project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml

{# wf_updated_on: 2016-09-28 #}
{# wf_published_on: 2016-09-28 #}

# PRPL 模式 {: .page-title }

{% include "web/_shared/contributors/addyosmani.html" %}

Dogfood：PRPL 是我們覺得非常有潛力的一種新模式。在這一階段，我們歡迎使用這一模式進行實驗，反覆在模式中測試我們的創意並收集此模式在哪些方面提供最大便利性的更多數據。



移動網絡非常慢。這些年，網絡已從以文檔爲中心的平臺演化爲一流的應用平臺。
有賴於平臺本身的進步（例如[服務工作線程](/web/fundamentals/getting-started/primers/service-workers)）以及我們用於構建應用的工具和技術，用戶在網絡上幾乎可以通過虛擬方式執行任何操作，就像在本機應用中操作一樣。





同時，我們大量的計算也已經發生變化，從使用快速、穩定網絡連接的強大桌面設備轉移到連接經常較慢、不穩定（或兩者兼有）的相對欠強大的移動設備上。特別是在孕育着下一批十億用戶的地方，這一點體現得尤爲真切。



很遺憾，我們在桌面時代設計用於構建和部署強大、功能豐富的網絡應用的模式通常會導致應用在移動設備上的加載時間過長 - 漫長的時間讓很多用戶選擇放棄應用。



這爲創建新模式提供了機會，新模式需要利用現代網絡平臺功能更快速、更精細地提供移動網絡體驗。PRPL 就是這樣一種模式。



## PRPL 模式

PRPL 是一種用於結構化和提供 Progressive Web App (PWA) 的模式，該模式強調應用交付和啓動的性能。
它代表：

*  **推送** - 爲初始網址路由推送關鍵資源。
*  **渲染** - 渲染初始路由。
*  **預緩存** - 預緩存剩餘路由。
*  **延遲加載** - 延遲加載並按需創建剩餘路由。

除了針對 PWA 的基本目標和標準外，PRPL 還竭力在以下方面進行優化：


* 儘可能減少交互時間
    * 特別是第一次使用（無論入口點在何處）
    * 特別是在真實的移動設備上
* 儘可能提高緩存效率，特別是在發佈更新時
* 開發和部署的簡易性

PRPL 的靈感來源於一套現代網絡平臺功能，不必在首字母縮略詞中打出每個字母或使用每個功能就可以應用這一模式。



實際上，PRPL 更多的是一種思維模式和提高移動網絡性能的長期願景，而不僅僅是特定技術或技巧。PRPL 背後的理念並不新，但該方法由 Polymer 團隊構建框架和命名，並在 [Google I/O 2016](https://www.youtube.com/watch?v=J4i0xJnQUzU) 上公佈。



Polymer 的 [Shop](https://shop.polymer-project.org) 電子商務演示是使用 PRPL 精細地提供資源的一流示例。它在真實的移動設備上以不可思議的速度爲每條路由實現交互性：




![Polymer 的 Shop 演示在 1.75 秒內實現交互](images/app-build-prpl-shop.png)

對於大多數真實項目，要純粹、完整地實現 PRPL 願景還爲時過早 - 但接受這種思維模式，或開始從多個角度追求這種願景絕對不早。在追尋 PRPL 的今天，應用開發者、工具開發者與瀏覽器廠商可以採取許多實用步驟。



## 應用結構

如果您的單頁面應用 (SPA) 採用以下結構，PRPL 完全適用：


-   應用的主_進入點_從每個有效的路由提供。
此文件應非常小，它從不同網址提供，因此會被緩存多次。
進入點的所有資源網址都需要是絕對網址，因爲它可以從非頂級網址提供。
-   _Shell_ 或 App Shell，包含頂級應用邏輯、路由器，等等。
-   延遲加載的應用_片段_。片段可以表示特定視圖的代碼，或可延遲加載的其他代碼（例如，首次繪製不需要的部分主應用，如用戶與應用交互前未顯示的菜單）。Shell 負責在需要時動態導入片段。


服務器和服務工作線程協同爲非活動路由預緩存資源。


用戶切換路由時，應用會延遲加載尚未緩存的任何所需資源，並創建所需視圖。
路由重複訪問應當可以立即交互。
服務工作線程這時可以提供很大幫助。

下圖顯示了使用[網絡組件](http://webcomponents.org/)構建的一個簡單應用的組件：


![具有兩個視圖的應用圖表，該應用包含獨立和共享的依賴項](images/app-build-components.png)


注：儘管 HTML 導入是 Polymer 的首選捆綁策略，您也可以使用代碼拆分和基於路由的分塊，通過現代 JavaScript 模塊捆綁程序實現相似的設置



在此圖表中，實線表示_靜態依賴項_：使用 `<link>` 和 `<script>` 標記在文件中標識的外部資源。
虛線表示_動態_或_按需加載的依賴項_：根據 Shell 所需加載的文件。



構建過程會構建一個包含所有這些依賴項的圖表，服務器會使用此信息高效地提供文件。
還會爲不支持 HTTP/2 的瀏覽器構建一組硬化捆綁包。


### 應用進入點

進入點必須導入和實例化 Shell，並且有條件地加載任何所需的 polyfill。


進入點的主要注意事項爲：

-   具有最少的靜態依賴項，換言之，除了 App Shell 本身外並沒有多少依賴項。
-   有條件地加載所需的 polyfill。
-   爲所有依賴項使用絕對路徑。

### App Shell

Shell 負責路由，通常包含應用的主導航 UI。


應用會根據需要延遲加載片段。例如，當用戶更換到新路由時，應用會導入與該路由相關的片段。這可能會向服務器發出新請求，或者只是從緩存加載資源。


Shell（包括其靜態依賴項）應包含第一次繪製所需的全部資源。


## 構建輸出

儘管使用 PRPL 沒有硬性要求，但您的構建過程仍會生成兩個構建：


-   設計用於服務器/瀏覽器組合的未捆綁構建，此類組合支持 HTTP/2，以便在優化緩存時傳輸第一次快速繪製所需的資源。可以使用 [`<link rel="preload">`][Resource hints]或 [HTTP/2 Push] 高效地觸發這些資源的傳輸。
-   設計用於最大程度減少所需往返次數的捆綁構建，使應用在不支持服務器推送的服務器/瀏覽器組合上運行時需要往返。



您的服務器邏輯會爲每個瀏覽器傳輸合適的構建。

### 捆綁的構建

對於不處理 HTTP/2 的瀏覽器，構建過程會生成一組不同的捆綁包：一個用於 Shell 的捆綁包，以及一個用於每個片段的捆綁包。下面的圖表顯示瞭如何使用網絡組件捆綁一個簡單的應用：


![同一應用的圖表，包含三個捆綁的依賴項](images/app-build-bundles.png)


兩個或多個片段共享的任何依賴項與 Shell 及其靜態依賴項相捆綁。


每個片段及其_未共享的_靜態依賴項捆綁到一個單獨的捆綁包中。
服務器應當返回合適版本的片段（捆綁或未捆綁），具體取決於瀏覽器。
這意味着 Shell 代碼可以延遲加載 `detail-view.html`，_無需瞭解是捆綁還是未捆綁_。它依靠服務器和瀏覽器來儘可能高效地加載依賴項。



## 背景：HTTP/2 和 HTTP/2 服務器推送

[HTTP/2] 允許在單個連接上_複用_下載，所以能夠更高效地下載多個小文件。


[HTTP/2 服務器推送][HTTP/2 Push]允許服務器搶先向瀏覽器發送資源。


以 HTTP/2 服務器推送如何加速下載爲例，考慮瀏覽器如何使用關聯的樣式表檢索 HTML 文件。


在 HTTP/1 中：

*   瀏覽器請求 HTML 文件。
*   服務器返回 HTML 文件，然後瀏覽器開始解析。
*   瀏覽器遇到 `<link rel="stylesheet">` 標記，啓動對樣式表的新請求。
*   瀏覽器接收樣式表。

對於 HTTP/2 推送：
*   瀏覽器請求 HTML 文件。
*   服務器返回 HTML 文件，同時推送樣式表。
*   瀏覽器開始解析 HTML。在瀏覽器遇到 `<linkrel="stylesheet"> 之前，樣式表已經位於緩存中。


在最簡單的情況下，HTTP/2 服務器推送可以去除一個 HTTP 請求響應。


在 HTTP/1 中，開發者可以捆綁資源來減少渲染頁面所需的 HTTP 請求數。
不過，捆綁會降低瀏覽器緩存的效率。如果每個頁面的資源整合到一個捆綁包中，每個頁面會獲得自己的捆綁包，瀏覽器將無法識別共享的資源。




結合 HTTP/2 和 HTTP/2 服務器推送帶來了捆綁的_好處_（延遲時間減少），而無需真正捆綁。
保持資源獨立意味着它們可以被高效地緩存且可以在頁面間共享。


需要小心使用 HTTP/2 推送，因爲即使文件已經位於瀏覽器的本地緩存中或帶寬已飽和，它都會對瀏覽器強制推送數據。如果操作錯誤，性能將降低。[`<link rel="preload">`][Resource hints] 能夠有效地使瀏覽器對設置這些請求的優先級做出明智的決定。

  

##  結論

更精細地爲路由加載代碼和讓瀏覽器更好地安排工作時間有助於在應用中更早實現交互性。我們需要**可以快速實現交互性的更優架構**，PRPL 模式是一個有趣的示例，它描繪瞭如何在真實的移動設備上實現此目標。



PRPL 模式很好地解決了餘量問題，在您完成抽象的加載後，它可以立即爲您提供足夠餘量。
如果點按某個鏈接時因爲阻止輸入事件分派的數秒腳本而出現延遲，這就是一個需要優化性能的強烈信號。眼下，使用較大的 JavaScript 庫構建的應用存在一個常見問題，UI 雖然正確渲染，但並不能按預期工作。



PRPL 僅需最少的功能代碼即可讓用戶所在的路由變得可交互，切實解決了這一問題。


[HTTP/2]: /web/fundamentals/performance/http2/
[Resource hints]: https://developers.google.com/web/updates/2016/03/link-rel-preload
[HTTP/2 Push]: /web/fundamentals/performance/http2/#server-push


{# wf_devsite_translation #}
