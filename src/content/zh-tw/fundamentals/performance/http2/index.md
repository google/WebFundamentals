project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml
description:HTTP/2（或 h2）是一種二進制協議，爲網絡帶來了推送、數據流複用和幀控制等功能。

{# wf_updated_on: 2017-07-13 #}
{# wf_published_on: 2016-09-29 #}

# HTTP/2 簡介 {: .page-title }

{% include "web/_shared/contributors/ilyagrigorik.html" %}
{% include "web/_shared/contributors/surma.html" %}

注：以下內容節選自[《Web 性能權威指南》](http://shop.oreilly.com/product/0636920028048.do)（O'Reilly，作者：Ilya Grigorik）。要了解完整版本和相關內容，請訪問 [hpbn.co](https://hpbn.co/){: .external }。


HTTP/2 可以讓我們的應用更快、更簡單、更穩定 - 這幾詞湊到一塊是很罕見的！HTTP/2 將很多以前我們在應用中針對 HTTP/1.1 想出來的“歪招兒”一筆勾銷，把解決那些問題的方案內置在了傳輸層中。不僅如此，它還爲我們進一步優化應用和提升性能提供了全新的機會！


HTTP/2 的目的是通過支持完整的請求與響應複用來減少延遲，通過有效壓縮 HTTP 標頭字段將協議開銷降至最低，同時增加對請求優先級和服務器推送的支持。爲達成這些目標，HTTP/2 還給我們帶來了大量其他協議層面的輔助實現，例如新的流控制、錯誤處理和升級機制。上述幾種機制雖然不是全部，但卻是最重要的，每一位網絡開發者都應該理解並在自己的應用中加以利用。

HTTP/2 沒有改動 HTTP 的應用語義。HTTP 方法、狀態代碼、URI 和標頭字段等核心概念一如往常。不過，HTTP/2 修改了數據格式化（分幀）以及在客戶端與服務器間傳輸的方式。這兩點統帥全局，通過新的分幀層向我們的應用隱藏了所有複雜性。因此，所有現有的應用都可以不必修改而在新協議下運行。


*爲什麼不是 HTTP/1.2？*

爲了實現 HTTP 工作組設定的性能目標，HTTP/2 引入了一個新的二進制分幀層，該層無法與之前的 HTTP/1.x 服務器和客戶端向後兼容，因此協議的主版本提升到 HTTP/2。

即便如此，除非您在實現網絡服務器（或自定義客戶端），需要使用原始的 TCP 套接字，否則您很可能注意不到任何區別：所有新的低級分幀由客戶端和服務器爲您執行。可觀察到的唯一區別將是性能的提升和請求優先級、流控制與服務器推送等新功能的出現。



## SPDY 與 HTTP/2 簡史

SPDY 是 Google 開發的一個實驗性協議，於 2009 年年中發佈，其主要目標是通過解決 HTTP/1.1 中廣爲人知的一些性能限制來減少網頁的加載延遲。具體來說，這個項目設定的目標如下：




* 頁面加載時間 (PLT) 減少 50%。
* 無需網站作者修改任何內容。
* 將部署複雜性降至最低，無需變更網絡基礎設施。
* 與開源社區合作開發這個新協議。
* 收集真實性能數據，驗證這個實驗性協議是否有效。

注：爲了達到減少 50% 頁面加載時間的目標，SPDY 引入了一個新的二進制分幀層，以實現請求和響應複用、優先級和標頭壓縮，目的是更有效地利用底層 TCP 連接；請參閱[延遲是性能瓶頸](https://hpbn.co/primer-on-web-performance/#latency-as-a-performance-bottleneck){: .external}。

首次發佈後不久，Google 的兩位軟件工程師 Mike Belshe 和 Roberto Peon 就分享了他們對這個新實驗性 SPDY 協議的實現結果、文檔和源代碼：

> 目前爲止，我們只在實驗室條件下測試過 SPDY。> 最初的成果很激動人心：通過模擬的家庭網絡連接下載了 25 個最流行的網站之後，我們發現性能的提升特別明顯，頁面加載速度最高加快了 55%。[*（Chromium 博客）*](https://blog.chromium.org/2009/11/2x-faster-web.html)



幾年後的 2012 年，這個新的實驗性協議得到了 Chrome、Firefox 和 Opera 的支持，越來越多的大型網站（如 Google、Twitter、Facebook）和小型網站開始在其基礎設施內部署 SPDY。事實上，在被行業越來越多的採用之後，SPDY 已經具備了成爲一個標準的條件。


觀察到這一趨勢後，HTTP 工作組 (HTTP-WG) 將這一工作提上議事日程，吸取 SPDY 的經驗教訓，並在此基礎上制定了官方“HTTP/2”標準。在擬定宣言草案、向社會徵集 HTTP/2 建議並經過內部討論之後，HTTP-WG 決定將 SPDY 規範作爲新 HTTP/2 協議的基礎。




在接下來幾年中，SPDY 和 HTTP/2 繼續共同演化，SPDY 作爲實驗性分支，用於爲 HTTP/2 標準測試新功能和建議。理論不一定適合實踐（反之亦然），SPDY 提供了一個測試和評估路線，可以對要包含到 HTTP/2 標準中的每條建議進行測試和評估。最終，這個過程持續了三年，期間產生了十餘箇中間草案：


* 2012 年 3 月：徵集 HTTP/2 建議
* 2012 年 11 月第一個 HTTP/2 草案（基於 SPDY）
* 2014 年 8 月：HTTP/2 草案 17 和 HPACK 草案 12 發佈
* 2014 年 8 月：工作組最後一次徵集 HTTP/2 建議
* 2015 年 2 月：IESG 批准 HTTP/2 和 HPACK 草案
* 2015 年 5 月：RFC 7540 (HTTP/2) 和 RFC 7541 (HPACK) 發佈

2015 年初，IESG 審閱了新的 HTTP/2 標準並批准發佈。
之後不久，Google Chrome 團隊公佈了他們爲 TLS 棄用 SPDY 和 NPN 擴展的時間表：


> 與 HTTP/1.1 相比，HTTP/2 的主要變化在於性能提升。> 一些主要功能（例如複用、標頭壓縮、優先級和協議協商）演化自之前開放但不標準的協議 (SPDY)。
> Chrome 自 Chrome 6 開始就支持 SPDY，但由於大部分優點都集中在 HTTP/2 中，是時候向 SPDY 說再見了。
> 我們計劃於 2016 年初停止對 SPDY 的支持，還會停止對 TLS 的 NPN 擴展的支持，轉而在 Chrome 中使用 ALPN。
> 強烈建議服務器開發者遷移到 HTTP/2 和 ALPN。
我們很高興參與到最終催生了 HTTP/2 的開放式標準制定過程，並且考慮到整個行業在標準化和實現過程中的參與熱情，我們希望對這一標準的採納越來越多。[*（Chromium 博客）*](https://blog.chromium.org/2015/02/hello-http2-goodbye-spdy.html)






SPDY 與 HTTP/2 的共同演化讓服務器、瀏覽器和網站開發者可以在新協議的制定過程中獲得真實體驗。因此，HTTP/2 標準自誕生之日起就成爲最好並經過大量測試的標準之一。到 HTTP/2 被 IESG 批准時，已經有很多經過完全測試並且可以立即投入生產的客戶端與服務器。事實上，在最終協議被批准的幾周後，由於多款熱門瀏覽器（和許多網站）都部署了完整的 HTTP/2 支持，大量用戶都體會到了新協議的好處。



## 設計和技術目標

早期版本的 HTTP 協議的設計初衷主要是實現要簡單：
HTTP/0.9 只用一行協議就啓動了萬維網；HTTP/1.0 則是對流行的 HTTP/0.9 擴展的一個正式說明；HTTP 1.1 則是 IETF 的一份官方標準；請參閱 [HTTP 簡史](https://hpbn.co/brief-history-of-http/){: .external}。因此，HTTP/0.9-1.x 只描述了現實是怎麼一回事：HTTP 是應用最廣泛、採用最多的一個互聯網應用協議。


然而，實現簡單是以犧牲應用性能爲代價的：
HTTP/1.x 客戶端需要使用多個連接才能實現併發和縮短延遲；HTTP/1.x 不會壓縮請求和響應標頭，從而導致不必要的網絡流量；HTTP/1.x 不支持有效的資源優先級，致使底層 TCP 連接的利用率低下；等等。





這些限制並不是致命的，但是隨着網絡應用的範圍、複雜性以及在我們日常生活中的重要性不斷增大，它們對網絡開發者和用戶都造成了巨大負擔，而這正是 HTTP/2 要致力於解決的：




> HTTP/2 通過支持標頭字段壓縮和在同一連接上進行多個併發交換，讓應用更有效地利用網絡資源，減少感知的延遲時間。具體來說，它可以對同一連接上的請求和響應消息進行交錯發送併爲 HTTP 標頭字段使用有效編碼。
> HTTP/2 還允許爲請求設置優先級，讓更重要的請求更快速地完成，從而進一步提升性能。出臺的協議對網絡更加友好，因爲與 HTTP/1.x 相比，可以使用更少的 TCP 連接。

> 這意味着與其他流的競爭減小，並且連接的持續時間變長，這些特性反過來提高了可用網絡容量的利用率。
> 最後，HTTP/2 還可以通過使用二進制消息分幀對消息進行更高效的處理。[*（超文本傳輸協議版本 2，草案 17）*](https://tools.ietf.org/html/draft-ietf-httpbis-http2-17)





需要注意的是，HTTP/2 仍是對之前 HTTP 標準的擴展，而非替代。
HTTP 的應用語義不變，提供的功能不變，HTTP 方法、狀態代碼、URI 和標頭字段等這些核心概念也不變。這些方面的變化都不在 HTTP/2 考慮之列。
雖然高級 API 保持不變，仍有必要了解低級變更如何解決了之前協議的性能限制。我們來簡單瞭解一下二進制分幀層及其功能。


## 二進制分幀層

HTTP/2 所有性能增強的核心在於新的二進制分幀層，它定義瞭如何封裝 HTTP 消息並在客戶端與服務器之間傳輸。



![HTTP/2 二進制分幀層](images/binary_framing_layer01.svg)

這裏所謂的“層”，指的是位於套接字接口與應用可見的高級 HTTP API 之間一個經過優化的新編碼機制：HTTP 的語義（包括各種動詞、方法、標頭）都不受影響，不同的是傳輸期間對它們的編碼方式變了。HTTP/1.x 協議以換行符作爲純文本的分隔符，而 HTTP/2 將所有傳輸的信息分割爲更小的消息和幀，並採用二進制格式對它們編碼。







這樣一來，客戶端和服務器爲了相互理解，都必須使用新的二進制編碼機制：HTTP/1.x 客戶端無法理解只支持 HTTP/2 的服務器，反之亦然。不過不要緊，現有的應用不必擔心這些變化，因爲客戶端和服務器會替我們完成必要的分幀工作。



## 數據流、消息和幀

新的二進制分幀機制改變了客戶端與服務器之間交換數據的方式。
爲了說明這個過程，我們需要了解 HTTP/2 的三個概念：


* *數據流*：已建立的連接內的雙向字節流，可以承載一條或多條消息。
* *消息*：與邏輯請求或響應消息對應的完整的一系列幀。
* *幀*：HTTP/2 通信的最小單位，每個幀都包含幀頭，至少也會標識出當前幀所屬的數據流。


這些概念的關係總結如下：

* 所有通信都在一個 TCP 連接上完成，此連接可以承載任意數量的雙向數據流。
* 每個數據流都有一個唯一的標識符和可選的優先級信息，用於承載雙向消息。
* 每條消息都是一條邏輯 HTTP 消息（例如請求或響應），包含一個或多個幀。
* 幀是最小的通信單位，承載着特定類型的數據，例如 HTTP 標頭、消息負載，等等。
來自不同數據流的幀可以交錯發送，然後再根據每個幀頭的數據流標識符重新組裝。


![HTTP/2 數據流、消息和幀](images/streams_messages_frames01.svg)

簡言之，HTTP/2 將 HTTP 協議通信分解爲二進制編碼幀的交換，這些幀對應着特定數據流中的消息。所有這些都在一個 TCP 連接內複用。這是 HTTP/2 協議所有其他功能和性能優化的基礎。


## 請求與響應複用

在 HTTP/1.x 中，如果客戶端要想發起多個並行請求以提升性能，則必須使用多個 TCP 連接（請參閱[使用多個 TCP 連接](https://hpbn.co/http1x/#using-multiple-tcp-connections)）。這是 HTTP/1.x 交付模型的直接結果，該模型可以保證每個連接每次只交付一個響應（響應排隊）。更糟糕的是，這種模型也會導致隊首阻塞，從而造成底層 TCP 連接的效率低下。


HTTP/2 中新的二進制分幀層突破了這些限制，實現了完整的請求和響應複用：客戶端和服務器可以將 HTTP 消息分解爲互不依賴的幀，然後交錯發送，最後再在另一端把它們重新組裝起來。




![一個共享連接內的 HTTP/2 請求和響應複用](images/multiplexing01.svg)

快照捕捉了同一個連接內並行的多個數據流。客戶端正在向服務器傳輸一個 `DATA` 幀（數據流 5），與此同時，服務器正向客戶端交錯發送數據流 1 和數據流 3 的一系列幀。因此，一個連接上同時有三個並行數據流。




將 HTTP 消息分解爲獨立的幀，交錯發送，然後在另一端重新組裝是 HTTP 2 最重要的一項增強。事實上，這個機制會在整個網絡技術棧中引發一系列連鎖反應，從而帶來巨大的性能提升，讓我們可以：





* 並行交錯地發送多個請求，請求之間互不影響。
* 並行交錯地發送多個響應，響應之間互不干擾。
* 使用一個連接並行發送多個請求和響應。
* 不必再爲繞過 HTTP/1.x 限制而做很多工作（請參閱[針對 HTTP/1.x 進行優化](https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x)，例如級聯文件、image sprites 和域名分片。
* 消除不必要的延遲和提高現有網絡容量的利用率，從而減少頁面加載時間。
* *等等…*

HTTP/2 中的新二進制分幀層解決了 HTTP/1.x 中存在的隊首阻塞問題，也消除了並行處理和發送請求及響應時對多個連接的依賴。結果，應用速度更快、開發更簡單、部署成本更低。


## 數據流優先級

將 HTTP 消息分解爲很多獨立的幀之後，我們就可以複用多個數據流中的幀，客戶端和服務器交錯發送和傳輸這些幀的順序就成爲關鍵的性能決定因素。爲了做到這一點，HTTP/2 標準允許每個數據流都有一個關聯的權重和依賴關係：


* 可以向每個數據流分配一個介於 1 至 256 之間的整數。
* 每個數據流與其他數據流之間可以存在顯式依賴關係。

數據流依賴關係和權重的組合讓客戶端可以構建和傳遞“優先級樹”，表明它傾向於如何接收響應。反過來，服務器可以使用此信息通過控制 CPU、內存和其他資源的分配設定數據流處理的優先級，在資源數據可用之後，帶寬分配可以確保將高優先級響應以最優方式傳輸至客戶端。




![HTTP/2 數據流依賴關係和權重](images/stream_prioritization01.svg)

HTTP/2 內的數據流依賴關係通過將另一個數據流的唯一標識符作爲父項引用進行聲明；如果忽略標識符，相應數據流將依賴於“根數據流”。聲明數據流依賴關係指出，應儘可能先向父數據流分配資源，然後再向其依賴項分配資源。換句話說，“請先處理和傳輸響應 D，然後再處理和傳輸響應 C”。


共享相同父項的數據流（即，同級數據流）應按其權重比例分配資源。
例如，如果數據流 A 的權重爲 12，其同級數據流 B 的權重爲 4，那麼要確定每個數據流應接收的資源比例，請執行以下操作：



1. 將所有權重求和：`4 + 12 = 16`
2. 將每個數據流權重除以總權重：`A = 12/16, B = 4/16`因此，數據流 A 應獲得四分之三的可用資源，數據流 B 應獲得四分之一的可用資源；數據流 B 獲得的資源是數據流 A 所獲資源的三分之一。我們來看一下上圖中的其他幾個動手示例：順序爲從左到右：
1. 數據流 A 和數據流 B 都沒有指定父依賴項，依賴於顯式“根數據流”；A 的權重爲 12，B 的權重爲 4。因此，根據比例權重：數據流 B 獲得的資源是 A 所獲資源的三分之一。
2. 數據流 D 依賴於根數據流；C 依賴於 D。因此，D 應先於 C 獲得完整資源分配。權重不重要，因爲 C 的依賴關係擁有更高的優先級。
3. 數據流 D 應先於 C 獲得完整資源分配；C 應先於 A 和 B 獲得完整資源分配；數據流 B 獲得的資源是 A 所獲資源的三分之一。
4. 數據流 D 應先於 E 和 C 獲得完整資源分配；E 和 C 應先於 A 和 B 獲得相同的資源分配；A 和 B 應基於其權重獲得比例分配。










如上面的示例所示，數據流依賴關係和權重的組合明確表達了資源優先級，這是一種用於提升瀏覽性能的關鍵功能，網絡中擁有多種資源類型，它們的依賴關係和權重各不相同。不僅如此，HTTP/2 協議還允許客戶端隨時更新這些優先級，進一步優化了瀏覽器性能。換句話說，我們可以根據用戶互動和其他信號更改依賴關係和重新分配權重。


注：數據流依賴關係和權重表示傳輸優先級，而不是要求，因此不能保證特定的處理或傳輸順序。即，客戶端無法強制服務器通過數據流優先級以特定順序處理數據流。
儘管這看起來違反直覺，但卻是一種必要行爲。
我們不希望在優先級較高的資源受到阻止時，還阻止服務器處理優先級較低的資源。



## 每個來源一個連接

有了新的分幀機制後，HTTP/2 不再依賴多個 TCP 連接去並行複用數據流；每個數據流都拆分成很多幀，而這些幀可以交錯，還可以分別設定優先級。因此，所有 HTTP/2 連接都是永久的，而且僅需要每個來源一個連接，隨之帶來諸多性能優勢。



> SPDY 和 HTTP/2 的殺手級功能是，可以在一個擁塞受到良好控制的通道上任意進行復用。
> 這一功能的重要性和良好運行狀況讓我吃驚。
> 我喜歡的一個非常不錯的指標是連接拆分，這些拆分僅承載一個 HTTP 事務（並因此讓該事務承擔所有開銷）。
> 對於 HTTP/1，我們 74% 的活動連接僅承載一個事務 - 永久連接並不如我們所有人希望的那般有用。
> 但是在 HTTP/2 中，這一比例銳減至 25%。[*（HTTP/2 登陸 Firefox，Patrick McManus）*](http://bitsup.blogspot.co.uk/2015/02/http2-is-live-in-firefox.html)



大多數 HTTP 傳輸都是短暫且急促的，而 TCP 則針對長時間的批量數據傳輸進行了優化。
通過重用相同的連接，HTTP/2 既可以更有效地利用每個 TCP 連接，也可以顯著降低整體協議開銷。不僅如此，使用更少的連接還可以減少佔用的內存和處理空間，也可以縮短完整連接路徑（即，客戶端、可信中介和源服務器之間的路徑）這降低了整體運行成本並提高了網絡利用率和容量。
因此，遷移到 HTTP/2 不僅可以減少網絡延遲，還有助於提高通量和降低運行成本。



注：連接數量減少對提升 HTTPS 部署的性能來說是一項特別重要的功能：可以減少開銷較大的 TLS 連接數、提升會話重用率，以及從整體上減少所需的客戶端和服務器資源。




## 流控制

流控制是一種阻止發送方向接收方發送大量數據的機制，以免超出後者的需求或處理能力：發送方可能非常繁忙、處於較高的負載之下，也可能僅僅希望爲特定數據流分配固定量的資源。例如，客戶端可能請求了一個具有較高優先級的大型視頻流，但是用戶已經暫停視頻，客戶端現在希望暫停或限制從服務器的傳輸，以免提取和緩衝不必要的數據。再比如，一個代理服務器可能具有較快的下游連接和較慢的上游連接，並且也希望調節下游連接傳輸數據的速度以匹配上游連接的速度來控制其資源利用率；等等。




上述要求會讓您想到 TCP 流控制嗎？您應當想到這一點；因爲問題基本相同（請參閱[流控制](https://hpbn.co/building-blocks-of-tcp/#flow-control)）。不過，由於 HTTP/2 數據流在一個 TCP 連接內複用，TCP 流控制既不夠精細，也無法提供必要的應用級 API 來調節各個數據流的傳輸。爲了解決這一問題，HTTP/2 提供了一組簡單的構建塊，這些構建塊允許客戶端和服務器實現其自己的數據流和連接級流控制：




* 流控制具有方向性。每個接收方都可以根據自身需要選擇爲每個數據流和整個連接設置任意的窗口大小。
* 流控制基於信用。每個接收方都可以公佈其初始連接和數據流流控制窗口（以字節爲單位），每當發送方發出 `DATA` 幀時都會減小，在接收方發出 `WINDOW_UPDATE` 幀時增大。
* 流控制無法停用。建立 HTTP/2 連接後，客戶端將與服務器交換 `SETTINGS` 幀，這會在兩個方向上設置流控制窗口。流控制窗口的默認值設爲 65,535 字節，但是接收方可以設置一個較大的最大窗口大小（`2^31-1` 字節），並在接收到任意數據時通過發送 `WINDOW_UPDATE` 幀來維持這一大小。
* 流控制爲逐躍點控制，而非端到端控制。即，可信中介可以使用它來控制資源使用，以及基於自身條件和啓發式算法實現資源分配機制。



HTTP/2 未指定任何特定算法來實現流控制。不過，它提供了簡單的構建塊並推遲了客戶端和服務器實現，可以實現自定義策略來調節資源使用和分配，以及實現新傳輸能力，同時提升網絡應用的實際性能和感知性能（請參閱[速度、性能和人類感知](https://hpbn.co/primer-on-web-performance/#speed-performance-and-human-perception)）。







例如，應用層流控制允許瀏覽器僅提取一部分特定資源，通過將數據流流控制窗口減小爲零來暫停提取，稍後再行恢復。換句話說，它允許瀏覽器提取圖像預覽或首次掃描結果，進行顯示並允許其他高優先級提取繼續，然後在更關鍵的資源完成加載後恢復提取。




## 服務器推送

HTTP/2 新增的另一個強大的新功能是，服務器可以對一個客戶端請求發送多個響應。
換句話說，除了對最初請求的響應外，服務器還可以向客戶端推送額外資源（圖 12-5），而無需客戶端明確地請求。




![服務器爲推送資源發起新數據流 (promise)](images/push01.svg)


注：HTTP/2 打破了嚴格的請求-響應語義，支持一對多和服務器發起的推送工作流，在瀏覽器內外開啓了全新的互動可能性。這是一項使能功能，對我們思考協議、協議用途和使用方式具有重要的長期影響。



爲什麼在瀏覽器中需要一種此類機制呢？一個典型的網絡應用包含多種資源，客戶端需要檢查服務器提供的文檔才能逐個找到它們。那爲什麼不讓服務器提前推送這些資源，從而減少額外的延遲時間呢？服務器已經知道客戶端下一步要請求什麼資源，這時候服務器推送即可派上用場。


事實上，如果您在網頁中內聯過 CSS、JavaScript，或者通過數據 URI 內聯過其他資產（請參閱[資源內聯](https://hpbn.co/http1x/#resource-inlining)），那麼您就已經親身體驗過服務器推送了。對於將資源手動內聯到文檔中的過程，我們實際上是在將資源推送給客戶端，而不是等待客戶端請求。使用 HTTP/2，我們不僅可以實現相同結果，還會獲得其他性能優勢。
推送資源可以進行以下處理：

* 由客戶端緩存
* 在不同頁面之間重用
* 與其他資源一起復用
* 由服務器設定優先級
* 被客戶端拒絕

### PUSH_PROMISE 101

所有服務器推送數據流都由 `PUSH_PROMISE` 幀發起，表明了服務器向客戶端推送所述資源的意圖，並且需要先於請求推送資源的響應數據傳輸。這種傳輸順序非常重要：客戶端需要了解服務器打算推送哪些資源，以免爲這些資源創建重複請求。滿足此要求的最簡單策略是先於父響應（即，`DATA` 幀）發送所有 `PUSH_PROMISE` 幀，其中包含所承諾資源的 HTTP 標頭。



在客戶端接收到 `PUSH_PROMISE` 幀後，它可以根據自身情況選擇拒絕數據流（通過 `RST_STREAM` 幀）。
（如果資源已經位於緩存中，可能會發生這種情況。）
這是一個相對於 HTTP/1.x 的重要提升。
相比之下，使用資源內聯（一種受歡迎的 HTTP/1.x“優化”）等同於“強制推送”：客戶端無法選擇拒絕、取消或單獨處理內聯的資源。



使用 HTTP/2，客戶端仍然完全掌控服務器推送的使用方式。客戶端可以限制並行推送的數據流數量；調整初始的流控制窗口以控制在數據流首次打開時推送的數據量；或完全停用服務器推送。這些優先級在 HTTP/2 連接開始時通過 `SETTINGS` 幀傳輸，可能隨時更新。



推送的每個資源都是一個數據流，與內嵌資源不同，客戶端可以對推送的資源逐一複用、設定優先級和處理。
瀏覽器強制執行的唯一安全限制是，推送的資源必須符合原點相同這一政策：服務器對所提供內容必須具有權威性。




## 標頭壓縮

每個 HTTP 傳輸都承載一組標頭，這些標頭說明了傳輸的資源及其屬性。
在 HTTP/1.x 中，此元數據始終以純文本形式，通常會給每個傳輸增加 500–800 字節的開銷。如果使用 HTTP Cookie，增加的開銷有時會達到上千字節。（請參閱[測量和控制協議開銷](https://hpbn.co/http1x/#measuring-and-controlling-protocol-overhead)。）爲了減少此開銷和提升性能，HTTP/2 使用 HPACK 壓縮格式壓縮請求和響應標頭元數據，這種格式採用兩種簡單但是強大的技術：



1. 這種格式支持通過靜態 Huffman 代碼對傳輸的標頭字段進行編碼，從而減小了各個傳輸的大小。
2. 這種格式要求客戶端和服務器同時維護和更新一個包含之前見過的標頭字段的索引列表（換句話說，它可以建立一個共享的壓縮上下文），此列表隨後會用作參考，對之前傳輸的值進行有效編碼。





利用 Huffman 編碼，可以在傳輸時對各個值進行壓縮，而利用之前傳輸值的索引列表，我們可以通過傳輸索引值的方式對重複值進行編碼，索引值可用於有效查詢和重構完整的標頭鍵值對。




![HPACK：HTTP/2 的標頭壓縮](images/header_compression01.svg)

作爲一種進一步優化方式，HPACK 壓縮上下文包含一個靜態表和一個動態表：靜態表在規範中定義，並提供了一個包含所有連接都可能使用的常用 HTTP 標頭字段（例如，有效標頭名稱）的列表；動態表最初爲空，將根據在特定連接內交換的值進行更新。因此，爲之前未見過的值採用靜態 Huffman 編碼，並替換每一側靜態表或動態表中已存在值的索引，可以減小每個請求的大小。




注：在 HTTP/2 中，請求和響應標頭字段的定義保持不變，僅有一些微小的差異：所有標頭字段名稱均爲小寫，請求行現在拆分成各個 `:method`、`:scheme`、`:authority` 和 `:path` 僞標頭字段。




### HPACK 的安全性和性能

早期版本的 HTTP/2 和 SPDY 使用 zlib（帶有一個自定義字典）壓縮所有 HTTP 標頭。
這種方式可以將所傳輸標頭數據的大小減小 85% - 88%，顯著減少了頁面加載時間延遲：



> 在帶寬較低的 DSL 鏈路中，上行鏈路速度僅有 375 Kbps，僅壓縮請求標頭就顯著減少了特定網站（即，發出大量資源請求的網站）的頁面加載時間。
> 我們發現，僅僅由於標頭壓縮，頁面加載時間就減少了 45 - 1142 毫秒。[*（SPDY 白皮書，chromium.org）*](https://www.chromium.org/spdy/spdy-whitepaper)



然而，2012 年夏天，出現了針對 TLS 和 SPDY 壓縮算法的“犯罪”安全攻擊，此攻擊會導致會話被劫持。
於是，zlib 壓縮算法被 HPACK 替代，後者經過專門設計，可以解決發現的安全問題、實現起來也更高效和簡單，當然，可以對 HTTP 標頭元數據進行良好壓縮。

如需瞭解有關 HPACK 壓縮算法的完整詳情，請參閱 <https://tools.ietf.org/html/draft-ietf-httpbis-header-compression>。


## 深入閱讀：

* [“HTTP/2”](https://hpbn.co/http2/){: .external } - Ilya Grigorik 所著的完整文章
* [“設置 HTTP/2”](https://surma.link/things/h2setup/){: .external } - 如何在不同的後端中設置 HTTP/2，作者：Surma
* [“HTTP/2”
  已經粉墨登場，我們一起優化性能吧！”](https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/edit#slide=id.p19)
  - Ilya Grigorik 在 Velocity 2015 上所作的演示
* [“HTTP/2 推送的經驗法則”](https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit)- Tom Bergan、Simon Pelchat 和 Michael Buettner 對何時以及如何使用推送的分析。



{# wf_devsite_translation #}
