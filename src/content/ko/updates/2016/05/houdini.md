project_path: /web/_project.yaml
book_path: /web/updates/_book.yaml
description: Houdini is a collection of APIs that expose the CSS engine’s internals to developers

{# wf_updated_on: 2017-03-23 #}
{# wf_published_on: 2016-05-19 #}
{# wf_tags: houdini,css #}
{# wf_featured_image: /web/updates/images/2016/05/houdini/compworklet_small.png #}

# Houdini: Demystifying CSS {: .page-title }

{% include "web/_shared/contributors/surma.html" %}

참고: 본 글의 각 문단들을 연관 표준의 최신 내용으로 업데이트하고 있습니다.

CSS가 할 수 있는 일들을 생각해본 적이 있나요? 여러분이 하나의 attribute를 바꾸면 전체 웹 페이지는 완전히 다른 레이아웃으로
 보여집니다. 그런 점에 있어서 마법과도 같죠. (앞으로 제가 무슨 말을 할 지 감이 오시나요?!) 지금까지 우리 웹 개발자들은
이러한 마법을 바라보기만 할 수 있었습니다. 만약 우리가 우리만의 마법을 부리고 싶다면요? 만약 우리가 마법사가 되고 싶다면요?
Houdini를 시작해보세요!

Houdini task force는 Mozilla, Apple, Opera, Microsoft, HP, Intel 그리고 Google의 엔지니어들로 구성되어 (번역자: LG도 있습니다!)
CSS 엔진의 일부분에 웹 개발자들이 접근할 수 있게 하도록 협업하고 있습니다. 이 task force는 공식 W3C 표준으로 채택되기 위한
표준 초안들을 작성하고 있습니다. 그들은 표준안에 대한 몇 가지 높은 수준의 목표를 세워 표준 초안을 작성하였으며 이를 기반으로
하위 수준 사양의 표준 문서들이 개발되었습니다. 이 표준 문서들은 누군가가 “Houdini”에 대해 이야기할 때 보통 의미하는 것입니다.
표준안 개발 작업이 진행되는 동안 표준 문서 초안들은 미완성 단계이며 일부 초안은 다소 가안일 수 있습니다.
그것이 우리가 Houdini를 개발하는 초기 단계입니다.

<div class="video-wrapper-full-width">
  <iframe class="devsite-embedded-youtube-video" data-video-id="EUlIxr8mk7s"
          data-autohide="1" data-showinfo="0" frameborder="0" allowfullscreen>
  </iframe>
</div>

주의: 저는 Houdini 표준안에 대한 간단한 개요를 통해 Houdini에서 어떠한 문제를 풀고자하는지 알려드리고 싶었습니다.
현재의 표준안이 지원 가능한 수준에서, 코드 샘플 또한 보여드립니다. 표준안들은 계속 수정되고 있는 초안임을 유념하시길 바랍니다.
향후에 본 글에서 설명하고 있는 코드의 결과는 정확하지 않을 수 있고, 일부 표준안의 내용은 공식 표준이 되지 않을 수 있습니다.

## 표준안

### Worklets
([spec][Worklets spec])

Worklets 자체는 큰 의미가 있지는 않습니다. Worklets는 다른 연관 표준안을 가능하게 하기 위해 도입된 개념입니다.
“Worklet”을 접했을 때 Web Workers를 떠올린다면 틀린 것은 아닙니다. 그 둘은 많은 개념적인 유사성을 가지고 있습니다.
그렇다면 이미 Workers가 있는데 왜 새로운 개념이 생겼을까요? Houdini의 목표는 웹 개발자가 자신의 코드를 CSS 엔진과
주변 시스템에 연결할 수 있도록 새로운 API를 제공하는 것입니다.  아마도 이러한 코드의 일부가 모든, 단일 프레임에서
실행되어야 한다고 가정하는 것은 비 현실적이지 않을 것입니다. 어쩌면 당연히 그렇게 되어야 합니다.
[Web Worker 표준]에는 다음과 같은 내용이 있습니다.:

> Workers [...] 는 상대적으로 무거우며 한 페이지에 많은 수의 Workers 사용은 권장하지 않습니다. 예를 들어 4 mega pixel
이미지의 각 pixel마다 하나의 Worker를 생성하는 것은 적절하지 않습니다.

이는 곧 web workers가 Houdini가 하려고 했던 것을 하기에는 무리라는 의미입니다. 따라서 worklets이 만들어졌습니다.
Worklets은 ES2015의 class들을 써서 method 집합들, worklet의 미리 정의된 타입인 signature들을 정의합니다.
그렇기 때문에 Worklet은 보다 경량화가 되었으며 수명 주기가 짧습니다.

### Paint worklet
([spec][Paint Worklet spec])

**Status update:** First incomplete implementation landed in Chrome Canary behind the
“Experimental Web Platform features” flag.

I am starting with this as it is introduces the fewest new concepts. From the
spec draft itself:

> The paint stage of CSS is responsible for painting the background, content and
highlight of an element based on that element’s geometry (as generated by the
layout stage) and computed style.

At the current level of the spec, you can create border
and background images dynamically. This allows you to do a lot of new things
like having a ripple effect on buttons without creating additional DOM elements.
Another big advantage of running your code at an element's paint time over
using a `<canvas>` element is that you will know the size of the element you are
painting and that you will be aware of the fragments and handle them appropriately.

Wait, what are fragments?

#### Fragments

I think of elements in the DOM tree as boxes that are laid out by the CSS engine
to make up my website. This model is flawed when inline elements come into play.
A `<span>` may need to be wrapped; so while still technically being a single DOM
node, it has been *fragmented* into 2, well, *fragments*. The [spec][Fragmentation spec]
calls the bounding box of these 2 fragments a *fragmentainer*. (I am not kidding.)

<img src="/web/updates/images/2016/05/houdini/fragment.png">

Back to the Paint Worklet: effectively, your code will get called for each
fragment and will be given access to a stripped down `<canvas>`-like API as well
as the styles applied to the element. Eventually, you  will even be able to request
an “overflow” margin to allow you to draw effects *around* the element’s boundaries,
just like `box-shadow`.


    class {
      static get inputProperties() {
        return ['border-color', 'border-size'];
      }
      paint(ctx, geom, inputProperties) {
        var offset = inputProperties['border-size']
        var colors = inputProperties['border-color'];
        self.drawFadingEdge(
          ctx,
          0-offset[0], 0-offset[0],
          geom.width+offset[0], 0-offset[0],
          color[0]);
        self.drawFadingEdge(
          ctx,
          geom.width+offset[1], 0-offset[1],
          geom.width+offset[1], geom.height+offset[1],
          color[1]);
        self.drawFadingEdge(
          ctx, 0-offset[2],
          geom.height+offset[2], geom.width+offset[2],
          geom.height+offset[2],
          color[2]);
        self.drawFadingEdge(
          ctx,
          0-offset[3], 0-offset[3],
          0-offset[3], geom.height+offset[3],
          color[3]);
      }
      drawFadingEdge(ctx, x0, y0, x1, y1, color) {
        var gradient =
          ctx.createLinearGradient(x0, y0, x1, y1);
        gradient.addColorStop(0, color);
        var colorCopy = new ColorValue(color);
        colorCopy.opacity = 0;
        gradient.addColorStop(0.5, colorCopy);
        gradient.addColorStop(1, color);
      }
      overflow(inputProperties) {
        // Taking a wild guess here. The return type
        // of overflow() is currently specified
        // as `void`, lol.
        return {
          top: inputProperties['border-size'][0],
          right: inputProperties['border-size'][1],
          bottom: inputProperties['border-size'][2],
          left: inputProperties['border-size'][3],
        };
      }
    };


Here is a video of a ripple [implementation][Paint Worklet source] that uses
the Paint Worklet API ([Demo][Paint Worklet demo]).

<div class="video-wrapper-full-width">
  <iframe class="devsite-embedded-youtube-video" data-video-id="BX_qv2yKSUk"
          data-autohide="1" data-showinfo="0" frameborder="0" allowfullscreen>
  </iframe>
</div>

### Compositor worklet

참고: 이 곳에 서술된 API는 더 이상 사용되지 않습니다. Compositor worklet 는 현재 “Animation Worklet”으로
새로 디자인되었습니다. 해당 API에 대한 더 자세한 사항은
[여기](https://dassur.ma/things/animworklet/)에서 찾아보실 수 있습니다.


Compositor Worklet이 WICG로 옮겨졌고 계속 내용이 바뀌고 있지만, 저에게는 가장 흥미로운 표준안입니다. 아시다시피 일부 작업은 CSS 엔진에 의해 그래픽 카드로 아웃소싱되며 일반적으로 그래픽 카드와 장치 모두에 의존합니다. 브라우저는 일반적으로 DOM 트리를 사용하고 특정 기준에 따라 일부 branch 혹은 하위 트리에 자체 [레이어][HTML5Rocks layers]를 공개합니다.
이러한 하위 트리는 스스로 해당 레이어에 그립니다. (향후에는 paint worklet을 사용하여 그릴 수도 있겠죠!) 마지막 단계로, 페인트 과정이 완료된 모든 개별 레이어는 z-index, 3D Transform등을 고려하여 서로 중첩이 디어 화면에 보이는 최종 이미지를 완성합니다. 이 프로세스를 “컴포지팅 (Compositing)”이라고 하며 컴포지터(Compositor)가 실행합니다. 이 프로세스의 장점은 페이지가 조금 스크롤될 때 *모든* 요소를 다시 그릴 필요가 없다는 것입니다. 대신, 이전 프레임에서 레이어를 재사용하고 변경된 스크롤 위치로 컴포지터를 다시 실행할 수 있습니다. 이로 인하여 빠른 처리가 가능합니다. 이는 60fps를 맞출수 있게 해줍니다. 이것은 [Paul Lewis]를 행복합니다.

<img src="/web/updates/images/2016/05/houdini/compworklet_small.png">

이름에서 알 수 있듯이 compositor worklet을 사용하면 컴포지션에 연결하여 이미 그린 레이어의 요소 레이어를 다른 레이어 위에 배치하고 레이어에 적용하는 방식에 영향을 줄 수 있습니다. 좀 더 구체적으로 설명하면, 특정 DOM 노드의 컴포지팅 과정에 연결하고 스크롤 위치, `transform` 또는 `opacity`와 같은 특정 속성에 대한 액세스를 요청할 수 있다고 브라우저에 알릴 수 있습니다. 이러한 방법으로 해당 요소는 자체의 레이어에서, 또한 여러분의 코드는 *각 프레임*에서 실행되게 해줍니다. 여러분은 레이어 변환을 조작하여 레이어를 이동시킬 수 있고 레이어의 속성 (`opacity` 같은)을 변경하여 60fps에서 실행되는 무엇인가 매우 멋진 것들을 구현할 수 있습니다. 다음 예제는 compositor worklet을 사용하여 parallax scrolling을 구현한 *전체* 코드입니다.

    // main.js
    window.compositorWorklet.import('worklet.js')
      .then(function() {
        var animator = new CompositorAnimator('parallax');
        animator.postMessage([
          new CompositorProxy($('.scroller'), ['scrollTop']),
          new CompositorProxy($('.parallax'), ['transform']),
        ]);
      });

    // worklet.js
    registerCompositorAnimator('parallax', class {
      tick(timestamp) {
        var t = self.parallax.transform;
        t.m42 = -0.1 * self.scroller.scrollTop;
        self.parallax.transform = t;
      }

      onmessage(e) {
        self.scroller = e.data[0];
        self.parallax = e.data[1];
      };
    });


저의 동료 Robert Flack이 Compositor Worklet을 위한 [polyfill][CompWorklet polyfill]을
구현했으니 사용해보세요 - 확실히 성능이 향상된 것을 볼 수 있습니다.

### Layout worklet
([spec][Layout Worklet spec])

Note: First real spec draft has been been proposed. Implementation
is a good while away.

Again, the specification for this is practically empty, but the concept is
intriguing: write your own layout! The layout worklet is supposed to enable you
to do `display: layout('myLayout')` and run your JavaScript to arrange a node’s
children in the node’s box. Of course, running a full JavaScript implementation
of CSS’s `flex-box` layout will be slower than running an equivalent native
implementation, but it’s easy to imagine a scenario where cutting corners can
yield a performance gain. Imagine a website consisting of nothing but tiles á la
Windows 10 or a [Masonry]-style layout. Absolute/fixed positioning is not used,
neither is `z-index` nor do elements ever overlap or have any kind of border or
overflow. Being able to skip all these checks on re-layout could yield a
performance gain.


    registerLayout('random-layout', class {
        static get inputProperties() {
          return [];
        }
        static get childrenInputProperties() {
          return [];
        }
        layout(children, constraintSpace, styleMap) {
            Const width = constraintSpace.width;
            Const height =constraintSpace.height;
            for (let child of children) {
                const x = Math.random()*width;
                const y = Math.random()*height;
                const constraintSubSpace = new ConstraintSpace();
                constraintSubSpace.width = width-x;
                constraintSubSpace.height = height-y;
                const childFragment = child.doLayout(constraintSubSpace);
                childFragment.x = x;
                childFragment.y = y;
            }

            return {
                minContent: 0,
                maxContent: 0,
                width: width,
                height: height,
                fragments: [],
                unPositionedChildren: [],
                breakToken: null
            };
        }
    });


### Typed CSSOM
([spec][Typed CSSOM spec])

Note: An “almost complete” implementation has landed in Chrome Canary
behind the “Experimental Web Platform features” flag.

Typed CSSOM (CSS Object Model or Cascading Style Sheets Object Model) addresses a
problem we probably all have encountered and just learned to just put up with.
Let me illustrate with a line of JavaScript:


    $('#someDiv').style.height = getRandomInt() + 'px';


We are doing math, converting a number to a string to append a unit just to have
the browser parse that string and convert it back to a number for the CSS engine.
This gets even uglier when you [manipulate transforms with JavaScript][Aerotwist FLIP].
No more! CSS is about to get some typing!

This draft is one of the more mature ones and a [polyfill][Typed CSSOM polyfill] is
already being worked on. (Disclaimer: using the polyfill will obviously
add *even more* computational overhead. The point is to show how convenient the
API is.)

Instead of strings you will be working on an element’s `StylePropertyMap`, where
each CSS attribute has it’s own key and corresponding value type. Attributes
like `width` have `LengthValue` as their value type. A `LengthValue` is a
dictionary of all CSS units like `em`, `rem`, `px`, `percent`, etc. Setting
`height: calc(5px + 5%)` would yield a `LengthValue{px: 5, percent: 5}`. Some
properties like `box-sizing` just accept certain keywords and therefore have a
`KeywordValue` value type. The validity of those attributes could then be checked
at runtime.


    <div style="width: 200px;" id="div1"></div>
    <div style="width: 300px;" id="div2"></div>
    <div id="div3"></div>
    <div style="margin-left: calc(5em + 50%);" id="div4"></div>
    var w1 = $('#div1').styleMap.get('width');
    var w2 = $('#div2').styleMap.get('width');
    $('#div3').styleMap.set('background-size',
      [new SimpleLength(200, 'px'), w1.add(w2)])
    $('#div4')).styleMap.get('margin-left')
      // => {em: 5, percent: 50}


### Properties and values
([spec][Properties and Values spec])

Note: Spec is pretty stable. No accesible implementation as of yet.

Do you know [CSS Custom Properties] (or their unofficial alias “CSS Variables”)?
This is them but with types! So far, variables could only have string values and
used a simple search-and-replace approach. This draft would allow you to not
only specify a type for your variables, but also define a default value and
influence the inheritance behavior using a JavaScript API. Technically, this
would also allow custom properties to get animated with standard CSS transitions
and animations, which is also being considered.


    ["--scale-x", "--scale-y"].forEach(function(name) {
    document.registerProperty({
        name: name,
        syntax: "<number>",
        inherits: false,
        initialValue: "1"
      });
    });


### Font metrics

Font metrics is exactly what it sounds like. What is the bounding box (or the
bounding boxes when we are wrapping) when I render string X with font Y at size
Z? What if I go all crazy unicode on you like using [ruby annotations]? This has
been requested a lot and Houdini should finally make these wishes
come true.

### But wait, there’s more!

There’s even more specs in Houdini’s list of drafts, but the future of those is
rather uncertain and they are not much more than placeholders for ideas.
Examples include custom overflow behaviors, CSS syntax extension API, extension
of native scroll behavior and similarly ambitious things all of which enable
things on the web platform that weren't possible before.

## Demos

I have open-sourced the [code for the demo][Houdini Samples]
([live demo][Houdini Demo] using polyfill) videos I made so you can get a feeling
on what working with worklets feels like. I will update the repository with new
demos as new APIs are landing in Canary.

If you want to get involved, there’s always the [Houdini mailing list].

[Houdini Drafts]: http://dev.w3.org/houdini/
[Worklets spec]: https://drafts.css-houdini.org/worklets/
[Web Worker spec]: https://www.w3.org/TR/workers/
[Paint Worklet spec]: https://drafts.css-houdini.org/css-paint-api/
[Fragmentation spec]: https://www.w3.org/TR/css3-break/
[HTML5Rocks layers]: http://www.html5rocks.com/en/tutorials/speed/layers/
[Paul Lewis]: https://twitter.com/aerotwist
[Layout Worklet spec]: https://drafts.css-houdini.org/css-layout-api/
[Masonry]: http://masonry.desandro.com/
[Typed CSSOM spec]: https://drafts.css-houdini.org/css-typed-om/
[Aerotwist FLIP]: https://aerotwist.com/blog/flip-your-animations/#got-code
[Typed CSSOM polyfill]: https://github.com/css-typed-om/typed-om
[ruby annotations]: https://en.wikipedia.org/wiki/Ruby_character
[Properties and Values spec]: https://drafts.css-houdini.org/css-properties-values-api/
[Houdini Samples]: https://github.com/GoogleChrome/houdini-samples
[Houdini mailing list]: https://lists.w3.org/Archives/Public/public-houdini/
[CompWorklet Polyfill]: https://github.com/googlechrome/houdini-samples
[Web Components]: http://webcomponents.org/
[parallax scrolling]: https://en.wikipedia.org/wiki/Parallax_scrolling
[CSS Custom Properties]: https://developers.google.com/web/updates/2016/02/css-variables-why-should-you-care
[Houdini Demo]: https://googlechrome.github.io/houdini-samples/animation-worklet/twitter-header/
[Paint Worklet demo]: http://googlechrome.github.io/houdini-samples/paint-worklet/ripple/
[Paint Worklet source]: https://github.com/GoogleChrome/houdini-samples/tree/master/paint-worklet/ripple


Translated By:
{% include "web/_shared/contributors/jihyerish.html" %}

{% include "comment-widget.html" %}
