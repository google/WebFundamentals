---
title: "자바스크립트로 상호작용 더하기"
description: "자바스크립트는 컨텐츠, 스타일, 그리고 유저와의 상호작용과 같은 페이지의 모든 부분을 변경할 수 있게 해줍니다. 또한 자바스크립트는 DOM 생성을 블록 할 수 있고 페이지가 렌더링 될 때 지연 시킬 수도 있습니다. 최적화된 성능을 제공하기 위해 당신의 자바스크립트를 비동기로 만들고 크리티컬 렌더링 패스에서 불필요한 자바스크립트는 삭제하세요."
updated_on: 2014-09-18
translation_priority: 0
translators:
  - swengineer
key-takeaways:
  adding-interactivity:
    - 자바스크립트는 DOM과 CSSOM을 쿼리 또는 수정할 수 있습니다.
    - 자바스크립트 실행은 CSSOM에 블록됩니다.
    - 자바스크립트는 명시적으로 비동기 선언이 되지 않으면 DOM 생성을 막습니다.
---

<p class="intro">
  자바스크립트는 컨텐츠, 스타일, 그리고 유저와의 상호작용과 같은 페이지의 모든 부분을 변경할 수 있게 해줍니다. 또한 자바스크립트는 DOM 생성을 블록 할 수 있고 페이지가 렌더링 될 때 지연 시킬 수도 있습니다. 최적화된 성능을 제공하기 위해 당신의 자바스크립트를 비동기로 만들고 크리티컬 렌더링 패스에서 불필요한 자바스크립트는 삭제하세요.
</p>

{% include shared/takeaway.liquid list=page.key-takeaways.adding-interactivity %}

자바스크립트는 브라우저에서 실행되고 페이지 동작에 관한 모든 면에 대해 수정이 가능한 동적인 언어입니다. 우리는 DOM 트리로부터 요소를 추가하거나 삭제함으로서 페이지 컨텐츠를 수정할 수 있고 각 요소의 CSSOM 속성들을 수정할 수 있습니다. 그리고 유저의 입력을 다루거나 더 많은 것들도 할 수 있습니다. 이러한 동작을 보여주기 위해, 예전의 " Hello world" 인라인 스크립트 예제를 더 확장시켜 봅시다.

{% include_code src=_code/script.html snippet=full %}

* 자바스크립트는 우리가 DOM에 접근할 수 있게 해주고 숨겨진 span 노드도 참조할 수 있도록 해줍니다. 그 숨겨진 노드는 아마 렌더트리에서 보이지 않을것 입니다. 그러나 DOM에는 여전히 존재합니다. 그렇게 한번 참조를 가지게 되면, 우리는 텍스트도 수정하고(.textContent를 통해) 심지어 계산된 디스플레이 스타일 속성도 'none'에서 'inline'으로 덮어쓰기 할 수 있습니다. 한번에 모든것이 말한대로 되었다면, 우리의 페이지는 "**Hello interactive students!**" 를 보여줄 것 입니다.

* 자바스크립트는 우리가 DOM에 새로운 요소를 생성, 스타일링, 그리고 추가 및 삭제를 할 수 있게 해줍니다. 사실, 기술적으로 우리의 전체 페이지는 요소를 하나씩 생성하고 스타일링하는 하나의 커다란 자바스크립트 파일이 될 수 있었습니다. 그것은 동작할것이지만, HTML, CSS를 이용하는것이 보통 더 쉽습니다. 우리의 자바스크립트 함수 두번째 파트에서 새로운 div 요소를 만들고, 그것의 텍스트 컨텐츠를 설정하고, 스타일링해서 body 태그에 붙입니다.

<img src="images/device-js-small.png" class="center" alt="page preview">

그것과 함께, 우리는 DOM에 이미 존재하는 노드의 컨텐츠와 CSS 스타일을 변경했습니다. 그리고 문서에 전체적으로 새로운 노드를 추가했습니다. 우리의 페이지는 어떠한 디자인상도 수상하진 않았지만, 자바스크립트가 우리에게 해줄 수 있는 힘과 유연성을 보여주었습니다.

그러나, 그 기저에는 숨겨진 커다란 성능 경고가 있습니다. 자바스크립트는 우리에게 많은 힘을 주지만, 페이지가 렌더링되는 때와 방법에 많은 추가적인 제약을 만듭니다.

먼저, 우리의 예제에서 인라인 스크립트는 페이지의 바닥에 가까웠음을 인지하세요. 왜냐하면, 음, 여러분은 스스로 해봐야 합니다. 만약 우리가 스크립트를 _span_ 요소 위로 움직이면, 여러분은 스크립트가 실패하고 문서에서 _span_ 요소를 찾을 수 없다는 불평을 보게 될 것입니다. 예를들어 _getElementsByTagName(‘span')_ 은 _null_ 을 리턴할 것입니다. 이것은 중요한 속성을 보여줍니다: 우리의 스크립트는 정확하게 문서에 삽입한 위치에서 실행된다는 것입니다. HTML 파서가 스크립트 태그를 만나면 파서는 DOM 생성을 중지하고 자바스크립트 엔진에게 그 컨트롤을 넘기게 됩니다. 자바스크립트 엔진이 실행을 완료하면, 브라우저는 떠났던 위치로 돌아와 다시 DOM 생성을 실행합니다.

다시 말해서, 우리의 스크립트는 블록은 아직 프로세스가 진행되지 않았기 때문에 페이지에서 어떤 요소도 찾지 못한것입니다. 비슷하게 다시 말하면: **인라인 스크립트의 실행이 DOM 생성을 막고, 첫 렌더링에 지연을 줄 것입니다.**

우리의 페이지를 통해 스크립트에 대해 소개할 또 다른 미묘한 점은 스크립트가 DOM뿐만 아니라 CSSOM 속성까지 읽고 수정할 수 있다는 것입니다. 사실, 이것은 span요소의 디스플레이 속성을 'none'에서 'inline'으로 변경함으로서 정확히 우리의 예제를 통해 한 것입니다. 그 결과는? 우리는 이제 경합 조건이 생겼습니다.

만약 브라우저가 CSSOM을 다운로드하고 빌드하는 것이 끝나지 않았을 때 우리의 자바스크립트가 실행되길 원하면 어떻게 될까요? 답은 간단하지만 성능에는 좋지 않습니다: **그 브라우저는 CSSOM을 다운로드하고 생성할 때 까지 스크립트 실행을 지연시킵니다. 그리고 우리가 기다리는 동안, DOM 생성 또한 블록됩니다.**

간단히 말해서, 자바스크립트는 DOM, CSSOM, 자바스크립트 실행과 같은 새로운 의존성을 소개합니다. 그리고 이것은 브라우저가 얼마나 빠르게 페이지를 프로세스하고 스크린에 렌더링하는 지에 대해 상당한 지연을 만들 수 있습니다.

 1. 문서에서 스크립트의 위치는 중요합니다.
 2. 한 스크립트 태그를 만났을 때 스크립트의 실행이 끝날때 까지 DOM 생성은 중지됩니다.
 3. 자바스크립트는 DOM과 CSSOM을 쿼리하고 수정할 수 있습니다.
 4. 자바스크립트 실행은 CSSOM이 준비될 때 까지 연기 됩니다.

 우리가 "크리티컬 렌더링패스의 최적화"를 이야기할 때, 상당 부분으로 HTML, CSS, 그리고 자바스크립트 의존성 그래프를 이해하고 최적화하는 것이 중요하다는 것을 말하고 있습니다.


## 파서의 블록 vs. 비동기적인 자바스크립트

기본적으로, 자바스크립트 실행은 "파서 블록"입니다: 브라우저가 문서안에서 스크립트 태그를 만났을 때, 그것은 반드시 DOM 생성을 중지시킵니다. 자바스크립트 런타임에게 컨트롤을 넘기고 자바스크립트가 실행되도록 둡니다. 이후에 DOM 생성을 진행합니다. 우리는 이전 예제를 통해 인라인스크립트가 이러한 동작을 하는것을 이미 봤습니다. 사실 인라인 스크립트는 당신이 특별한 주의를 가하고 실행을 지연시키기 위한 추가적인 코드를 덧붙이지 않으면 항상 파서를 블록시킵니다.

스크립트 태그를 통해 포함된 스크립트는 어떨까요? 우리의 이전 예제를 별도의 파일이 되도록 코드를 분리해보겠습니다.

{% include_code src=_code/split_script.html snippet=full %}

**app.js**

{% include_code src=_code/app.js snippet=full lang=javascript %}

우리가 인라인 자바스크립트 조각을 사용하는 대신 `<script>`를 사용하면 실행 순서가 달라질 것이라 기대하시나요? 물론 대답은 "아니요"입니다. 그것들은 동일하며 같은 방식으로 동작 해야 합니다. 두가지 경우 모두 브라우저는 문서의 나머지 부분을 프로세스 하기 전에 정지하고 자바스크립트를 실행합니다. 그러나, **브라우저의 외부 자바스크립트파일인 경우에도 마찬가지로 정지하고 스크립트가 원격 서버 또는 캐쉬, 디스크로 부터 받아오기 까지 기다립니다. 그것들은 크리티컬 렌더링 패스에 몇 초의 시간을 더할 수도 있습니다.**

그 말은, 좋은 소식으로, 우리는 방법이 있다는 것입니다. 기본적으로 모든 자바스크립트는 파서를 블록하고 브라우저는 그 스크립트가 무엇을 할 지 모릅니다. 그러므로 브라우저는 최악의 시나리오를 가정하고 파서를 블록시키는 것입니다. 그러나 브라우저에게 그 스크립트는 문서에 위치한 정확한 때에 실행될 필요가 없다고 알려주면 어떻게 될까요? 그것은 브라우저에게 DOM을 생성을 계속하게 하고 자바스크립트는 준비가 됐을 때 실행하도록 허용해줍니다. 예를들어 자바스크립트 파일이 캐쉬나 원격 서버로부터 받아졌을 때 말입니다.

그래서 어떻게 이러한 트릭을 적용할까요? 매우 간단합니다 우리의 스크립트를 _async_ 표시해주면 됩니다.

{% include_code src=_code/split_script_async.html snippet=full %}

비동기 키워드를 스크립트에 추가하는 것은 스크립트를 다운로드 받고 이용가능할 때 까지 기다리는 동안 DOM 생성을 막지 말라고 브라우저에게 말해주는것 입니다. 이것이 성능의 커다란 개선을 가져다 줍니다.
