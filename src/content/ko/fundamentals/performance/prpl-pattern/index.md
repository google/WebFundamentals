project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml

{# wf_updated_on: 2016-09-28 #}
{# wf_published_on: 2016-09-28 #}

# The PRPL Pattern {: .page-title }

{% include "web/_shared/contributors/addyosmani.html" %}

Dogfood : PRPL 은 우리가 느끼기에 굉장한 잠재력을 지닌 새로운 패턴입니다.
이번 단계에서는 이 패턴에 대한 아이디어를 토대로 반복적인 실험을 해보고
매력적인 장점을 발견할 수 있도록 더 많은 정보를 얻으려고 합니다.

모바일 웹은 너무 느립니다. 지난 시간 동안 웹은 다큐멘트 중심의 플랫폼에서 일급 함수 어플리케이션 플랫폼으로 발전해왔습니다.
플랫폼과 도구 측면에서 [서비스 워커](/web/fundamentals/getting-started/primers/service-workers) 와 같은 기술적인 진보와, 앱을 구현할 때 사용하는 기술들 덕분에 사용자들은 네이티브 앱에서 할 수 있던 것들을 웹에서도 할 수 있게 되었습니다.

이와 동시에 대다수의 컴퓨팅 환경이 빠르고 안정적인 네트워크 연결을 제공하는 강력한 데스크톱에서,
상대적으로 느리거나, 품질이 낮은 연결을 제공하는 모바일 장치들로 옮겨왔습니다.
몇십억 명의 사용자들이 온라인을 경험하게 되는 세계에서는 이러한 주장이 사실로 여겨지고 있습니다.

불행하게도 우리가 데스크톱에서 강력하고 기능이 많은 웹 앱을 만들고 배포하기 위해 고안했었던 패턴들이
이제 일반적으로는 모바일 기기에서 너무 시간이 오래 걸리게 되었습니다. 이로 인해 많은 사용자들이 사이트가 느리면 그냥 포기하게 되죠.

이러한 상황은 모바일 웹 경험을 더 빠르게 제공할 수 있고, 최신 웹 플랫폼 특징들을 녹여낼 수 있는 새로운 패턴들을 제작하는 계기가 됩니다.
그리고 PRPL 은 그 중 하나가 되겠죠.

## PRPL 패턴

PRPL 는 프로그레시브 웹 앱 (PWA) 를 구조화 하고 동작시킬 수 있는 패턴입니다. 앱 시작과 배포에서 성능의 강점을 가지죠.
PRPL 의 각 철자는 아래의 의미를 갖습니다.

*  **푸시(Push)** : 초기 URL 접근에 대한 크리티컬 리소스 푸시
*  **렌더(Render)** : 초기 접근의 렌더링
*  **프리캐쉬(Pre-cache)** : 나머지 라우팅에 대한 프리 캐쉬
*  **게으른로드(Lazy-load)** : 나머지 라우팅을 필요에 따라 뒤늦게 생성하고 게으른 로딩

PWA 의 표준과 핵심 목표를 달성하는 것 이상으로, PRPL 는 아래와 같은 항목을 최적화 하고자 합니다.

* 상호작용을 위한 최소시간
  * 특히 첫번째 상호작용 시점 (어떤 기기로 접속하는가와 관계 없이)
  * 특히 실생활의 모바일 기기에서
* 캐싱 효율 최대화, 특히 시간에 지남에 따라 업데이트가 되면서
* 개발과 배포의 단순화

PRPL 은 최신 웹 플랫폼 기술들의 조합에서 영감을 받았습니다.
하지만, PRPL 의 모든 기술들을 사용하지 않고도 패턴이 적용 가능합니다.

실은 PRPL 이 어쩌면 특정 기술과 테크닉에 관한 내용이라기 보다
개발자의 마음가짐이나 모바일 웹의 성능을 향상하기 위한 장기적인 목표에 더 가까울지도 모릅니다.
PRPL 의 근간이 새로운 것은 아니지만 접근 방식 자체가 Polymer 팀에 의해 정의되고 명명되었으며,
[Google I/O 2016](https://www.youtube.com/watch?v=J4i0xJnQUzU) 에서 소개됨.

폴리머의 [Shop](https://shop.polymer-project.org) 전자상거래 데모는 PRPL 를 이용하여
리소스를 최소한으로 제공하는 모범 사례입니다.
실생활에서 사용하는 모바일 기기의 모든 라우팅에 대해 믿을 수 없을 정도로 빠른 상호작용을 제공하였죠.

![1.75 초 안에 상호작용 할 수 있는 폴리머 샵 데모](images/app-build-prpl-shop.png)

대부분의 실제 프로젝트의 경우, 솔직하게 말해 아직은 PRPL 에서 추구하는 마음가짐을 깨닫기에는 조금 이른감이 있습니다.
하지만 한가지 확실한건 마음가짐을 갖는 것이라던가 다양한 각도에서 PRPL 사상을 쫓기 시작하는 것이 이른게 아니라는 점이죠.
앱 개발자, 도구 개발자, 브라우저 벤더사들이 PRPL 의 목적 달성을 하기 위해 해볼 수 있는 쓸만한 절차들이 있습니다.

## 앱 구조

당신의 싱글 페이지 앱이 다음과 같은 구조를 갖고 있으면 PRPL 이 잘 동작할 수 있습니다.

-   모두 유효한 라우트들에서 접근할 수 있는 _주요 진입점_.
    이 파일은 다른 URL 들에서 접근되기 때문에 매우 작아야 하고 여러번 캐시가 되어야 합니다.
    모든 리소스 URL 들은 최상위 레벨이 아닌 URL 에서 제공될 수 있기 때문에 진입점에서 절대 경로를 가져야합니다.

-   _쉘_ 또는 앱 쉘.
    최상위 레벨의 앱 로직, 라우터 등을 포함하는 쉘 또는 앱 쉘.

-   게으르게 로딩된 앱의 _프레그먼트_.
    프레그먼트는 특정 뷰에 대한 코드를 나타낼 수 있고, 또는 게으르게 로딩될 수 있는 코드들을 의미합니다.
    (예를 들어, 사용자가 앱을 조작하기 전까지 표시되지 않는 메뉴처럼 첫 화면 그리기에 필요하지 않은 메인 앱의 부분들)
    쉘은 필요에 따라 프레그멘트를 동적으로 불러와야 합니다.

서버와 서비스워커는 비활성화된 라우트에 해당되는 리소스를 프리캐쉬하기 위해 같이 작동합니다.

사용자가 라우터를 전환할 때, 앱이 아직까지 캐쉬되지 않은 필요 리소스들을 게으르게 로딩합니다.
그리고 필요한 뷰를 생성합니다. 계속된 라우팅 반복은 즉시 상호작용이 가능한 상태로 됩니다.
여기에 서비스워커가 많은 역할을 합니다.

아래 다이어그램에서는 [웹 컴포넌트](http://webcomponents.org/) 를 이용하여 구조화 할 수 있는
간단한 앱의 컴포넌트들을 확인할 수 있습니다.

![2 개의 뷰를 갖는 앱의 다이어그램, 각 뷰는 독립적인 디펜던시와 상호공유된 디펜던시를 갖는다.](images/app-build-components.png)

Note: HTML Imports 가 폴리머에서 선호하는 제작 전략일지라도
당신이 코드를 분리해서 사용하거나, 최신 자바스크립트 모듈 번들러를 이용한 방식과 유사하게 구성할 수 있는
라우트 기반 분리를 사용할 수 있습니다.

이 다이어그램에서 굵은 선이 의미하는 것은 _정적인 디펜던시_ 입니다 :
파일에서 `<link>` 와 `<script>` 태그를 사용하여 불러오는 외부 리소스들을 의미합니다.
점선이 의미하는 것은 _동적인_ 또는 _요구 기반 디펜던시_ 입니다 :
쉘에 의해 필요에 따라 로딩되는 파일을 의미하죠.

빌드 과정을 통해 이 모든 디펜던시의 그래프를 만듭니다. 그리고 서버는 이 정보를 이용하여 파일을 효율적으로 제공할 수 있습니다.
또한, HTTP/2 를 지원하지 않는 브라우저를 위해 vulcanized(화학처리)한 번들 집합을 만듭니다.

### 앱 진입점

진입점에서는 무조건 쉘을 초기화 시키고 임포트 해야합니다. 또한, 선택적으로 필요한 폴리필을 다 로딩해야합니다.

진입점에 대한 고려사항은 다음과 같습니다.

  - 정적인 디펜던시은 최소한으로만 갖고 있어야 합니다. 달리 말해, 앱 쉘 자체를 넘어서는 로딩은 지양합니다.
  - 필요한 폴리필을 조건적으로 로딩합니다.
  - 모든 디펜던시에 대해 절대 경로를 사용합니다.

### 앱 쉘

앱 쉘은 앱의 라우팅과 보통 앱의 메인 네비게이션 UI 를 포함합니다.

프레그먼트는 필요할 때 엡에서 늦게 로딩해야 합니다. 예를 들어, 사용자가 새 라우팅을 할 때 새 라우팅과 관련된 프레그멘트들이 임포트됩니다.
이 과정에서 서버로 새로운 요청이 생성될 수도 있고, 단순히 캐쉬에서 리소스를 로딩할 수도 있습니다.

쉘은 (정적인 디펜던시를 포함한) 첫 그리기를 위해 필요한 모든 구성요소들을 포함하고 있어야 합니다.

## 빌드 결과

PRPL 이용하는 것이 어려운 요구사항은 아니지만, 당신의 빌드 과정의 결과가 2 개가 될 수 있습니다.

-   번들화 되지 않은 빌드 : 캐쉬를 최적화 하고, 브라우저가 첫 페인팅을 빠르게 하기 위해 필요한 자원들을 전달할 수 있는 HTTP/2 를 지원하고 있는 서버 / 브라우저 조합으로 설계된. [`<link rel="preload">`][리소스 힌트] 또는 [HTTP/2 푸시] 를 이용하여 효율적으로 리소스를 전달할 수 있습니다.

-   번들화된 빌드 : 서버 푸시를 지원하지 않는 서버 / 브라우저 조합 위에서 어플리케이션을 동작하기 위해 필요한 왕복 요청을 최소화 할 수 있게 설계된.

서버 로직은 각 브라우저에 맞춰 적절하게 빌드해야 합니다.

### 번들화된 빌드

HTTP/2 를 다루지 않는 브라우저들의 경우에는 빌드 절차가 다른 번들 집합을 만들 수 있어야 합니다:
쉘을 위한 1 개의 번들, 각 프레그먼트를 위한 1 개의 번들. 아래의 다이어그램은 어떻게 간단한 앱이 웹 컴포넌트를 이용하여 번들화할 수 있는지 보여줍니다.

![위 앱 구조에서 나온 앱에 3 개의 번들 디펜던시를 적용한 다이어그램](images/app-build-bundles.png)

2 개 또는 그 이상의 프레그먼트에 공유되는 디펜던시는 쉘, 정적인 디펜던시와 함께 번들화됩니다.

각 프레그먼트 와 _공유되지 않은_ 정적인 디펜던시는 한 개의 번들로 번들화 됩니다.
브라우저에 맞춰 서버에서는 프레그먼트의 적절한 버전을 반환해야 합니다. 이 말은 쉘 코드가
`detail-view.html` 가 번들화 되어야 하는지 아닌지 알 필요 없이 뒤늦게 로딩할 수 있다는 걸 의미합니다.
가장 효율적인 방법으로 디펜던시를 로딩할 수 있는 서버와 브라우저에 의존한다는 것이죠.


## 백그라운드: HTTP/2 와 HTTP/2 서버 푸시

[HTTP/2] 는 단일 연결에서 _복합_ 다운로드 를 허용합니다.
그렇게 해서 여러 개의 작은 파일이 더 효율적으로 다운로드가 될 수 있습니다.

[HTTP/2 서버 푸시][HTTP/2 푸시] 는 서버가 브라우저에 리소스를 우선적을 보낼 수 있게 합니다.

HTTP/2 서버 푸시가 어떻게 다운로드 속도를 올릴 수 있는 지 보여주는 경우,
어떻게 브라우저가 HTML 파일(링크된 스타일시트 포함)을 가져오는 지 고려해야 합니다.

HTTP/1 에서는:

*   브라우저가 HTML 파일을 요청합니다.
*   서버가 HTML 파일을 브라우저에 반환해주고, 브라우저는 파싱을 시작합니다.
*   브라우저가 `<link rel="stylesheet">` 태그를 마주치면, 스타일시트에 대한 새로운 요청을 보냅니다.
*   브라우저는 스타일시트를 수신합니다.

HTTP/2 푸시로는:

*   브라우저는 HTML 파일을 요청합니다.
*   서버에서 HTML 파일을 반환해주고, 동시에 스타일시트를 밀어 넣어줍니다.
*   브라우저가 HTML 파싱을 시작합니다. 파싱 중 `<link rel="stylesheet">` 만날 때 쯤이면, 스타일시트는 이미 캐쉬 안에 있습니다.

이 단순한 경우에서도 볼 수 있듯이, HTTP/2 서버 푸시 방식으로 HTTP 요청 - 응답 수를 줄일 수 있습니다.

HTTP/1 으로 개발자들은 페이지 렌더링에 필요한 HTTP 리소스 요청 수를 줄이는 리소스 번들링이 가능합니다.
하지만, 번들링이 브라우저 캐쉬의 효율성을 감소시킬 수는 있습니다. 만약 각 페이지의 리소스들이 1 개의 번들로 합쳐지지 않으면,
각 페이지는 각자의 번들을 갖게 되고 브라우저가 공유되는 리소스를 확인할 수 없습니다.

HTTP/2 와 HTTP/2 서버 푸시의 조합은 실제 바인딩 없이 latency 를 줄이는 번들링 혜택을 줍니다.
리소스를 분리하는 것으로 페이지 간의 리소스 공유가 가능하고 효율적으로 캐쉬할 수 있습니다.

HTTP/2 Push 는 파일이 브라우저 로컬 캐쉬에 있거나 대역폭이 이미 포화되어 있더라도
브라우저에 데이터를 보내기 때문에 조심해서 사용해야 합니다. 만약 잘못 되는 경우에는 성능이 악화될 수 있습니다.
[`<link rel="preload">`][리소스 힌트] 는 브라우저가 이러한 요청의 우선순위를 현명하게
정하는데에 도움이 될 수 있는 좋은 대안이 될 것입니다.

## 결론

라우팅을 위한 코드 로딩과 브라우저가 작업을 더 효율적으로 스케줄링 하는 것은 어플리케이션에서 더 훌륭한
반응성을 제공할 수 있는 잠재력을 지닙니다. 우리는 **빠르게 상호작용 할 수 있는 더 나은 아키텍쳐** 가 필요하고,
PRPL 패턴은 이러한 목표를 어떻게 실제 모바일 기기에서 달성할 수 있는지를 보여주는 흥미로운 예제입니다.

이 모든 것이 다 headroom 에 관한 것이므로 일단 당신이 모든 abstractions 를 로딩하면 충분합니다.
만약 링크 동작이 입력 이벤트를 방해하는 스크립트에 몇 초 정도 지연된다면, 이는 성능 쪽에 보완이 필요하다는 강한 암시입니다.
이는 오늘날 큰 자바스크립트 라이브러리들로 제작된 어플리케이션 (UI 가 렌더되고 나서 동작을 해야 되지만 동작을 안하는) 이 갖는 흔한 문제입니다.

PRPL 는 이러한 문제들을 해결하면서, 사용자가 마주치는 라우트들을 더 인터랙티브하게 위해 최소의 크기를 갖으면서 기능하는 코드를 전달할 수 있습니다.

[HTTP/2]: /web/fundamentals/performance/http2/
[리소스 힌트]: https://developers.google.com/web/updates/2016/03/link-rel-preload
[HTTP/2 푸시]: /web/fundamentals/performance/http2/#server-push

Translated By:
{% include "web/_shared/contributors/captainpangyo.html" %}
