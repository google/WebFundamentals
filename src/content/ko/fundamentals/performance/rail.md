project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml
description: RAIL 은 사용자 중심의 성능 모델입니다.
모든 웹 앱은 앱 생명주기와 연관성이 있고 각기 뚜렷하게 구분되는 4 가지 상태가 있습니다.
그리고 성능은 이 각 부분에 다양한 방법으로 연관됩니다: 반응, 애니메이션, 유휴, 로딩

{# wf_updated_on: 2015-06-07 #}
{# wf_published_on: 2015-06-07 #}

# RAIL 모델로 성능 측정하기 {: .page-title }

{% include "web/_shared/contributors/megginkearney.html" %}

RAIL 은 사용자 중심의 성능 모델입니다.
모든 웹 앱은 앱 생명주기와 연관성이 있고 각기 뚜렷하게 구분되는 4 가지 상태가 있습니다.
그리고 성능은 이 각 부분에 다양한 방법으로 연관됩니다.

![RAIL performance model](images/rail.png)


### TL;DR {: .hide-from-toc }

- 사용자에게 집중하세요. 최종 목적은 단순히 사이트가 어느 기기에서나 빠르게 동작하는 것이 아니라
  궁극적으로 사용자를 즐겁게 하는 것 입니다.
- 사용자에게 즉각적으로 반응하세요. 사용자의 입력을 100ms 이내에 반응해야 합니다.
- 애니메이션이나 스크롤링을 할 때 프레임은 10ms 이내로 실행되어야 합니다.
- 메인 쓰레드의 유휴 시간을 최대로 늘리세요.
- 사용자가 사이트에 계속 머물게 하세요. 상호작용과 관련된 컨텐츠는 1000ms 이내에 전달해야 합니다.


## 사용자에게 집중하세요.

성능 향상은 사용자를 중점으로 둬야 합니다.
사용자가 당신의 사이트에서 보내는 대부분의 시간은 컨텐츠가 로딩되기를 기다리는 시간이 아니라,
사용하는 와중에 반응이 일어나기를 기다리는 시간입니다.
아래 표를 통해 어떻게 사용자가 성능 지연을 인지하는지 확인하세요:

<table class="responsive">
  <thead>
      <th colspan="2">지연 &amp; 사용자 반응</th>
  </thead>
  <tbody>
    <tr>
      <td data-th="Delay">0 - 16ms</td>
      <td data-th="User Reaction">사람들은 유난히 동작을 따라가는데 능합니다. 그리고, 그 동작이 매끄럽지 못하면 싫어하죠.
      사용자는 애니메이션이 매 초 마다 60 프레임 이하로 전개되면 매끄럽다고 생각합니다.
      1 프레임당 16ms 인 셈이고, 이 시간은 브라우저가 새 프레임을 화면에 그리는 시간과,
      프레임을 그리기 위해 10ms 간 앱을 떠나는 시간도 포함합니다.</td>
    </tr>
    <tr>
      <td data-th="Delay">0 - 100ms</td>
      <td data-th="User Reaction">이 시간 안에 사용자의 반응에 응답하면 사용자는 결과가 즉각적이라고 느낄겁니다.
      만약 더 길어지면 사용자의 반응와 응답사이의 연결이 끊어졌다고 생각하게 되죠.
      </td>
    </tr>
    <tr>
      <td data-th="Delay">100 - 300ms</td>
      <td data-th="User Reaction">사용자는 약간의 지연을 느낍니다.</td>
    </tr>
    <tr>
      <td data-th="Delay">300 - 1000 ms</td>
      <td data-th="User Reaction">
      이 시간은 모든 동작들이 자연스럽게 느껴지고 일이 연속적인 측면에서 제대로 진행되고 있다고 생각하는 시간입니다.
      대부분의 웹 사용자들에게는 페이지를 로딩하거나 뷰를 변경하는 게 작업이 진행되는 것 처럼 보입니다.
      </td>
    </tr>
    <tr>
      <td data-th="Delay">1000+ms</td>
      <td data-th="User Reaction">1 초를 넘어가면 사용자들은 자신들이 수행하던 일에서 집중력을 잃습니다.</td>
    </tr>
    <tr>
      <td data-th="Delay">10,000+ms</td>
      <td data-th="User Reaction">좌절을 느끼고 하던 일을 포기하는 경향이 강합니다. 그리고 아마도 해당 사이트에 재방문 하지 않을겁니다.</td>
    </tr>
  </tbody>
</table>

## 응답은 100ms 이내에

사용자가 렉이라고 판단하기 전까지 보통 사용자의 입력에 응답하는데 100ms 정도 시간이 있습니다.
위 시간은 버튼 클릭, 폼 형식에서 토글링, 애니메이션 시작과 같은 대부분의 입력에 해당됩니다.
하지만 마우스 드래그나 스크롤에는 해당되지 않습니다.

만약 당신이 응답하지 않으면 사용자의 동작과 반응이 연결되지 않을 겁니다. 그러면 사용자는 알아차리겠죠.

사용자의 동작에 즉각적으로 응답하는 것이 당연하다고 여겨질 수 있지만 이게 항상 맞는 방식은 아닙니다.
100m 시간을 다른 고비용 작업 처리에 활용하세요, 하지만 사용자를 막지 않도록 주의하세요.
만약 가능하다면 백그라운드에서 작업을 처리하세요.

완료하는데 500ms 이상 걸리는 동작들에 대해서는 항상 피드백을 제공하세요.

## 애니메이션 : 1 프레임당 10ms

단순히 화려한 UI 효과만이 애니메이션이 아닙니다. 예를 들어, 스크롤을 하거나 드래그를 하는 것은 모두 애니메이션입니다.

사용자는 애니메이션 프레임 비율이 변할 때 알아차립니다.
당신의 목표는 초당 60 프레임을 생성하는 것이고, 모든 프레임은 아래의 과정을 거쳐야합니다.

![프레임을 렌더하기 위한 절차](images/render-frame.png)

단순히 수학적인 관점에서는, 모든 프레임이 16ms 정도의 여유 (1000ms / 60 초당 프레임 = 프레임 당 16.66ms)가 있습니다.
그러나 브라우저는 새로운 프레임을 화면에 그리는데 시간이 필요하기 때문에 **당신의 코드가 10ms 이내에 실행이 종료되어야 합니다.**

애니메이션과 같이 성능에서 높은 압박을 받는 부분에서는 가능한한 애니메이션을 하지 않고,
그렇지 못하다면 최소한의 애니메이션을 사용해야 합니다.
가능한 한 언제나 100ms 응답을 고비용 작업을 처리하는데 사용해야 60 fps를 할 수 있는 확률이 높아집니다.

더 많은 정보를 보시려면, [렌더링 성능](/web/fundamentals/performance/rendering/) 을 참고하세요.

## 유휴 : 유휴 시간 최대화

연기된 작업을 처리하는데 유휴 시간을 활용하세요.
예를 들어, 미리 로딩해야 할 데이터를 최소화 하여 앱을 빠르게 로딩합니다.
그리고 유휴 시간을 이용하여 나머지 데이터를 로딩합니다.


연기된 작업들은 약 50ms 의 블락으로 나눠 그룹 짓습니다.
사용자가 상호작용을 해야할 때, 최고 우선순위는 그 반응에 응답하는 것입니다.

100ms 내에 응답할 수 있도록,
앱은 픽셀 변환 과정 실행과 사용자 입력 반응등의 제어권을 최대 50ms 마다 메인 쓰레드에 양보해야합니다.


50ms 안에 수행하면 즉각적인 반응을 제공하면서 작업을 처리할 수 있습니다.

## 로딩 : 1000ms 안에 컨텐츠를 전달하기

당신의 사이트를 1초 안에 로딩하세요. 그렇게 못하면 사용자의 주의가 분산되고, 그들의 작업 집중력이 떨어질 것입니다.

[크리티컬 렌더링 패스 최적화](/web/fundamentals/performance/critical-rendering-path/) 에서
어떻게 렌더링 막기를 피하는지 확인하세요.

완벽한 로딩의 느낌을 내기 위해 모든 것을 1초 이내에 로딩할 필요는 없습니다.
점진적인 렌더링을 활용하고 백그라운드에서 작업을 처리하세요.
비필수적인 로딩을 유휴 시간으로 연기합니다. ([웹 사이트 성능 최적화 - 유다시티](https://www.udacity.com/course/website-performance-optimization--ud884) 확인)

## 주요 RAIL 메트릭 요약

RAIL 메트릭을 기준으로 사이트를 평가하려면 크롬 개발자 도구를 사용하여 사용자 동작을 녹화합니다.
[타임라인 도구](/web/tools/chrome-devtools/profile/evaluate-performance/timeline-tool).
그리고 나서 아래 주요 RAIL 메트릭에 대한 녹화 시간을 확인합니다.

<table>
  <thead>
      <th>RAIL 단계</th>
      <th>주요 지수</th>
      <th>사용자 동작</th>
  </thead>
  <tbody>
    <tr>
      <td data-th="RAIL Step"><strong>반응 (Reponse)</strong></td>
      <td data-th="Key Metric">입력 지연시간 (터치 후 그리기 까지) < 100ms.</td>
      <td data-th="User Test">사용자가 버튼 터치 (예를 들어, 네비게이션 동작).</td>
    </tr>
    <tr>
      <td data-th="RAIL Step"><strong>애니메이션 (Animation)</strong></td>
      <td data-th="Key Metric">각 프레임 동작 완료 (JS 부터 그리기 까지) < 16ms.</td>
      <td data-th="User Test">사용자가 페이지를 스크롤 하거나, 손가락으로 드래그 (예를 들어, 메뉴 열기)
        또는 애니메이션 보기. 드래깅을 할 때, 앱의 반응은 새로 고침을 하거나 카라우셀을 밀 때 처럼 손가락 위치에 달려있음.
        이 지수는 오직 연속적인 드래그 상태에서만 적용 되고, 시작은 해당되지 않음.
      </td>
    </tr>
    <tr>
      <td data-th="RAIL Step"><strong>유휴 (Idle)</strong></td>
      <td data-th="Key Metric">50ms 이하로 쌓여 있는 메인 JS 쓰레드 작업</td>
      <td data-th="User Test">사용자는 페이지와 상호작용하지 않고 있고,
      메인 쓰레드는 다음 사용자 입력을 처리하기에 충분해야 한다.</td>
    </tr>
    <tr>
      <td data-th="RAIL Step"><strong>로딩 (Load)</strong></td>
      <td data-th="Key Metric">1000m 안에 로딩되어 사용가능한 페이지</td>
      <td data-th="User Test">사용자가 페이지를 로딩할 떄 크리티컬 패스 컨텐츠를 확인</td>
    </tr>
  </tbody>
</table>

Translated By:
{% include "web/_shared/contributors/captainpangyo.html" %}
