project_path: /web/fundamentals/_project.yaml
book_path: /web/fundamentals/_book.yaml

{% include "web/_shared/machine-translation-start.html" %}

{# wf_auto_generated #}
{# wf_updated_on: 2019-04-19 #}
{# wf_published_on: 2016-01-01 #}

# आपका पहला प्रगतिशील वेब ऐप {: .page-title }

{% include "web/_shared/contributors/petelepage.html" %}

## परिचय

### वेब ऐप क्या बनाता है, प्रोग्रेसिव वेब ऐप?

प्रोग्रेसिव वेब ऐप्स डेस्कटॉप और मोबाइल पर एक इंस्टॉल करने योग्य, ऐप जैसा अनुभव प्रदान करते हैं जो सीधे वेब के माध्यम से बनाया और वितरित किया जाता है। वे वेब ऐप्स हैं जो तेज़ और विश्वसनीय हैं। और सबसे महत्वपूर्ण बात, वे वेब ऐप हैं जो किसी भी ब्राउज़र में काम करते हैं। यदि आप आज एक वेब ऐप बना रहे हैं, तो आप पहले से ही एक प्रगतिशील वेब ऐप बनाने की दिशा में अग्रसर हैं।

#### फास्ट एंड विश्वसनीय

हर वेब अनुभव तेज़ होना चाहिए, और यह विशेष रूप से प्रोग्रेसिव वेब ऐप्स के लिए सच है। फास्ट स्क्रीन पर सार्थक सामग्री प्राप्त करने में लगने वाले समय को संदर्भित करता है, और 5 सेकंड से भी कम समय में एक इंटरैक्टिव अनुभव प्रदान करता है।

और, यह __reliably fast__ होना चाहिए। यह पर्याप्त तनाव करना मुश्किल है कि कितना बेहतर विश्वसनीय प्रदर्शन है। इसे इस तरह से सोचें: एक मूल एप्लिकेशन का पहला भार निराशाजनक है। यह एक ऐप स्टोर और एक विशाल डाउनलोड द्वारा gated है, लेकिन एक बार जब आप एक ऐसे बिंदु पर पहुंच जाते हैं जहां ऐप इंस्टॉल होता है, तो सभी ऐप शुरू होने के दौरान अप-फ्रंट लागत को संशोधित किया जाता है, और उनमें से कोई भी शुरू होने में देरी नहीं होती है। प्रत्येक अनुप्रयोग प्रारंभ अंतिम, कोई विचरण नहीं है। एक प्रगतिशील वेब ऐप को यह विश्वसनीय प्रदर्शन प्रदान करना होगा जो उपयोगकर्ता किसी भी स्थापित अनुभव से उम्मीद करते हैं।

#### Installable

प्रगतिशील वेब ऐप्स ब्राउज़र टैब में चल सकते हैं, लेकिन इंस्टॉल करने योग्य भी हैं। किसी साइट को बुकमार्क करना केवल एक शॉर्टकट जोड़ता है, लेकिन एक स्थापित प्रोग्रेसिव वेब ऐप अन्य सभी इंस्टॉल किए गए ऐप्स की तरह दिखता है और व्यवहार करता है। यह उसी जगह से लॉन्च होता है, जितना अन्य एप लॉन्च करते हैं। आप लॉन्च के अनुभव को नियंत्रित कर सकते हैं, जिसमें एक अनुकूलित स्प्लैश स्क्रीन, आइकन और बहुत कुछ शामिल हैं। यह एक ऐप के रूप में, एक ऐप विंडो में एक एड्रेस बार या अन्य ब्राउज़र UI के बिना चलता है। और अन्य सभी इंस्टॉल किए गए ऐप्स की तरह, यह टास्क स्विचर में एक शीर्ष स्तर का ऐप है।

याद रखें, यह महत्वपूर्ण है कि एक इंस्टॉल करने योग्य PWA तेज़ और विश्वसनीय है। PWA स्थापित करने वाले उपयोगकर्ता अपेक्षा करते हैं कि उनके ऐप्स काम करें, चाहे वे किसी भी प्रकार के नेटवर्क कनेक्शन पर हों। यह एक आधारभूत अपेक्षा है जो हर स्थापित ऐप से पूरी होनी चाहिए।

#### मोबाइल और डेस्कटॉप

उत्तरदायी डिज़ाइन तकनीकों का उपयोग करते हुए, प्रगतिशील वेब ऐप दोनों मोबाइल __and__ डेस्कटॉप पर काम करते हैं, प्लेटफार्मों के बीच एक एकल कोड बेस का उपयोग करते हैं। यदि आप एक देशी ऐप लिखने पर विचार कर रहे हैं, तो उन लाभों पर एक नज़र डालें जो PWA प्रदान करता है।

### आप क्या बनाएँगे

इस कोडलैब में, आप प्रगतिशील वेब ऐप तकनीकों का उपयोग करके एक मौसम वेब ऐप बनाने जा रहे हैं। आपका ऐप होगा:

* उत्तरदायी डिज़ाइन का उपयोग करें, इसलिए यह डेस्कटॉप या मोबाइल पर काम करता है।
* तेज, सेवा कार्यकर्ता का उपयोग करने के लिए ऐप संसाधनों (एचटीएमएल, सीएसएस, जावास्क्रिप्ट, चित्र) को चलाने के लिए और प्रदर्शन में सुधार के लिए रनटाइम पर मौसम डेटा को कैश करने के लिए तेज़ रहें।
* स्थापित करने योग्य है, एक वेब ऐप मेनिफ़ेस्ट और `beforeinstallprompt` ईवेंट का उपयोग करके उपयोगकर्ता को यह सूचित करने के लिए कि यह इंस्टाल करने योग्य है

![95fe6f7fbeee5bb1.png](img/95fe6f7fbeee5bb1.png)

Warning: इस कोडलैब को सरल बनाने के लिए, और एक ऑफ़लाइन अनुभव प्रदान करने के मूल सिद्धांतों की व्याख्या करें, हम वेनिला जावास्क्रिप्ट का उपयोग कर रहे हैं। एक उत्पादन ऐप में, हम दृढ़ता से अपने सेवा कार्यकर्ता का निर्माण करने के लिए [Workbox](/web/tools/workbox/) जैसे उपकरणों का उपयोग करने की सलाह देते हैं। यह आपके द्वारा चलाए जा सकने वाले तेज किनारों और अंधेरे कोनों को हटा देता है।

### आप क्या सीखेंगे

* वेब ऐप मेनिफ़ेस्ट कैसे बनाएं और जोड़ें
* एक सरल ऑफ़लाइन अनुभव प्रदान करने के लिए कैसे
* कैसे एक पूर्ण ऑफ़लाइन अनुभव प्रदान करने के लिए
* अपने ऐप को इंस्टॉल करने योग्य कैसे बनाएं

यह कोडलैब प्रोग्रेसिव वेब एप्स पर केंद्रित है। गैर-प्रासंगिक अवधारणाएं और कोड ब्लॉक ओवर ग्लॉस किए जाते हैं और आपको बस कॉपी और पेस्ट करने के लिए प्रदान किए जाते हैं।

### तुम क्या आवश्यकता होगी

* क्रोम का एक हालिया संस्करण (74 या बाद का) PWA सिर्फ वेब ऐप हैं, और सभी ब्राउज़रों में काम करते हैं, लेकिन हम ब्राउज़र स्तर पर क्या हो रहा है, इसे बेहतर ढंग से समझने के लिए और इसका उपयोग करने के लिए Chrome DevTools की कुछ विशेषताओं का उपयोग करेंगे स्थापित अनुभव का परीक्षण करें।
* HTML, CSS, JavaScript और [Chrome DevTools](https://developer.chrome.com/devtools) ।

## सेट अप हो रहा है

### डार्क स्काई एपीआई के लिए एक कुंजी प्राप्त करें

हमारे मौसम का डेटा [Dark Sky API](https://darksky.net/dev) से आता है। इसका उपयोग करने के लिए, आपको एपीआई कुंजी का अनुरोध करना होगा। यह गैर-व्यावसायिक परियोजनाओं के लिए उपयोग करना आसान है, और मुफ्त है।

[Register for API Key](https://darksky.net/dev/register)

Note: आप अभी भी डार्क स्काई एपीआई कुंजी के बिना इस कोडलैब को पूरा कर सकते हैं। यदि हमारा सर्वर डार्क स्काई एपीआई से वास्तविक डेटा प्राप्त करने में असमर्थ है, तो यह बदले में नकली डेटा लौटाएगा।

#### सत्यापित करें कि आपकी API कुंजी ठीक से काम कर रही है

यह जांचने के लिए कि आपकी API कुंजी ठीक से काम कर रही है, DarkSky API के लिए HTTP अनुरोध करें। अपनी API कुंजी के साथ `DARKSKY_API_KEY` को बदलने के लिए नीचे दिए गए URL को अपडेट करें। यदि सब कुछ काम करता है, तो आपको न्यूयॉर्क शहर के लिए नवीनतम मौसम पूर्वानुमान देखना चाहिए।

`https://api.darksky.net/forecast/DARKSKY_API_KEY/40.7720232,-73.9732319`

### कोड प्राप्त करें

हमने इस प्रोजेक्ट के लिए Git repo में आपकी जरूरत की सभी चीजें डाल दी हैं। आरंभ करने के लिए, आपको कोड को पकड़ना होगा और इसे अपने पसंदीदा देव वातावरण में खोलना होगा। इस कोडलैब के लिए, हम ग्लिच का उपयोग करने की सलाह देते हैं।

#### सिफारिश की: रेपो आयात करने के लिए गड़बड़ का उपयोग करें

ग्लिच का उपयोग करना इस कोडलैब के माध्यम से काम करने के लिए अनुशंसित विधि है।

1. एक नया ब्राउज़र टैब खोलें और [https://glitch.com](https://glitch.com) पर [https://glitch.com](https://glitch.com) ।
2. यदि आपका कोई खाता नहीं है, तो आपको साइन अप करना होगा।
3. __New Project__ पर क्लिक करें, फिर __Clone से Git Repo .__
4. क्लोन __https://github.com/googlecodelabs/your-first-pwapp.git__ पर क्लिक करें और ठीक क्लिक करें।
5. एक बार जब रेपो लोड हो जाता है, तो `.env` फ़ाइल को संपादित करें, और इसे अपने DarkSky API कुंजी से अपडेट करें।
6. PWA को कार्रवाई में देखने के लिए __Show Live__ बटन पर क्लिक करें।

#### वैकल्पिक: डाउनलोड कोड और स्थानीय स्तर पर काम करते हैं

यदि आप कोड डाउनलोड करना चाहते हैं और स्थानीय स्तर पर काम करना चाहते हैं, तो आपको नोड का हाल का संस्करण, और कोड संपादक सेटअप और जाने के लिए तैयार होना होगा।

Caution: यदि आप स्थानीय रूप से काम करते हैं, तो लाइटहाउस के कुछ ऑडिट पास नहीं होंगे, और इंस्टॉलेशन उपलब्ध नहीं हो सकता है क्योंकि स्थानीय सर्वर सुरक्षित संदर्भ में सामग्री की सेवा नहीं करता है।

[Download source code](https://github.com/googlecodelabs/your-first-pwapp/archive/master.zip)

1. Unpack the downloaded zip file.
2. Run `npm install` to install the dependencies required to run the server.
3. Edit `server.js` and set your DarkSky API key.
4. Run `node server.js` to start the server on port 8000.
5. Open a browser tab to  [http://localhost:8000](http://localhost:8000)

## एक आधार रेखा स्थापित करें

### हमारा शुरुआती बिंदु क्या है?

हमारा शुरुआती बिंदु एक बुनियादी मौसम ऐप है जो इस कोडलैब के लिए बनाया गया है। इस कोडेलैब में अवधारणाओं को दिखाने के लिए कोड को अत्यधिक सरल बना दिया गया है, और इसमें बहुत कम त्रुटि है। यदि आप किसी उत्पादन एप्लिकेशन में इस कोड का पुन: उपयोग करना चुनते हैं, तो सुनिश्चित करें कि आप किसी भी त्रुटि को संभालते हैं और सभी कोड का पूरी तरह से परीक्षण करते हैं।

कोशिश करने के लिए कुछ बातें ...

1. नीचे दाएं कोने में नीले प्लस बटन के साथ एक नया शहर जोड़ें।
2. ऊपरी दाएं कोने में ताज़ा बटन के साथ डेटा ताज़ा करें।
3. प्रत्येक शहर कार्ड के ऊपरी दाईं ओर x का उपयोग करके एक शहर को हटाएं।
4. देखें कि यह डेस्कटॉप और मोबाइल पर कैसे काम करता है।
5. जब आप ऑफ़लाइन होते हैं तो देखें।
6. क्रोम के नेटवर्क पैनल का उपयोग करना, देखें कि जब नेटवर्क 3 जी को धीमा कर देता है तो क्या होता है।
7. `FORECAST_DELAY` में `server.js` बदलकर पूर्वानुमान सर्वर में देरी जोड़ें

### लाइटहाउस के साथ ऑडिट

[Lighthouse](/web/tools/lighthouse/#devtools) आपकी साइटों और पृष्ठों की गुणवत्ता में सुधार करने में मदद करने के लिए एक आसान उपकरण है। इसमें प्रदर्शन, पहुंच, प्रगतिशील वेब ऐप और बहुत कुछ के लिए ऑडिट हैं। प्रत्येक ऑडिट में एक संदर्भ डॉक होता है जिसमें बताया गया है कि ऑडिट महत्वपूर्ण क्यों है, साथ ही इसे कैसे ठीक किया जाए।

![b112675caafccef0.png](img/b112675caafccef0.png)

हम अपने वेदर ऐप को ऑडिट करने और हमारे द्वारा किए गए परिवर्तनों को सत्यापित करने के लिए लाइटहाउस का उपयोग करेंगे।

Note: आप कमांड लाइन से या नोड मॉड्यूल के रूप में क्रोम देवटूल में लाइटहाउस चला सकते हैं। पर विचार करें [adding Lighthouse](https://github.com/GoogleChromeLabs/lighthousebot) सुनिश्चित करें कि आपके वेब एप्लिकेशन निकासी नहीं है बनाने के लिए अपने निर्माण की प्रक्रिया के लिए।

### चलो लाइटहाउस चलाते हैं

1. अपने प्रोजेक्ट को एक नए टैब में खोलें।
2. क्रोम DevTools खोलें और __Audits__ टैब पर स्विच करें, DevTools ऑडिट श्रेणियों की एक सूची दिखाता है, उन्हें सभी सक्षम छोड़ दें।
3. क्लिक करें __Run audits__, 60-90 सेकंड के बाद, लाइटहाउस आपको पृष्ठ पर एक रिपोर्ट देता है।

### प्रोग्रेसिव वेब ऐप ऑडिट

हम प्रगतिशील वेब ऐप ऑडिट के परिणामों पर ध्यान केंद्रित करने जा रहे हैं।

![af1a64a13725428e.png](img/af1a64a13725428e.png)

और ध्यान केंद्रित करने के लिए लाल रंग का एक बहुत कुछ है:

* __❗असफल हुआ:__ वर्तमान पृष्ठ ऑफ़लाइन होने पर 200 के साथ उत्तर नहीं देता है।
* __❗असफल हुआ:__ `start_url` ऑफ़लाइन होने पर 200 के साथ जवाब नहीं देता है।
* __❗असफल हुआ:__ पेज और `start_url.` नियंत्रित करने वाले सेवा कार्यकर्ता को पंजीकृत नहीं करता है
* __❗असफल हुआ:__ वेब ऐप मेनिफेस्टेबिलिटी आवश्यकताओं को पूरा नहीं करता है।
* __❗असफल हुआ:__ एक कस्टम स्प्लैश स्क्रीन के लिए कॉन्फ़िगर नहीं किया गया है।
* __❗असफल हुआ:__ एक एड्रेस-बार थीम रंग निर्धारित नहीं करता है

चलो कूदते हैं और इनमें से कुछ मुद्दों को ठीक करना शुरू करते हैं!

## एक वेब ऐप मैनिफ़ेस्ट जोड़ें

इस अनुभाग के अंत तक, हमारा मौसम ऐप निम्नलिखित ऑडिट पास करेगा:

* वेब ऐप मेनिफेस्टेबिलिटी आवश्यकताओं को पूरा नहीं करता है
* एक कस्टम स्प्लैश स्क्रीन के लिए कॉन्फ़िगर नहीं किया गया है।
* एड्रेस-बार थीम कलर सेट नहीं करता है।

### वेब एप मेनिफेस्ट बनाएं

[web app manifest](/web/fundamentals/web-app-manifest) एक सरल JSON फ़ाइल है जो आपको, डेवलपर को नियंत्रित करने की क्षमता देती है कि आपका ऐप उपयोगकर्ता को कैसे दिखता है।

वेब एप्लिकेशन मेनिफ़ेस्ट का उपयोग करके, आपका वेब ऐप निम्न कर सकता है:

* उस ब्राउज़र को बताएं जिसे आप चाहते हैं कि आपका ऐप एक स्टैंडअलोन विंडो ( `display` ) में खुले।
* एप्लिकेशन को पहली बार लॉन्च किए जाने पर ( `start_url` ) किस पेज को खोला गया है, इसे परिभाषित करें।
* परिभाषित करें कि ऐप को डॉक या ऐप लॉन्चर पर कैसा दिखना चाहिए ( `short_name` , `icons` )।
* एक स्पलैश स्क्रीन बनाएं ( `name` , `icons` , `colors` )।
* ब्राउज़र को परिदृश्य, या पोर्ट्रेट मोड ( `orientation` ) में विंडो खोलने के लिए `orientation` ।
* और [plenty more](https://developer.mozilla.org/en-US/docs/Web/Manifest#Members) ।

अपनी परियोजना में `public/manifest.json` नामक एक फ़ाइल बनाएँ और निम्नलिखित सामग्रियों को कॉपी / पेस्ट करें:

`public/manifest.json`

```json
{
  "name": "Weather",
  "short_name": "Weather",
  "icons": [{
    "src": "/images/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    }, {
      "src": "/images/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    }, {
      "src": "/images/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    }, {
      "src": "/images/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    }, {
      "src": "/images/icons/icon-256x256.png",
      "sizes": "256x256",
      "type": "image/png"
    }, {
      "src": "/images/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }],
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#3E4EB8",
  "theme_color": "#2F3BA2"
}
```

मैनिफ़ेस्ट विभिन्न स्क्रीन साइज़ के लिए, आइकनों की एक सरणी का समर्थन करता है। इस कोड लैब के लिए, हमने कुछ अन्य को शामिल किया है क्योंकि हमें अपने iOS एकीकरण के लिए उनकी आवश्यकता थी।

Note: इंस्टॉल करने योग्य होने के लिए, क्रोम के लिए आवश्यक है कि आप कम से कम 192x192px आइकन और 512x512px आइकन प्रदान करें। लेकिन आप अन्य आकार भी प्रदान कर सकते हैं। Chrome 48dp के निकटतम आइकन का उपयोग करता है, उदाहरण के लिए, 2x डिवाइस पर 96px या 3x डिवाइस के लिए 144px।

### वेब ऐप मैनिफ़ेस्ट का लिंक जोड़ें

इसके बाद, हमें अपने ऐप में प्रत्येक पृष्ठ पर एक `<link rel="manifest"...` जोड़कर अपने `<link rel="manifest"...` बारे में ब्राउज़र को बताना होगा। अपनी `index.html` फ़ाइल में `<head>` तत्व में निम्न पंक्ति जोड़ें।

#### [public/index.html](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L30)

```html
<!-- CODELAB: Add link rel manifest -->
<link rel="manifest" href="/manifest.json">
```

#### DevTools Detour

DevTools आपकी `manifest.json` फाइल की जाँच करने के लिए एक त्वरित, आसान तरीका प्रदान करता है। __Application__ पैनल पर __Manifest__ फलक खोलें। यदि आपने सूचना को सही तरीके से जोड़ा है, तो आप इसे फलक पर मानव-अनुकूल प्रारूप में पार्स और प्रदर्शित कर पाएंगे।

![c462743e1bc26958.png](img/c462743e1bc26958.png)

### iOS मेटा टैग और आइकन जोड़ें

IOS पर Safari वेब अनुप्रयोग प्रकट (समर्थन नहीं करता [yet](https://webkit.org/status/#specification-web-app-manifest) ) है, तो आप जोड़ने की आवश्यकता होगी [traditional `meta` tags](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html) को `<head>` अपने की `index.html` फ़ाइल:

#### [public/index.html](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L31)

```html
<!-- CODELAB: Add iOS meta tags and icons -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Weather PWA">
<link rel="apple-touch-icon" href="/images/icons/icon-152x152.png">
```

### बोनस: आसान प्रकाशस्तंभ फिक्स

हमारे लाइटहाउस ऑडिट ने कुछ अन्य चीजें बताईं, जिन्हें ठीक करना बहुत आसान है, तो हम यहां रहते हुए उन बातों का ध्यान रखें।

#### मेटा विवरण सेट करें

एसईओ ऑडिट के तहत, लाइटहाउस ने बताया कि हमारे &quot; [Document does not have a meta description.](/web/tools/lighthouse/audits/description) &quot; विवरण Google के खोज परिणामों में प्रदर्शित किए जा सकते हैं। उच्च-गुणवत्ता, अद्वितीय विवरण आपके परिणामों को उपयोगकर्ताओं को खोजने के लिए अधिक प्रासंगिक बना सकते हैं और आपके खोज ट्रैफ़िक को बढ़ा सकते हैं।

विवरण जोड़ने के लिए, अपने दस्तावेज़ के `<head>` में निम्नलिखित `meta` टैग जोड़ें:

#### [public/index.html](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L32)

```html
<!-- CODELAB: Add description here -->
<meta name="description" content="A sample weather app">
```

#### पता बार थीम रंग सेट करें

PWA ऑडिट में, लाइटहाउस ने हमारे ऐप &quot; [Does not set an address-bar theme color](/web/tools/lighthouse/audits/address-bar) &quot; को नोट किया। अपने ब्रांड के रंगों से मिलान करने के लिए ब्राउज़र के एड्रेस बार का उपयोग अधिक उपयोगकर्ता अनुभव प्रदान करता है।

मोबाइल पर थीम रंग सेट करने के लिए, अपने दस्तावेज़ के `<head>` में निम्नलिखित `meta` टैग जोड़ें:

#### [public/index.html](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L33)

```html
<!-- CODELAB: Add meta theme-color -->
<meta name="theme-color" content="#2F3BA2" />
```

### लाइटहाउस के साथ परिवर्तनों को सत्यापित करें

लाइटहाउस को फिर से चलाएँ (ऑडिट फलक के ऊपरी बाएँ कोने में + चिह्न पर क्लिक करके) और अपने परिवर्तनों को सत्यापित करें।

__SEO लेखापरीक्षा__

* __✅ अच्छा:__ दस्तावेज़ में एक मेटा विवरण है।

__प्रतिस्पर्धी वेब ऐप Audit__

* __❗असफल हुआ:__ वर्तमान पृष्ठ ऑफ़लाइन होने पर 200 के साथ उत्तर नहीं देता है।
* __❗असफल हुआ:__ `start_url` ऑफ़लाइन होने पर 200 के साथ जवाब नहीं देता है।
* __❗असफल हुआ:__ पेज और `start_url.` नियंत्रित करने वाले सेवा कार्यकर्ता को पंजीकृत नहीं करता है
* __✅ अच्छा:__ वेब ऐप मेनिफेस्टेबिलिटी आवश्यकताओं को पूरा करता है
* __✅ अच्छा:__ एक कस्टम स्प्लैश स्क्रीन के लिए कॉन्फ़िगर किया गया।
* __✅ अच्छा:__ एक एड्रेस-बार थीम कलर सेट करता है।

## एक बुनियादी ऑफ़लाइन अनुभव प्रदान करें

उपयोगकर्ताओं से एक उम्मीद है कि इंस्टॉल किए गए ऐप में ऑफ़लाइन होने पर हमेशा आधारभूत अनुभव होगा। यही कारण है कि यह इंस्टॉल करने योग्य वेब ऐप्स के लिए महत्वपूर्ण है कि क्रोम के ऑफ़लाइन डायनासोर को कभी न दिखाएं। ऑफ़लाइन अनुभव एक साधारण, ऑफ़लाइन पृष्ठ से हो सकता है, पहले से कैश किए गए डेटा के साथ केवल-पढ़ने के लिए अनुभव, पूरी तरह कार्यात्मक ऑफ़लाइन अनुभव के लिए सभी तरह से जो नेटवर्क कनेक्शन बहाल होने पर स्वचालित रूप से सिंक करता है।

इस अनुभाग में, हम अपने मौसम ऐप में एक सरल ऑफ़लाइन पेज जोड़ने जा रहे हैं। यदि उपयोगकर्ता ऑफ़लाइन रहते हुए ऐप को लोड करने का प्रयास करता है, तो यह हमारे कस्टम पेज को दिखाएगा, बजाय ब्राउज़र को दिखाए गए विशिष्ट ऑफ़लाइन पेज के। इस अनुभाग के अंत तक, हमारा मौसम ऐप निम्नलिखित ऑडिट पास करेगा:

* वर्तमान पृष्ठ ऑफ़लाइन होने पर 200 के साथ उत्तर नहीं देता है।
* `start_url` ऑफ़लाइन होने पर 200 के साथ प्रतिक्रिया नहीं देता है।
* एक सेवा कार्यकर्ता को पंजीकृत नहीं करता है जो पृष्ठ और `start_url.` नियंत्रित करता है

अगले भाग में, हम अपने कस्टम ऑफ़लाइन पेज को पूर्ण ऑफ़लाइन अनुभव से बदल देंगे। यह ऑफ़लाइन अनुभव में सुधार करेगा, लेकिन इससे भी महत्वपूर्ण बात यह है कि यह हमारे प्रदर्शन में काफी सुधार लाएगा, क्योंकि हमारी अधिकांश संपत्ति (HTML, CSS और JavaScript) स्थानीय रूप से संग्रहीत और सेवा की जाएगी, नेटवर्क को संभावित अड़चन के रूप में समाप्त कर देगा।

### बचाव के लिए सेवा कार्यकर्ता

यदि आप [Introduction To Service Workers](/web/fundamentals/primers/service-worker/) अपरिचित हैं, तो आप [Introduction To Service Workers](/web/fundamentals/primers/service-worker/) को पढ़कर एक बुनियादी समझ प्राप्त कर सकते हैं कि वे क्या कर सकते हैं, उनका जीवनचक्र कैसे काम करता है। एक बार जब आप इस कोड लैब को पूरा कर लेते हैं, तो सेवा श्रमिकों के साथ काम करने के तरीके के बारे में अधिक [Debugging Service Workers code lab](http://goo.gl/jhXCBy) लिए [Debugging Service Workers code lab](http://goo.gl/jhXCBy) जांच करना सुनिश्चित करें।

सेवा श्रमिकों के माध्यम से प्रदान की जाने वाली सुविधाओं को एक प्रगतिशील वृद्धि माना जाना चाहिए, और केवल ब्राउज़र द्वारा समर्थित होने पर जोड़ा जाएगा। उदाहरण के लिए, [app shell](/web/fundamentals/architecture/app-shell) साथ आप अपने ऐप के लिए [app shell](/web/fundamentals/architecture/app-shell) और डेटा को कैश कर सकते हैं, ताकि नेटवर्क न होने पर भी यह उपलब्ध हो। जब सेवा कर्मचारियों का समर्थन नहीं किया जाता है, तो ऑफ़लाइन कोड को कॉल नहीं किया जाता है, और उपयोगकर्ता को एक मूल अनुभव मिलता है। प्रगतिशील एन्हांसमेंट प्रदान करने के लिए फीचर डिटेक्शन का उपयोग करने से बहुत अधिक ओवरहेड होता है और यह पुराने ब्राउज़र में नहीं टूटेगा जो उस सुविधा का समर्थन नहीं करते हैं।

Warning: सेवा कार्यकर्ता कार्यक्षमता केवल उन पृष्ठों पर उपलब्ध है जो HTTPS (http: // localhost और समतुल्य भी परीक्षण की सुविधा के लिए काम करेंगे) के माध्यम से उपलब्ध हैं।

### सेवा कार्यकर्ता का पंजीकरण करें

सेवा कार्यकर्ता को पंजीकृत करने के लिए पहला कदम है। आपके लिए निम्न कोड जोड़ें `index.html` फ़ाइल:

#### [public/index.html](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L206)

```js
// CODELAB: Register service worker.
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
        .then((reg) => {
          console.log('Service worker registered.', reg);
        });
  });
}
```

इस कोड को अगर सेवा कार्यकर्ता एपीआई उपलब्ध है देखने के लिए जाँच करता है, और अगर ऐसा है, पर सेवा कार्यकर्ता `/service-worker.js` एक बार पेज है पंजीकृत है [loaded](/web/fundamentals/primers/service-workers/registration) ।

ध्यान दें, सर्विस वर्कर को रूट डायरेक्टरी से काम किया जाता है, `/scripts/` डायरेक्टरी से नहीं। यह आपके सेवा कार्यकर्ता के __ `scope` __ को सेट करने का सबसे आसान तरीका है। सेवा कर्मी का `scope` यह निर्धारित करता है कि सेवा कर्मी किस फाइल को नियंत्रित करता है, दूसरे शब्दों में, जिस रास्ते से सेवा कर्मी अनुरोधों को रोक देगा। डिफ़ॉल्ट `scope` सेवा कार्यकर्ता फ़ाइल का स्थान है, और नीचे सभी निर्देशिकाओं तक फैली हुई है। इसलिए यदि `service-worker.js` रूट डायरेक्टरी में स्थित है, तो सेवा कार्यकर्ता इस डोमेन के सभी वेब पेजों से अनुरोधों को नियंत्रित करेगा।

### Precache ऑफ़लाइन पृष्ठ

पहले, हमें सेवा कार्यकर्ता को यह बताना होगा कि कैश क्या करना है। हमने पहले से ही एक सरल [offline page](https://your-first-pwa.glitch.me/offline.html) ( `public/offline.html` ) बनाया है जो हम किसी भी समय प्रदर्शित करेंगे जब कोई नेटवर्क कनेक्शन नहीं है।

अपने `service-worker.js` , `'/offline.html',` को `FILES_TO_CACHE` सरणी में जोड़ें, अंतिम परिणाम इस तरह दिखना चाहिए:

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L23)

```js
// CODELAB: Update cache names any time any of the cached files change.
const FILES_TO_CACHE = [
  '/offline.html',
];
```

अगला, हमें सेवा कार्यकर्ता को ऑफलाइन पेज को प्री-कैश करने के लिए `install` ईवेंट को अपडेट करने की आवश्यकता है:

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L29)

```js
// CODELAB: Precache static resources here.
evt.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[ServiceWorker] Pre-caching offline page');
      return cache.addAll(FILES_TO_CACHE);
    })
);
```

Note: सेवा कर्मी घटनाओं और जीवन चक्र अगले भाग में शामिल किया गया है।

हमारी `install` घटना अब `caches.open()` साथ कैश को `caches.open()` और कैश नाम प्रदान करती है। कैश नाम प्रदान करने से हम फ़ाइलों को संस्करणित कर सकते हैं, या कैश्ड संसाधनों से डेटा को अलग कर सकते हैं ताकि हम आसानी से एक को अपडेट कर सकें लेकिन दूसरे को प्रभावित न करें।

एक बार कैश खुलने के बाद, हम फिर से कॉल कर सकते हैं `cache.addAll()` , जो URL की एक सूची लेता है, उन्हें सर्वर से प्राप्त करता है और कैश में प्रतिक्रिया जोड़ता है। ध्यान दें कि अगर कोई भी व्यक्तिगत अनुरोध विफल रहता है तो `cache.addAll()` अस्वीकार कर देगा। इसका मतलब है कि आप इस बात की गारंटी दे रहे हैं कि यदि इंस्टॉल स्टेप सफल होता है, तो आप कैश एक सुसंगत स्थिति में होंगे। लेकिन, अगर यह किसी कारण से विफल हो जाता है, तो यह स्वचालित रूप से अगली बार सेवा कार्यकर्ता शुरू होने पर फिर से कोशिश करेगा।

#### DevTools Detour

आइए एक नज़र डालते हैं कि आप सेवा कर्मियों को समझने और डिबग करने के लिए DevTools का उपयोग कैसे कर सकते हैं। अपना पृष्ठ पुनः लोड करने से पहले, DevTools खोलें, __Applic____ पैनल पर __Service Workers__ फलक पर जाएँ। इसे ऐसा दिखना चाहिए:

![b3aa37b67863fd03.png](img/b3aa37b67863fd03.png)

जब आप इस तरह एक खाली पृष्ठ देखते हैं, तो इसका मतलब है कि वर्तमान में खुले पृष्ठ में कोई पंजीकृत सेवा कार्यकर्ता नहीं है।

अब, अपने पृष्ठ को पुनः लोड करें। सेवा कार्यकर्ता फलक को अब इस तरह दिखना चाहिए:

![69808e4bf3aee41b.png](img/69808e4bf3aee41b.png)

जब आप इस तरह की जानकारी देखते हैं, तो इसका मतलब है कि पृष्ठ में एक सेवा कार्यकर्ता चल रहा है।

स्टेटस लेबल के आगे, एक नंबर (*34251* इस मामले में) है, उस नंबर पर नज़र रखें, जैसा कि आप सेवा कार्यकर्ताओं के साथ काम कर रहे हैं। यह बताने का एक आसान तरीका है कि क्या आपके सेवा कार्यकर्ता को अपडेट किया गया है।

### पुराने ऑफ़लाइन पृष्ठों को साफ करें

हम अपने कैश में किसी भी पुराने डेटा को साफ़ करने के लिए `activate` घटना का उपयोग करेंगे। यह कोड सुनिश्चित करता है कि आपका सेवा कर्मी जब भी कोई भी शेल फ़ाइल बदलता है, तो उसका कैश अपडेट कर दे। इसे काम करने के लिए, आपको अपनी सेवा कार्यकर्ता फ़ाइल के शीर्ष पर `CACHE_NAME` चर को बढ़ाना होगा।

अपने `activate` ईवेंट में निम्न कोड जोड़ें:

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L36)

```js
// CODELAB: Remove previous cached data from disk.
evt.waitUntil(
    caches.keys().then((keyList) => {
      return Promise.all(keyList.map((key) => {
        if (key !== CACHE_NAME) {
          console.log('[ServiceWorker] Removing old cache', key);
          return caches.delete(key);
        }
      }));
    })
);
```

#### DevTools Detour

सेवा कार्यकर्ता फलक खुला होने के साथ, पृष्ठ को ताज़ा करें, आप नए सेवा कार्यकर्ता को स्थापित करेंगे और स्थिति संख्या वृद्धि देखेंगे।

![1db827d76bc0b359.png](img/1db827d76bc0b359.png)

अपडेटेड सर्विस वर्कर तुरंत नियंत्रण में ले लेता है क्योंकि हमारी `install` ईवेंट, `self.skipWaiting()` साथ समाप्त हो `self.skipWaiting()` , और `activate` ईवेंट `self.clients.claim()` साथ समाप्त हो `self.clients.claim()` । उन लोगों के बिना, पुराने सेवा कार्यकर्ता पृष्ठ को तब तक नियंत्रित करना जारी रखेगा जब तक पृष्ठ पर एक टैब खुला रहता है।

### हैंडल विफल नेटवर्क अनुरोध

और अंत में, हमें `fetch` घटनाओं को संभालने की आवश्यकता है। हम एक [network, falling back to cache strategy](/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache) का उपयोग करने जा रहे हैं। सेवा कार्यकर्ता पहले नेटवर्क से संसाधन लाने की कोशिश करेगा, यदि वह विफल रहता है, तो वह कैश से ऑफ़लाइन पृष्ठ वापस कर देगा।

![6302ad4ba8460944.png](img/6302ad4ba8460944.png)

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L43)

```js
// CODELAB: Add fetch event handler here.
if (evt.request.mode !== 'navigate') {
  // Not a page navigation, bail.
  return;
}
evt.respondWith(
    fetch(evt.request)
        .catch(() => {
          return caches.open(CACHE_NAME)
              .then((cache) => {
                return cache.match('offline.html');
              });
        })
);
```

`fetch` हैंडलर को केवल पृष्ठ नेविगेट करने की आवश्यकता होती है, इसलिए अन्य अनुरोधों को हैंडलर से बाहर निकाला जा सकता है और ब्राउज़र द्वारा सामान्य रूप से निपटा जाएगा। लेकिन, यदि अनुरोध `.mode` `navigate` , तो नेटवर्क से आइटम प्राप्त करने के लिए प्रयास करें `fetch` का उपयोग करें। अगर यह विफल रहता है, तो `catch` हैंडलर कैश को `caches.open(CACHE_NAME)` साथ `caches.open(CACHE_NAME)` और `cache.match('offline.html')` से मौजूद ऑफ़लाइन पेज को पाने के लिए WORDS6 का उपयोग करता है। फिर परिणाम को `evt.respondWith()` उपयोग से ब्राउज़र में वापस भेज दिया जाता है।

Key Point: रैपिंग `fetch` में कॉल [`evt.respondWith()`](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith) ब्राउज़रों डिफ़ॉल्ट से निपटने लाने को रोकता है और ब्राउज़र हम प्रतिक्रिया अपने आप को हैंडल करना चाहते हैं बताता है। अगर आप `fetch` हैंडलर के अंदर `evt.respondWith()` को नहीं बुलाते हैं, तो आपको डिफ़ॉल्ट नेटवर्क व्यवहार मिलेगा।

#### DevTools Detour

आइए यह सुनिश्चित करने के लिए जांचें कि सब कुछ काम करता है जैसा कि हम उम्मीद करते हैं। सेवा कार्यकर्ता फलक खुला होने के साथ, पृष्ठ को ताज़ा करें, आप नए सेवा कार्यकर्ता को स्थापित करेंगे और स्थिति संख्या वृद्धि देखेंगे।

हम यह भी देख सकते हैं कि क्या कैश किया गया है। DevTools के __Application__ पैनल पर __Cache Storage__ फलक पर जाएं। राइट-क्लिक करें __Cache Storage__, __Refresh Caches__ चुनें, सेक्शन का विस्तार करें और आपको बाईं ओर सूचीबद्ध अपने स्थिर कैश का नाम देखना चाहिए। कैश नाम पर क्लिक करने से उन सभी फ़ाइलों का पता चलता है जो कैश की गई हैं।

![c80a2a2e93c1c3ee.png](img/c80a2a2e93c1c3ee.png)

अब, ऑफ़लाइन मोड का परीक्षण करते हैं। DevTools के __Service Workers__ फलक पर वापस जाएँ और __Offline__ चेकबॉक्स की जाँच करें। इसे जांचने के बाद, आपको __Network__ पैनल टैब के बगल में थोड़ा पीला चेतावनी आइकन देखना चाहिए। यह इंगित करता है कि आप ऑफ़लाइन हैं।

![984b34dc2aa667a.png](img/984b34dc2aa667a.png)

अपने पृष्ठ को पुनः लोड करें और ... यह काम करता है! हमें क्रोम के ऑफ़लाइन डिनो के बजाय __our__ ऑफ़लाइन पांडा मिलता है!

### सेवा कार्यकर्ताओं के परीक्षण के लिए सुझाव

सेवा कार्यकर्ताओं को डीबग करना एक चुनौती हो सकती है, और जब इसमें कैशिंग शामिल होता है, तो चीजें दुःस्वप्न की तरह बन सकती हैं यदि आप इसकी अपेक्षा करते समय कैश अपडेट नहीं करते हैं विशिष्ट सेवा कार्यकर्ता जीवनचक्र और आपके कोड में बग के बीच, आप जल्दी निराश हो सकते हैं। __But नहीं। !!!!

#### DevTools का उपयोग करें

एप्लिकेशन पैनल के सर्विस वर्कर्स फलक में, कुछ चेकबॉक्स हैं जो आपके जीवन को बहुत आसान बना देंगे।

![c7ac93904f473a91.png](img/c7ac93904f473a91.png)

* __Offline__ - जब चेक किया गया एक ऑफ़लाइन अनुभव का अनुकरण करता है और किसी भी अनुरोध को नेटवर्क पर जाने से रोकता है।
* __Update on reload__ - जब जाँच की जाएगी कि नवीनतम सेवा कर्मी मिलेगा, इसे स्थापित करें, और तुरंत इसे सक्रिय करें
* ___ नेटवर्क के लिए बायपास करें - जब चेक किए गए अनुरोध सेवा कर्मी को बायपास करते हैं और सीधे नेटवर्क पर भेजे जाते हैं।

#### नए #### शुरू करें

कुछ मामलों में, आप अपने आप को कैश्ड डेटा लोड कर सकते हैं या वह चीजें अपडेट नहीं की जाती हैं जैसी आप उम्मीद करते हैं। सभी सहेजे गए डेटा (लोकलस्टोरेज, इंडेक्सडीडीबी डेटा, कैश्ड फाइल) को हटाने और किसी भी सेवाकर्मियों को हटाने के लिए, एप्लिकेशन टैब में क्लियर स्टोरेज पेन का उपयोग करें। वैकल्पिक रूप से, आप एक गुप्त विंडो में भी काम कर सकते हैं।

![398bbcd285e2c5dd.png](img/398bbcd285e2c5dd.png)

अतिरिक्त सुझाव:

* एक बार एक सेवाकर्मी के अपंजीकृत होने के बाद, यह तब तक सूचीबद्ध रह सकता है जब तक कि इसकी ब्राउज़र विंडो बंद न हो जाए।
* यदि आपके ऐप की कई विंडो खुली हैं, तो एक नया सेवा कर्मचारी तब तक प्रभावी नहीं होगा, जब तक कि सभी विंडोज़ को नवीनतम सर्विस वर्कर को पुनः लोड और अपडेट न कर दिया जाए।
* किसी सेवा कर्मी को अपंजीकृत करने से कैश साफ़ नहीं होता!
* यदि एक सेवा कार्यकर्ता मौजूद है और एक नया सेवा कर्मी पंजीकृत है, तो नया सेवा कर्मचारी तब तक नियंत्रण नहीं करेगा, जब तक कि पृष्ठ को पुनः लोड नहीं किया जाता है, जब तक कि आप [take immediate control](/web/fundamentals/primers/service-workers/lifecycle#clientsclaim) नहीं करते।

### लाइटहाउस के साथ परिवर्तनों को सत्यापित करें

लाइटहाउस को फिर से चलाएँ और अपने परिवर्तनों को सत्यापित करें। अपने परिवर्तनों को सत्यापित करने से पहले ऑफ़लाइन चेकबॉक्स को अनचेक करना न भूलें!

__SEO लेखापरीक्षा__

* __✅ अच्छा:__ दस्तावेज़ में एक मेटा विवरण है।

__प्रतिस्पर्धी वेब ऐप Audit__

* __✅ अच्छा:__ वर्तमान पृष्ठ ऑफ़लाइन होने पर 200 के साथ उत्तर देता है।
* __✅ अच्छा:__ `start_url` करता है जब 200 ऑफ़लाइन होता है
* __✅ अच्छा:__ एक सेवा कार्यकर्ता को नियंत्रित करता है जो पेज और `start_url.` नियंत्रित करता है
* __✅ अच्छा:__ वेब ऐप मेनिफेस्टेबिलिटी आवश्यकताओं को पूरा करता है
* __✅ अच्छा:__ एक कस्टम स्प्लैश स्क्रीन के लिए कॉन्फ़िगर किया गया।
* __✅ अच्छा:__ एक एड्रेस-बार थीम कलर सेट करता है।

## एक पूर्ण ऑफ़लाइन अनुभव प्रदान करें

एक क्षण लें और अपने फोन को हवाई जहाज मोड में डालें, और अपने कुछ पसंदीदा ऐप चलाने का प्रयास करें। लगभग सभी मामलों में, वे काफी मजबूत ऑफ़लाइन अनुभव प्रदान करते हैं। उपयोगकर्ताओं को अपने ऐप्स से उस मजबूत अनुभव की उम्मीद है। और वेब अलग नहीं होना चाहिए। प्रोग्रेसिव वेब ऐप्स को एक कोर परिदृश्य के रूप में ऑफ़लाइन डिज़ाइन किया जाना चाहिए।

Key Point: ऑफ़लाइन-पहले के लिए डिज़ाइन करना आपके ऐप द्वारा किए गए नेटवर्क अनुरोधों की संख्या को कम करके आपके वेब ऐप के प्रदर्शन में काफी सुधार कर सकता है, इसके बजाय संसाधनों को स्थानीय कैश से सीधे प्रसारित और सेवा की जा सकती है। यहां तक कि सबसे तेज़ नेटवर्क कनेक्शन के साथ, स्थानीय कैश से सेवा तेज हो जाएगी!

### सेवा कार्यकर्ता जीवन चक्र

सेवा कार्यकर्ता का जीवन चक्र सबसे जटिल हिस्सा है। यदि आप नहीं जानते कि यह क्या करने की कोशिश कर रहा है और क्या लाभ हैं, तो ऐसा महसूस हो सकता है कि यह आपसे लड़ रहा है। लेकिन एक बार जब आप यह जान जाते हैं कि यह कैसे काम करता है, तो आप उपयोगकर्ताओं को वेब और देशी पैटर्नों का सबसे अच्छा मिश्रण करके सहज, विनीत अपडेट प्रदान कर सकते हैं।

Key Point: यह कोडलैब केवल सेवा कार्यकर्ता जीवन चक्र की मूल बातें शामिल करता है। गहरा गोता लगाने के लिए, [The Service Worker Lifecycle](/web/fundamentals/primers/service-workers/lifecycle) पर WORDS0 लेख देखें।

#### `install` event

सेवा कार्यकर्ता को `install` वाली पहली घटना `install` । जैसे ही कार्यकर्ता निष्पादित करता है, यह ट्रिगर हो जाता है, और इसे केवल एक बार सेवा कार्यकर्ता के रूप में कहा जाता है। __अगर आप अपनी सर्विस वर्कर स्क्रिप्ट को बदल देते हैं तो ब्राउज़र इसे एक अलग सर्विस वर्कर__ मानता है, और इसे अपना `install` इवेंट मिल जाएगा।

![72ed77b1720512da.png](img/72ed77b1720512da.png)

आमतौर पर `install` ईवेंट का उपयोग आपके ऐप को चलाने के लिए आपकी ज़रूरत की हर चीज़ को कैश करने के लिए किया जाता है।

#### `activate` event

सेवा कर्मी को हर बार शुरू होने पर एक `activate` ईवेंट प्राप्त होगा। `activate` घटना का मुख्य उद्देश्य सेवा कार्यकर्ता के व्यवहार को कॉन्फ़िगर करना है, पिछले रन (जैसे पुराने कैश) से पीछे `activate` किसी भी संसाधन को साफ करना, और नेटवर्क अनुरोधों को संभालने के लिए सेवा कार्यकर्ता को तैयार करना (उदाहरण के लिए नीचे वर्णित `fetch` घटना)।

#### `fetch` event

भ्रूण घटना सेवा कर्मी को किसी भी नेटवर्क अनुरोध को रोकने और अनुरोधों को संभालने की अनुमति देती है। यह संसाधन प्राप्त करने के लिए नेटवर्क पर जा सकता है, इसे अपने कैश से खींच सकता है, एक कस्टम प्रतिक्रिया या विभिन्न विकल्पों में से किसी भी संख्या को उत्पन्न कर सकता है। विभिन्न रणनीतियों के लिए [Offline Cookbook](/web/fundamentals/instant-and-offline/offline-cookbook/) देखें जो आप उपयोग कर सकते हैं।

#### एक सेवा कार्यकर्ता अपडेट कर रहा है

ब्राउज़र यह देखने के लिए जांचता है कि क्या प्रत्येक पृष्ठ लोड पर आपके सेवा कार्यकर्ता का नया संस्करण है या नहीं। यदि यह एक नया संस्करण पाता है, तो नया संस्करण पृष्ठभूमि में डाउनलोड और इंस्टॉल किया गया है, लेकिन यह सक्रिय नहीं है। यह एक प्रतीक्षा की स्थिति में बैठता है, जब तक कि कोई भी पेज नहीं खुलता है जो पुराने सेवा कार्यकर्ता का उपयोग करते हैं। पुराने सर्विस वर्कर के उपयोग से सभी विंडो बंद हो जाने के बाद, नया सर्विस वर्कर सक्रिय हो जाता है और नियंत्रण कर सकता है। आगे के विवरण के लिए सेवा कार्यकर्ता जीवनचक्र डॉक के [Updating the service worker](/web/fundamentals/primers/service-workers/lifecycle#updates) खंड का संदर्भ लें।

### सही कैशिंग रणनीति का चयन

सही [caching strategy](/web/fundamentals/instant-and-offline/offline-cookbook/) चयन उस संसाधन के प्रकार पर निर्भर करता है जिसे आप कैश करने की कोशिश कर रहे हैं और बाद में आपको इसकी आवश्यकता कैसे पड़ सकती है। हमारे मौसम एप्लिकेशन के लिए, हम उन संसाधनों को विभाजित करेंगे जिन्हें हमें दो श्रेणियों में कैश करने की आवश्यकता है: संसाधन जिन्हें हम कैश करना चाहते हैं और जो डेटा हम रनटाइम पर कैश करेंगे।

#### स्थिर संसाधनों की कैशिंग

अपने संसाधनों को रोकना एक ऐसी अवधारणा है जो तब होती है जब उपयोगकर्ता डेस्कटॉप या मोबाइल एप्लिकेशन इंस्टॉल करता है। एप्लिकेशन को चलाने के लिए आवश्यक मुख्य संसाधन इंस्टॉल किए गए हैं, या डिवाइस पर कैश किए गए हैं ताकि उन्हें बाद में लोड किया जा सके कि क्या नेटवर्क कनेक्शन है या नहीं।

हमारे ऐप के लिए, हम अपने सभी स्थिर संसाधनों को प्रीचेज करेंगे, जब हमारा सर्विस वर्कर इंस्टॉल हो जाएगा ताकि हमारे ऐप को चलाने के लिए हमें जो कुछ भी चाहिए वह यूजर के डिवाइस पर स्टोर हो। यह सुनिश्चित करने के लिए कि हमारा ऐप तेज़ गति से लोड हो रहा है, हम [cache-first](/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network) रणनीति का उपयोग करेंगे; संसाधनों को प्राप्त करने के लिए नेटवर्क पर जाने के बजाय, वे स्थानीय कैश से खींचे जाते हैं; केवल यह उपलब्ध नहीं होने पर हम इसे नेटवर्क से प्राप्त करने का प्रयास करेंगे।

![44860840e2090bd8.png](img/44860840e2090bd8.png)

स्थानीय कैश से खींचना किसी भी नेटवर्क परिवर्तनशीलता को समाप्त करता है। कोई फर्क नहीं पड़ता कि उपयोगकर्ता किस तरह का नेटवर्क है (वाईफाई, 5 जी, 3 जी, या 2 जी), हमें जिन प्रमुख संसाधनों को चलाने की आवश्यकता है, वे लगभग तुरंत उपलब्ध हैं।

Caution: इस नमूने में, स्थैतिक संसाधनों को एक [`cache-first`](/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network) रणनीति का उपयोग करके परोसा जाता है, जिसके परिणामस्वरूप किसी भी कैश की गई सामग्री की प्रतिलिपि नेटवर्क के परामर्श के बिना वापस आ जाती है। हालांकि एक `cache-first` रणनीति को लागू करना आसान है, यह भविष्य में चुनौतियों का कारण बन सकता है।

#### एप्लिकेशन डेटा कैशिंग

[stale-while-revalidate strategy](/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate) आदर्श डेटा के कुछ प्रकार है और हमारे app के लिए अच्छी तरह से काम करता है। यह स्क्रीन पर डेटा को जितनी जल्दी हो सके, फिर अपडेट करता है कि एक बार नेटवर्क ने नवीनतम डेटा वापस कर दिया है। बासी-जबकि-अमान्य का मतलब है कि हमें दो अतुल्यकालिक अनुरोधों को किक करना होगा, एक कैश और एक नेटवर्क में।

![6ebb2681eb1f58cb.png](img/6ebb2681eb1f58cb.png)

सामान्य परिस्थितियों में, कैश्ड डेटा को लगभग तुरंत वापस कर दिया जाएगा, जिससे ऐप हाल ही के डेटा का उपयोग कर सके। फिर, जब नेटवर्क अनुरोध वापस आएगा, तो नेटवर्क से नवीनतम डेटा का उपयोग करके ऐप को अपडेट किया जाएगा।

हमारे ऐप के लिए, यह नेटवर्क की तुलना में बेहतर अनुभव प्रदान करता है, कैश रणनीति पर वापस आ रहा है क्योंकि उपयोगकर्ता को स्क्रीन पर कुछ देखने के लिए नेटवर्क के अनुरोध के समय तक इंतजार नहीं करना पड़ता है। वे शुरू में पुराने डेटा को देख सकते हैं, लेकिन एक बार नेटवर्क अनुरोध वापस आने पर, ऐप को नवीनतम डेटा के साथ अपडेट किया जाएगा।

### ऐप लॉजिक अपडेट करें

जैसा कि पहले उल्लेख किया गया है, ऐप को दो अतुल्यकालिक अनुरोधों को बंद करना होगा, एक को कैश और एक को नेटवर्क में। ऐप कैश का उपयोग करने और नवीनतम डेटा को पुनः प्राप्त करने के लिए `window` में उपलब्ध `caches` ऑब्जेक्ट का उपयोग करता है। यह प्रगतिशील वृद्धि का एक उत्कृष्ट उदाहरण है क्योंकि सभी ब्राउज़र में `caches` ऑब्जेक्ट उपलब्ध नहीं हो सकता है, और यदि यह नेटवर्क अनुरोध अभी भी काम नहीं करता है

`getForecastFromCache()` फ़ंक्शन को अपडेट करें, यह जांचने के लिए कि क्या `caches` ऑब्जेक्ट वैश्विक `window` ऑब्जेक्ट में उपलब्ध है, और यदि है, तो कैश से डेटा का अनुरोध करें।

#### [public/scripts/app.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L164)

```js
// CODELAB: Add code to get weather forecast from the caches object.
if (!('caches' in window)) {
  return null;
}
const url = `${window.location.origin}/forecast/${coords}`;
return caches.match(url)
    .then((response) => {
      if (response) {
        return response.json();
      }
      return null;
    })
    .catch((err) => {
      console.error('Error getting data from cache', err);
      return null;
    });
```

फिर, हमें [`updateData()`](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L196) को संशोधित करने की आवश्यकता है ताकि यह नेटवर्क से पूर्वानुमान प्राप्त करने के लिए `getForecastFromNetwork()` से एक को कॉल करे, और नवीनतम कैशेड पूर्वानुमान प्राप्त करने के लिए `getForecastFromCache()` से एक:

#### [public/scripts/app.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L200)

```js
// CODELAB: Add code to call getForecastFromCache.
getForecastFromCache(location.geo)
    .then((forecast) => {
      renderForecast(card, forecast);
    });
```

हमारा मौसम ऐप अब डेटा के लिए दो एसिंक्रोनस अनुरोध करता है, एक कैश से और एक `fetch` जरिए। यदि कैश में डेटा है, तो इसे वापस लौटाया जाएगा और बहुत जल्दी (दसियों मिलीसेकेंड) प्रदान किया जाएगा। फिर, जब `fetch` प्रतिक्रिया करता है, तो कार्ड को मौसम एपीआई से सीधे ताजे डेटा के साथ अपडेट किया जाएगा।

गौर करें कि पूर्वानुमान कार्ड को अपडेट करने के लिए कैशे अनुरोध और `fetch` दोनों कॉल के साथ कैसे अनुरोध करते हैं। एप्लिकेशन को कैसे पता चलता है कि वह नवीनतम डेटा प्रदर्शित कर रहा है या नहीं? यह `renderForecast()` से निम्नलिखित कोड में संभाला गया है:

#### [public/scripts/app.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L85)

```js
// If the data on the element is newer, skip the update.
if (lastUpdated >= data.currently.time) {
  return;
}
```

हर बार जब कोई कार्ड अपडेट किया जाता है, तो ऐप कार्ड के छिपे विशेषता पर डेटा के टाइमस्टैम्प को संग्रहीत करता है। ऐप केवल तभी घंटी बजाता है जब कार्ड पर मौजूद टाइमस्टैम्प पहले से मौजूद फ़ंक्शन के डेटा की तुलना में नया हो।

### हमारे ऐप संसाधनों को प्री-कैश करें

सेवा कार्यकर्ता में, हम एक `DATA_CACHE_NAME` ताकि हम अपने एप्लिकेशन डेटा को ऐप शेल से अलग कर सकें। जब ऐप शेल को अपडेट किया जाता है और पुराने कैश को शुद्ध किया जाता है, तो हमारा डेटा अनछुआ रहेगा, सुपर फास्ट लोड के लिए तैयार है। ध्यान रखें, यदि भविष्य में आपका डेटा प्रारूप बदलता है, तो आपको इसे संभालने और ऐप शेल और सामग्री को सिंक में सुनिश्चित करने के लिए एक तरीके की आवश्यकता होगी।

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L21)

```js
// CODELAB: Update cache names any time any of the cached files change.
const CACHE_NAME = 'static-cache-v2';
const DATA_CACHE_NAME = 'data-cache-v1';
```

`CACHE_NAME` को भी अपडेट करना न भूलें; हम अपने सभी स्थैतिक संसाधनों को भी बदलते रहेंगे।

हमारे ऐप को ऑफ़लाइन काम करने के लिए, हमें उन सभी संसाधनों की आवश्यकता है जो इसके लिए आवश्यक हैं। इससे हमारे प्रदर्शन में भी मदद मिलेगी। नेटवर्क से सभी संसाधनों को प्राप्त करने के बजाय, ऐप सभी को स्थानीय कैश से लोड करने में सक्षम होगा, किसी भी नेटवर्क अस्थिरता को समाप्त करेगा।

फ़ाइलों की सूची के साथ `FILES_TO_CACHE` सरणी को अपडेट करें:

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L23)

```js
// CODELAB: Add list of files to cache here.
const FILES_TO_CACHE = [
  '/',
  '/index.html',
  '/scripts/app.js',
  '/scripts/install.js',
  '/scripts/luxon-1.11.4.js',
  '/styles/inline.css',
  '/images/add.svg',
  '/images/clear-day.svg',
  '/images/clear-night.svg',
  '/images/cloudy.svg',
  '/images/fog.svg',
  '/images/hail.svg',
  '/images/install.svg',
  '/images/partly-cloudy-day.svg',
  '/images/partly-cloudy-night.svg',
  '/images/rain.svg',
  '/images/refresh.svg',
  '/images/sleet.svg',
  '/images/snow.svg',
  '/images/thunderstorm.svg',
  '/images/tornado.svg',
  '/images/wind.svg',
];
```

चूँकि हम फ़ाइलों को कैश करने के लिए मैन्युअल रूप से जनरेट कर रहे हैं, हर बार जब हम कोई फाइल अपडेट करते हैं तो हम __must को `CACHE_NAME` __ अपडेट करते हैं। हम कैश की गई फ़ाइलों की हमारी सूची से `offline.html` को निकालने में सक्षम थे क्योंकि हमारे ऐप में अब सभी आवश्यक संसाधन हैं जिन्हें ऑफ़लाइन काम करने की आवश्यकता है, और कभी भी ऑफ़लाइन पृष्ठ को फिर से नहीं दिखाएंगे।

Caution: इस नमूने में, हम अपने स्वयं के सेवा कार्यकर्ता को हाथ से लुढ़काते हैं। जब भी हम किसी भी स्थैतिक संसाधन को अपडेट करते हैं, हमें सेवा कर्मी को फिर से रोल करने और कैश को अपडेट करने की आवश्यकता होती है, अन्यथा पुरानी सामग्री परोसी जाएगी। इसके अलावा, जब एक फ़ाइल बदलती है, तो पूरा कैश अमान्य हो जाता है और उसे फिर से डाउनलोड करना पड़ता है। इसका मतलब है कि एक साधारण एकल वर्ण वर्तनी की गलती को ठीक करना कैश को अमान्य कर देगा और सब कुछ फिर से डाउनलोड करने की आवश्यकता होगी - बिल्कुल कुशल नहीं। [Workbox](/web/tools/workbox/) इसे अपने निर्माण की प्रक्रिया में एकीकृत करके, इनायत से संभालता है, केवल परिवर्तित फ़ाइलों को अपडेट किया जाएगा, उपयोगकर्ताओं के लिए बैंडविड्थ की बचत और आपके लिए आसान रखरखाव!

#### सक्रिय ईवेंट हैंडलर को अपडेट करें

हमारे सुनिश्चित करने के लिए `activate` घटना गलती से, हमारे डेटा नहीं हटता में `activate` की घटना `service-worker.js` , की जगह `if (key !== CACHE_NAME) {` साथ:

#### पब्लिक / सर्विस-वर्कर.जेएस

```js
if (key !== CACHE_NAME && key !== DATA_CACHE_NAME) {
```

#### लाने के लिए घटना ईवेंट हैंडलर

हमें मौसम एपीआई के अनुरोधों को स्वीकार करने और कैश में अपनी प्रतिक्रियाओं को संग्रहीत करने के लिए सेवा कार्यकर्ता को संशोधित करने की आवश्यकता है, ताकि हम बाद में आसानी से उन तक पहुंच सकें। बासी-जबकि-अमान्य रणनीति में, हम नेटवर्क की प्रतिक्रिया को &#39;सच्चाई का स्रोत&#39; होने की उम्मीद करते हैं, हमेशा हमें सबसे हालिया जानकारी प्रदान करते हैं। यदि ऐसा नहीं हो सकता, तो असफल होना ठीक है क्योंकि हमने अपने ऐप में नवीनतम कैश्ड डेटा को पहले ही प्राप्त कर लिया है।

डेटा API के अनुरोधों को अन्य अनुरोधों से अलग करने के लिए `fetch` ईवेंट हैंडलर को अपडेट करें

#### [public/service-worker.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L42)

```js
// CODELAB: Add fetch event handler here.
if (evt.request.url.includes('/forecast/')) {
  console.log('[Service Worker] Fetch (data)', evt.request.url);
  evt.respondWith(
      caches.open(DATA_CACHE_NAME).then((cache) => {
        return fetch(evt.request)
            .then((response) => {
              // If the response was good, clone it and store it in the cache.
              if (response.status === 200) {
                cache.put(evt.request.url, response.clone());
              }
              return response;
            }).catch((err) => {
              // Network request failed, try to get it from the cache.
              return cache.match(evt.request);
            });
      }));
  return;
}
evt.respondWith(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.match(evt.request)
          .then((response) => {
            return response || fetch(evt.request);
          });
    })
);
```

कोड अनुरोध को स्वीकार करता है और जांचता है कि क्या यह मौसम के पूर्वानुमान के लिए है। यदि ऐसा है, तो अनुरोध करने के लिए `fetch` का उपयोग करें। एक बार प्रतिक्रिया वापस आ जाने पर, कैश खोलें, प्रतिक्रिया को क्लोन करें, इसे कैश में स्टोर करें और मूल अनुरोधकर्ता को प्रतिक्रिया लौटाएं।

हमें `evt.request.mode !== 'navigate'` जाँच को हटाने की आवश्यकता है क्योंकि हम चाहते हैं कि हमारा सेवा कर्मचारी सभी अनुरोधों (चित्रों, लिपियों, CSS फाइलों, आदि सहित) को `evt.request.mode !== 'navigate'` , न कि केवल नौवहन। यदि हम उस चेक को छोड़ देते हैं, तो केवल HTML को सेवा कार्यकर्ता कैश से प्राप्त किया जाएगा, बाकी सब कुछ नेटवर्क से अनुरोध किया जाएगा।

### इसे आज़माएं

एप्लिकेशन को अब पूरी तरह से ऑफ़लाइन-कार्यात्मक होना चाहिए। यह सुनिश्चित करने के लिए पृष्ठ को ताज़ा करें कि आपको नवीनतम सेवा कार्यकर्ता स्थापित हो गया है, फिर कुछ शहरों को सहेजें और ताज़ा मौसम डेटा प्राप्त करने के लिए ऐप पर ताज़ा करें बटन दबाएं।

फिर DevTools के __Application__ पैनल पर __Cache Storage__ फलक पर जाएं। अनुभाग का विस्तार करें और आपको बाईं ओर सूचीबद्ध अपने स्थिर कैश और डेटा कैश का नाम देखना चाहिए। डेटा कैश खोलने पर प्रत्येक शहर के लिए संग्रहीत डेटा दिखाना चाहिए।

![731e91776cb6ef18.png](img/731e91776cb6ef18.png)

फिर, DevTools खोलें और सर्विस वर्कर फलक पर जाएँ, और ऑफ़लाइन चेकबॉक्स की जाँच करें, फिर पृष्ठ को पुनः लोड करने का प्रयास करें, और फिर ऑफ़लाइन जाकर पृष्ठ को पुनः लोड करें।

आप एक तेजी से नेटवर्क पर हों, और देखना चाहते हैं कि मौसम पूर्वानुमान डेटा कनेक्शन धीमा अद्यतन किया जाता है चाहते हैं, सेट `FORECAST_DELAY` में संपत्ति `server.js` को `5000` । पूर्वानुमान एपीआई के सभी अनुरोधों में 5000ms की देरी होगी।

### लाइटहाउस के साथ परिवर्तनों को सत्यापित करें

लाइटहाउस को फिर से चलाना भी एक अच्छा विचार है।

__SEO लेखापरीक्षा__

* __✅ अच्छा:__ दस्तावेज़ में एक मेटा विवरण है।

__प्रतिस्पर्धी वेब ऐप Audit__

* __✅ अच्छा:__ वर्तमान पृष्ठ ऑफ़लाइन होने पर 200 के साथ उत्तर देता है।
* __✅ अच्छा:__ `start_url` करता है जब 200 ऑफ़लाइन होता है
* __✅ अच्छा:__ एक सेवा कार्यकर्ता को नियंत्रित करता है जो पेज और `start_url.` नियंत्रित करता है
* __✅ अच्छा:__ वेब ऐप मेनिफेस्टेबिलिटी आवश्यकताओं को पूरा करता है
* __✅ अच्छा:__ एक कस्टम स्प्लैश स्क्रीन के लिए कॉन्फ़िगर किया गया।
* __✅ अच्छा:__ एक एड्रेस-बार थीम कलर सेट करता है।

## स्थापित अनुभव जोड़ें

जब एक प्रोग्रेसिव वेब ऐप इंस्टॉल होता है, तो यह अन्य सभी इंस्टॉल किए गए ऐप्स की तरह दिखता है और व्यवहार करता है। यह उसी जगह से लॉन्च होता है, जितना अन्य एप लॉन्च करते हैं। यह बिना एड्रेस बार या अन्य ब्राउजर यूआई के ऐप में चलता है। और अन्य सभी इंस्टॉल किए गए ऐप्स की तरह, यह टास्क स्विचर में एक शीर्ष स्तर का ऐप है।

![d824e1712e46a1cc.png](img/d824e1712e46a1cc.png)

Chrome में, एक प्रगतिशील वेब ऐप तीन-बिंदु संदर्भ मेनू के माध्यम से स्थापित किया जा सकता है, या आप उपयोगकर्ता को एक बटन या अन्य UI घटक प्रदान कर सकते हैं जो उन्हें आपके ऐप को स्थापित करने के लिए संकेत देगा।

Success: चूंकि क्रोम के थ्री-डॉट संदर्भ मेनू में इंस्टॉल का अनुभव कुछ हद तक दफन है, इसलिए हम अनुशंसा करते हैं कि आप अपने ऐप को इंस्टॉल किए जाने वाले उपयोगकर्ता को सूचित करने के लिए अपने ऐप के भीतर कुछ संकेत प्रदान करें, और इंस्टॉल प्रक्रिया को पूरा करने के लिए इंस्टॉल बटन।

### लाइटहाउस के साथ ऑडिट

किसी उपयोगकर्ता को आपके प्रगतिशील वेब ऐप को स्थापित करने में सक्षम होने के लिए, उसे [certain criteria](/web/fundamentals/app-install-banners/#criteria) से मिलने की आवश्यकता है। चेक करने का सबसे आसान तरीका लाइटहाउस का उपयोग करना है और यह सुनिश्चित करना है कि यह इंस्टॉल करने योग्य मानदंडों को पूरा करता है।

![b921f5583fcddf03.png](img/b921f5583fcddf03.png)

यदि आप इस कोडलैब के माध्यम से काम कर रहे हैं, तो आपका PWA पहले से ही इन मानदंडों को पूरा करना चाहिए।

Key Point: इस अनुभाग के लिए, नेटवर्क सेवा **** वर्कर बॉक्स में** बायपास को सक्षम करें **DevTools में** एप्लिकेशन ** पैनल का फलक। जब जाँच की जाती है, तो अनुरोध सेवा कार्यकर्ता को बायपास करता है और सीधे नेटवर्क पर भेज दिया जाता है। यह हमारी विकास प्रक्रिया को सरल बनाता है क्योंकि हमें इस अनुभाग के माध्यम से काम करते समय अपने सेवा कर्मी को अपडेट नहीं करना है।

### को index.html में जोड़ें

सबसे पहले, हमारे `index.html` फ़ाइल में `install.js` जोड़ें।

#### [public/index.html](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L204)

```html
<!-- CODELAB: Add the install script here -->
<script src="/scripts/install.js"></script>
```

### `beforeinstallprompt` घटना के लिए सुनो

अगर ऐड टू होम स्क्रीन [criteria](/web/fundamentals/app-install-banners/#criteria) हैं, तो Chrome एक `beforeinstallprompt` ईवेंट को आग लगा देगा, जिसका उपयोग आप यह संकेत देने के लिए कर सकते हैं कि आपका ऐप &#39;इंस्टॉल&#39; हो सकता है, और फिर यूज़र को इसे इंस्टॉल करने के लिए संकेत दें। `beforeinstallprompt` घटना को सुनने के लिए नीचे दिए गए कोड को जोड़ें:

#### [public/scripts/install.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L24)

```js
// CODELAB: Add event listener for beforeinstallprompt event
window.addEventListener('beforeinstallprompt', saveBeforeInstallPromptEvent);
```

### ईवेंट सहेजें और इंस्टॉल बटन दिखाएं

हमारे `saveBeforeInstallPromptEvent` फ़ंक्शन में, हम `beforeinstallprompt` ईवेंट के लिए एक संदर्भ `beforeinstallprompt` ताकि हम बाद में इस पर `prompt()` को कॉल कर `prompt()` , और इंस्टॉल बटन दिखाने के लिए हमारे UI को अपडेट कर `prompt()` ।

#### [public/scripts/install.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L34)

```js
// CODELAB: Add code to save event & show the install button.
deferredInstallPrompt = evt;
installButton.removeAttribute('hidden');
```

### प्रॉम्प्ट दिखाएँ / बटन छिपाएँ

जब उपयोगकर्ता इंस्टॉल बटन पर क्लिक करता है, तो हमें सहेजे गए कार्य `beforeinstallprompt` घटना पर `.prompt()` पर कॉल `.prompt()` । हमें इंस्टॉल बटन को छिपाने की भी आवश्यकता है, क्योंकि `.prompt()` को प्रत्येक सहेजे गए ईवेंट पर केवल एक बार कॉल किया जा सकता है।

#### [public/scripts/install.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L45)

```js
// CODELAB: Add code show install prompt & hide the install button.
deferredInstallPrompt.prompt();
// Hide the install button, it can't be called twice.
evt.srcElement.setAttribute('hidden', true);
```

`.prompt()` को कॉल करने से उपयोगकर्ता को एक मोडल डायलॉग दिखाई देगा, जिससे उन्हें अपने ऐप को अपनी होम स्क्रीन पर जोड़ने के लिए कहा जाएगा।

### परिणाम लॉग करें

आप यह देखने के लिए जांच सकते हैं कि उपयोगकर्ता ने सहेजे गए `beforeinstallprompt` इवेंट के `userChoice` गुण द्वारा दिए गए वादे को सुनकर इंस्टॉल डायलॉग का जवाब कैसे दिया। प्रॉम्प्ट में दिखाया गया है कि प्रॉम्प्ट के बाद एक `outcome` प्रॉपर्टी के साथ एक ऑब्जेक्ट लौटाता है और उपयोगकर्ता ने इसका जवाब दिया है।

#### [public/scripts/install.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L47)

```js
// CODELAB: Log user response to prompt.
deferredInstallPrompt.userChoice
    .then((choice) => {
      if (choice.outcome === 'accepted') {
        console.log('User accepted the A2HS prompt', choice);
      } else {
        console.log('User dismissed the A2HS prompt', choice);
      }
      deferredInstallPrompt = null;
    });
```

के बारे में एक टिप्पणी `userChoice` , [spec defines it as a property](https://w3c.github.io/manifest/#beforeinstallpromptevent-interface) , एक समारोह नहीं आप उम्मीद कर सकते हैं।

#### सभी स्थापित घटनाओं को लॉग इन करें

अपने ऐप को इंस्टॉल करने के लिए आपके द्वारा जोड़े गए किसी भी UI के अलावा, उपयोगकर्ता आपके PWA को अन्य तरीकों से भी इंस्टॉल कर सकते हैं, उदाहरण के लिए Chrome का तीन-डॉट मेनू। इन घटनाओं को ट्रैक करने के लिए, एप्पीटेड इवेंट के लिए सुनो।

#### [public/scripts/install.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L51)

```js
// CODELAB: Add event listener for appinstalled event
window.addEventListener('appinstalled', logAppInstalled);
```

फिर, हमें इस कोडेलैब के लिए `logAppInstalled` फ़ंक्शन को अपडेट करने की आवश्यकता है, हम बस `console.log` उपयोग `console.log` , लेकिन एक उत्पादन ऐप में, आप शायद इसे अपने एनालिटिक्स सॉफ़्टवेयर के साथ एक घटना के रूप में लॉग करना चाहते हैं।

#### [public/scripts/install.js](https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L60)

```js
// CODELAB: Add code to log the event
console.log('Weather App was installed.', evt);
```

### सेवा कर्मी को अपडेट करें

अपने `service-worker.js` फ़ाइल में `CACHE_NAME` को अपडेट करना न भूलें क्योंकि आपने पहले से ही कैश की गई फ़ाइलों में परिवर्तन कर दिया है। DevTools में एप्लिकेशन पैनल के सर्विस वर्कर्स फलक में network__ चेकबॉक्स के लिए __Bypass को इनेबल करने से विकास में काम आएगा, लेकिन यह वास्तविक दुनिया में मदद नहीं करेगा।

### इसे आज़माएं

आइए देखें कि हमारा इंस्टॉल चरण कैसे चला। सुरक्षित होने के लिए, सब कुछ दूर करने के लिए DevTools के एप्लिकेशन पैनल में __Clear साइट data__ बटन का उपयोग करें और सुनिश्चित करें कि हम नए सिरे से शुरू कर रहे हैं। यदि आपने पहले ऐप इंस्टॉल किया है, तो इसे अनइंस्टॉल करना सुनिश्चित करें, अन्यथा इंस्टॉल आइकन फिर से दिखाई नहीं देगा।

#### सत्यापित करें कि स्थापित बटन दिखाई दे रहा है

पहले, आइए हमारे इंस्टॉल आइकन को ठीक से सत्यापित करें कि यह डेस्कटॉप और मोबाइल दोनों पर आजमाया जाए।

1. Open the URL in a new Chrome tab.
2. Open Chrome's three-dot menu (next to the address bar).
▢ Verify you see "*Install Weather...*" in the menu.
3. Refresh the weather data using the refresh button in the upper right corner to ensure we meet the  [user engagement heuristics](/web/fundamentals/app-install-banners/#criteria).
▢ Verify the install icon is visible in the app header.

#### स्थापित बटन काम की जाँच करें

अगला, सुनिश्चित करें कि सब कुछ ठीक से स्थापित हो गया है, और हमारी घटनाओं को ठीक से निकाल दिया गया है। आप ऐसा डेस्कटॉप या मोबाइल पर भी कर सकते हैं। यदि आप मोबाइल पर इसका परीक्षण करना चाहते हैं, तो सुनिश्चित करें कि आप दूरस्थ डिबगिंग का उपयोग कर रहे हैं ताकि आप देख सकें कि कंसोल में क्या लॉग इन है।

1. क्रोम खोलें, और एक नए ब्राउज़र टैब में, अपने वेदर PWA में नेविगेट करें।
2. DevTools खोलें और कंसोल फलक पर जाएँ।
3. ऊपरी दाएं कोने में स्थापित बटन पर क्लिक करें। Disapp सत्यापित करें स्थापित बटन गायब हो जाता है
▢ सत्यापित करें कि स्थापित मोडल संवाद दिखाया गया है।
4. रद्द करें पर क्लिक करें।
▢ सत्यापित करें &quot;* उपयोगकर्ता ने A2HS प्रॉम्प्ट को खारिज कर दिया है&quot; कंसोल आउटपुट में दिखाया गया है। Rea इंस्टॉल बटन को फिर से देखें।
5. फिर से इंस्टॉल बटन पर क्लिक करें, फिर मोडल डायल में इंस्टॉल बटन पर क्लिक करें। * सत्यापित करें &quot;* उपयोगकर्ता ने A2HS प्रॉम्प्ट को स्वीकार किया है&quot; कंसोल आउटपुट में दिखाया गया है। Is सत्यापित करें &quot;* मौसम ऐप इंस्टॉल किया गया था *&quot; कंसोल आउटपुट में दिखाया गया है। Where वेरीफाई ऐप को उस स्थान पर जोड़ा जाता है जहाँ आप आमतौर पर ऐप पाते हैं।
6. मौसम PWA लॉन्च करें। App सत्यापित करें कि ऐप एक स्टैंडअलोन ऐप के रूप में खुलता है, या तो डेस्कटॉप पर ऐप विंडो में, या मोबाइल पर पूर्ण स्क्रीन।

ध्यान दें, यदि आप लोकलहोस्ट से डेस्कटॉप पर चल रहे हैं, तो आपका स्थापित PWA एक पता बैनर दिखा सकता है क्योंकि लोकलहोस्ट को एक सुरक्षित होस्ट नहीं माना जाता है।

#### सत्यापित करें कि iOS इंस्टॉलेशन ठीक से काम करता है

आइए iOS पर व्यवहार की भी जांच करें। यदि आपके पास एक आईओएस डिवाइस है, तो आप इसका उपयोग कर सकते हैं, या यदि आप मैक पर हैं, तो एक्सकोड के साथ उपलब्ध आईओएस सिम्युलेटर का प्रयास करें।

1. सफारी खोलें और एक नए ब्राउज़र टैब में, अपने मौसम PWA में नेविगेट करें।
2. * शेयर * पर क्लिक करें![8ac92dd483c689d3.png](img/8ac92dd483c689d3.png) बटन।
3. दाईं ओर स्क्रॉल करें और *होम स्क्रीन पर जोड़ें* बटन पर क्लिक करें। ▢ सत्यापित करें कि शीर्षक, URL और आइकन सही हैं।
4. &quot;जोड़ें&quot; पर क्लिक करें। the सत्यापित करें ऐप आइकन को होम स्क्रीन पर जोड़ा गया है। 5. होम स्क्रीन से वेदर पीडब्ल्यूए लॉन्च करें। App सत्यापित करें कि ऐप पूर्ण स्क्रीन लॉन्च करता है।

### बोनस: यह पता लगाना कि क्या आपका ऐप होम स्क्रीन से लॉन्च किया गया है

`display-mode` मीडिया क्वेरी, एप्लिकेशन को लॉन्च किए जाने के आधार पर शैलियों को लागू करना संभव बनाता है या यह निर्धारित करता है कि इसे जावास्क्रिप्ट के साथ कैसे लॉन्च किया गया था।

```css
@media all and (display-mode: standalone) {
  body {
    background-color: yellow;
  }
}
```

तुम भी जाँच कर सकते हैं `display-mode` में मीडिया क्वेरी [JavaScript to see if you're running in standalone](/web/fundamentals/app-install-banners/#detect-mode) ।

### बोनस: अपने PWA की स्थापना रद्द करें

याद रखें, यदि एप्लिकेशन पहले से इंस्टॉल है, तो `beforeinstallevent` आग नहीं `beforeinstallevent` है, इसलिए विकास के दौरान आप यह सुनिश्चित करना चाहते हैं कि सब कुछ अपेक्षित रूप से काम कर रहा है या नहीं, अपने ऐप को कई बार इंस्टॉल और अनइंस्टॉल करना होगा।

#### Android

एंड्रॉइड पर, PWA को उसी तरह से अनइंस्टॉल किया जाता है जिस तरह से अन्य इंस्टॉल किए गए ऐप्स को अनइंस्टॉल किया जाता है।

* ऐप ड्रॉर खोलें।
* मौसम आइकन खोजने के लिए नीचे स्क्रॉल करें।
* स्क्रीन के शीर्ष पर एप्लिकेशन आइकन खींचें।
* चुनें *स्थापना रद्द करें।*

#### ChromeOS

ChromeOS पर, PWA को आसानी से लॉन्चर खोज बॉक्स से अनइंस्टॉल किया जाता है।

* लॉन्चर खोलें।
* खोज बॉक्स में &quot;* मौसम *&quot; टाइप करें, आपका मौसम PWA परिणामों में दिखाई देना चाहिए।
* मौसम PWA पर राइट क्लिक (ऑल-क्लिक)
* क्रोम से *निकालें पर क्लिक करें ...*

#### और विंडोज

Mac और Windows पर, PWA को Chrome के माध्यम से अनइंस्टॉल किया जाना चाहिए।

* एक नए ब्राउज़र टैब में, क्रोम खोलें: // ऐप्स।
* मौसम PWA पर राइट क्लिक (ऑल-क्लिक)
* क्रोम से *निकालें पर क्लिक करें ...*

## बधाई

बधाई हो, आपने अपना पहला प्रगतिशील वेब ऐप सफलतापूर्वक बनाया है!

आपने इसे स्थापित करने में सक्षम करने के लिए एक वेब ऐप प्रकट किया, और आपने यह सुनिश्चित करने के लिए एक सेवा कार्यकर्ता जोड़ा कि आपका PWA हमेशा तेज और विश्वसनीय है। आपने सीखा कि किसी एप्लिकेशन को ऑडिट करने के लिए DevTools का उपयोग कैसे करें और यह आपके उपयोगकर्ता अनुभव को बेहतर बनाने में आपकी मदद कैसे कर सकता है।

अब आप किसी भी वेब ऐप को प्रोग्रेसिव वेब ऐप में बदलने के लिए आवश्यक प्रमुख चरणों को जानते हैं।

### अतिरिक्त पठन

* [High-performance service worker loading](/web/fundamentals/primers/service-workers/high-performance-loading)
* [Service Worker Caching Strategies Based on Request Types](https://medium.com/dev-channel/service-worker-caching-strategies-based-on-request-types-57411dd7652c)

### संदर्भ डॉक्स

* [Web App Manifest docs](/web/fundamentals/web-app-manifest)
* [Web App Manifest properties (MDN)](https://developer.mozilla.org/en-US/docs/Web/Manifest#Members)
* [Install & Add to Home Screen](/web/fundamentals/app-install-banners/)
* [Service Worker Overview](/web/fundamentals/primers/service-workers/)
* [Service Worker Lifecycle](/web/fundamentals/primers/service-workers/lifecycle)
* [High-performance service worker loading](/web/fundamentals/primers/service-workers/high-performance-loading)
* [Offline Cookbook](/web/fundamentals/instant-and-offline/offline-cookbook/#generic-fallback)

## एक मुद्दा मिला, या प्रतिक्रिया है? {: .hide-from-toc }

हमें एक जमा करके बेहतर हमारे कोड प्रयोगशालाओं बनाने में मदद करें [issue](https://github.com/googlecodelabs/your-first-pwapp/issues) आज। और धन्यवाद!

{% include "web/_shared/translation-end.html" %}
