project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml
description: Оптимизация невозможна без анализа данных. С помощью Navigation Timing API вы можете отследить каждый этап визуализации веб-страницы!

{# wf_updated_on: 2014-09-17 #}
{# wf_published_on: 2014-03-31 #}

# Отслеживание визуализации {: .page-title }

{% include "web/_shared/contributors/ilyagrigorik.html" %}


Оптимизация невозможна без анализа данных. С помощью Navigation Timing API вы можете отследить каждый этап визуализации веб-страницы!


### TL;DR {: .hide-from-toc }
- С помощью Navigation Timing API можно получать детальные временные отметки для анализа визуализации.
- Браузер делит визуализацию на несколько этапов, названия которых можно использовать для анализа.


Стратегия оптимизации строится на анализе времени загрузки страниц. Его удобно проводить с помощью Navigation Timing API.

<img src="images/dom-navtiming.png" class="center" alt="Этапы визуализации страницы">

При загрузке страницы браузер отслеживает время, затраченное на каждый отмеченный на диаграмме этап. Обратите внимание, что мы пока не учитываем сетевые этапы. К ним вы вернемся в одном из следующих уроков.

А пока давайте выясним, что означают эти названия на диаграмме.

* **domLoading**. Начальная отметка. В этот момент браузер начинает анализировать первые байты HTML-
  документа.
* **domInteractive**. В это время браузер завершил анализ документа и создал модель DOM.
* **domContentLoaded**. К этому моменту модели DOM и CSSOM уже готовы, поэтому ничто не мешает запуску скриптов JavaScript. Это значит, что браузер может приступать к созданию модели визуализации.
    * Если ваш фреймворк JavaScript запускается на этом этапе, вы можете отследить, как долго он выполняется, с помощью меток _EventStart_ и _EventEnd_.
* **domComplete**. К этому моменту обработка завершена, а контент страницы (например, изображения) полностью скачан. Индикатор загрузки перестает вращаться.
* **loadEvent**. Сигнал полного завершения загрузки. Его можно использовать в качестве триггера функций и скриптов, добавив в HTML-код событие `onload`.

В спецификации HTML подробно оговаривается, когда каждое событие должно быть инифиировано, при каких условиях и т. д. Для анализа визуализации нам потребуются только следующие события:

* **domInteractive**. Модель DOM готова.
* **domContentLoaded**. Модели [DOM и CSSOM](http://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/) готовы.
    * Если в HTML-документе нет встроенного кода JavaScript, событие _DOMContentLoaded_ инициируется сразу после _domInteractive_.
* **domComplete**. Страница готова, ее контент загружен.

^

<pre class="prettyprint">
{% includecode content_path="web/fundamentals/performance/critical-rendering-path/_code/measure_crp.html" region_tag="full"   adjust_indentation="auto" %}
</pre>

Этот код на первый взгляд может показаться пугающим, однако на самом деле все очень просто! Navigation Timing API записывает нужные временные отметки, дожидается инициации события `onload` (после завершения этапов domInteractive, domContentLoaded и domComplete) и вычисляет разницу во времени между отметками.
<img src="images/device-navtiming-small.png" class="center" alt="Результат анализа Navigation Timing API">

Теперь вы знаете, какие этапы визуализации нужно отслеживать и как вывести результаты на страницу. Кстати, вместо этого можно отправить данные на сервер ([в Google Analytics это происходит автоматически](https://support.google.com/analytics/answer/1205784)), немного изменив код. Так вы сможете отслеживать скорость загрузки и определять, какие страницы необходимо оптимизировать.



