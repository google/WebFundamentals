---
title: "Производительность визуализации"
description: "Пользователи заметят, если сайты и приложения работают плохо, поэтому оптимизация производительности визуализации имеет важнейшее значение!"
updated_on: 2015-03-20
notes:
  csstriggers:
    "Если вы желаете узнать, какие из приведенных выше трех вариантов вызовут изменение того или иного свойства CSS, читайте статью <a href='http://csstriggers.com'>Срабатывание событий при изменении CSS</a>. Если вы сразу хотите узнать, как создавать высокопроизводительную анимацию, прочитайте раздел об <a href='stick-to-compositor-only-properties-and-manage-layer-count'>изменении свойств, которые затрагивают только компоновку</a>."
  rasterize:
    "Иногда, когда речь идет о прорисовке, можно услышать термин 'растеризовать'. Связано это с тем, что прорисовка, по сути, состоит из двух операций: 1) создания списка команд draw call и 2) заполнения пикселей.

    Последняя операция называется 'растеризацией', поэтому, когда вы видите записи о прорисовке в DevTools, это означает, что также подразумевается и растеризация. (В некоторых вариантах архитектуры создание списка команд draw call и растеризация выполняются в разных потоках, однако разработчик не может этого контролировать.)"
udacity:
  id: ud860
  title: Оптимизация визуализации в браузере
  description: "Вам интересно поглубже познакомиться с оптимизацией визуализации? Запишитесь на соответствующий курс и узнайте, как браузер преобразует HTML, CSS и JavaScript в пиксели на экране, как пользоваться DevTools для оценки производительности, а также как оптимизировать визуализацию страниц"
  image: images/rp-udacity.jpg
---
<p class="intro">
  Сегодняшние интернет-пользователи <a href="http://paul.kinlan.me/what-news-readers-want/">хотят, чтобы открываемые ими страницы были интерактивными и работали плавно.</a> Именно этому и требуется уделять много времени и труда. Страницы должны не только быстро загружаться, но и работать хорошо: прокрутка должна быть быстрой, а анимация и взаимодействия – плавными
</p>

<img src="images/intro/response.jpg" class="center" alt="Пользователь, взаимодействующий с веб-сайтом.">

Длятого чтобы писать производительные сайты и приложения, необходимо понимать, каким образом браузер обрабатывает HTML, JavaScript и CSS. А уже на основе этих знаний необходимо предпринять усилия, чтобы ваш код (а также сторонний код, который вы используете) работал как можно эффективнее.

## 60 кадров в секунду и частота обновления экрана устройства

Сегодня большинство устройств обновляют свои экраны **60 раз в секунду**. Если выполняется анимация или переход либо если пользователь прокручивает страницы, браузеру нужно соответствовать частоте обновления экрана устройства и выдавать по одной новой картинке (или кадру) при каждом обновлении экрана.

Каждый из этих кадров может длиться чуть более 16 мс (1 секунда / 60 = 16,66 мс). В реальности же браузеру нужно выполнить и еще кое-какие действия, потому вся ваша работа должна занимать не более **10 мс**. Если не уложиться в эти рамки, частота кадров будет меньше, а контент начнет дергаться на экране. Часто эту ситуацию называют **подвисанием**, она отрицательно сказывается на восприятии пользователей.

## Конвейер пикселей
Есть пять основных областей, о которых следует знать и помнить при выполнении своей работы. Это те области, которые вы в наибольшей степени контролируете. Они являются ключевыми точками конвейера вывода пикселей на экран.

<img src="images/intro/frame-full.jpg" class="center" alt="Полный конвейер пикселей">

* **JavaScript**. Обычно JavaScript используется для выполнения работы, результатом которой будут визуальные изменения, будь то функция jQuery `animate`, сортировка набора данных или добавление DOM-элементов на страницу. Однако вызывать визуальное изменение можно не только с помощью JavaScript: Также часто используются анимация CSS, переходы и API-интерфейс веб-анимации.
* **Вычисление стилей**. В процессе вычисления стилей определяется, какие правила CSS к каким элементам применяются с учетом соответствующих селекторов, например: `.headline` или `.nav > .nav__item`. Отсюда, после того как правила определены, они применяются и вычисляются итоговые стили для каждого элемента.
* **Расчет макета**. Как только браузер будет знать, какие правила применяются к элементу, он может начать вычислять, сколько места он займет, и где он находится на экране. Модель макета для Интернета означает, что один элемент может влиять на другие, например: ширина элемента `<body>` обычно влияет на значения ширины дочерних элементов и так далее по всему дереву, поэтому этот процесс для браузера может быть довольно сложным.
* **Прорисовка**. Прорисовка – это процесс заполнения пикселей. Он подразумевает вывод текста, цветов, изображений, границ и теней, по сути – всех визуальных частей элементов. Прорисовка обычно выполняется на нескольких поверхностях, которые называются слоями.
* **Компоновка**. Поскольку части страницы потенциально были прорисованы на нескольких слоях, они должны быть выведены на экран в надлежащем порядке, с тем чтобы страница отображалась правильно. Это особенно важно для элементов, которые перекрывают другие элементы, поскольку ошибка может привести к тому, что один элемент будет неправильно показан поверх другого элемента.

Каждая из этих частей конвейера является потенциальным источником подвисания. Поэтому важно точно понимать, какие части конвейера срабатывают при выполнении вашего кода.

{% include shared/remember.liquid title="Note" list=page.notes.rasterize %}

Далеко не всегда каждый кадр затрагивает все части конвейера. На самом деле есть три варианта, в соответствии с которыми конвейер_обычно_ воспроизводится для данного кадра при внесении визуального изменения, – с помощью JavaScript, CSS или веб-анимации:

### 1. JS / CSS > Стиль > Расчет макета > Прорисовка > Компоновка

<img src="images/intro/frame-full.jpg" class="center" alt="Полный конвейер пикселей">

Если изменить свойство, относящееся к макету, например такое свойство геометрии элемента, как ширина, высота или положение относительно левого верхнего угла, браузеру придется проверить все остальные элементы и перерасчитать дерево отрисовки страницы. Все затронутые области необходимо будет прорисовать заново, а итоговые элементы нужно будет снова скомпоновать.

### 2. JS / CSS > Стиль > Прорисовка > Компоновка

<img src="images/intro/frame-no-layout.jpg" class="center" alt="Конвейер пикселей без перерасчета макета.">

Если изменить свойство, которое связано только с прорисовкой, например фоновое изображение, цвет текста или его тень, другими словами, свойство, которое не влияет на макет страницы, браузер оставит макет неизменным, но ему все равно придется выполнить прорисовку.

### 3. JS / CSS > Стиль > Компоновка

<img src="images/intro/frame-no-layout-paint.jpg" class="center" alt="Конвейер пикселей без перерасчета макета или прорисовки.">

Если же изменить свойство, которое не требует ни перерасчета макета, ни прорисовки, браузер сразу же перейдет к компоновке.

Последний вариант является самым простым и наиболее предпочтительным для точек высокой нагрузки в жизненном цикле приложения, например при анимации или прокрутке.

{% include shared/remember.liquid title="Note" list=page.notes.csstriggers %}

Производительность – это искусство избегать работы и делать любую работу как можно более эффективно. Во многих случаях это означает работу вместе с браузером, а не против него. Стоит помнить, что описанная выше работа в конвейере отличается по затратам вычислительных ресурсов: одни задачи являются более ресурсоемкими, чем другие!

Давайте разберемся с разными частями конвейера. Мы рассмотрим стандартные проблемы, а также методы их диагностики и устранения.

{% include fundamentals/udacity_course.liquid uid=page.udacity.id title=page.udacity.title image=page.udacity.image description=page.udacity.description %}

