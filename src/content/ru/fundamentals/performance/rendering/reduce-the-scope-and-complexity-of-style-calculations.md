project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml
description: Любые изменения DOM, будь то добавление или удаление элементов, изменение атрибутов, классов или использование средств анимации, ведут к тому, что браузер перерасчитывает стили элементов и во многих случаях макет всей страницы или ее частей. Этот процесс называется вычислением стилей

{# wf_updated_on: 2015-03-19 #}
{# wf_published_on: 2000-01-01 #}

# Ограничение объема и сложности вычисления стилей {: .page-title }

{% include "web/_shared/contributors/paullewis.html" %}


Любые изменения DOM, будь то добавление или удаление элементов, изменение атрибутов, классов или использование средств анимации, ведут к тому, что браузер перерасчитывает стили элементов и во многих случаях макет всей страницы или ее частей. Этот процесс называется <em>вычислением стилей</em>

### TL;DR {: .hide-from-toc }
- Снижайте сложность своих селекторов; используйте методологию, основанную на классах, например BEM.
- Сокращайте количество элементов, для которых требуется выполнять вычисление стилей.


Первая часть вычисления стилей заключается в создании набора соответствующих селекторов. По сути, в этом процессе браузер определяет, какие классы, псевдоселекторы и идентификаторы относятся к тому или иному элементу.

Вторая часть процесса состоит в получении всех правил стилей из соответствующих селекторов и определении стилей, которые в итоге имеет элемент. В Blink (движке визуализации Chrome и Opera) эти процессы на сегодня более или менее одинаковы по затратам:

<div class="quote" style="margin-top: 30px;">
  <div class="container">
    <blockquote>Приблизительно 50 % времени, которое тратится на вычисление стиля элемента, уходит на сопоставление селекторов, а вторую половину времени занимает построение RenderStyle (представления стиля) на основе сопоставленных правил.
    <p>Руне Лиллесвеен (Rune Lillesveen), Opera / <a href="https://docs.google.com/document/d/1vEW86DaeVs4uQzNFI5R-_xS9TcS1Cs_EUsHRSgCHGu8/edit">Аннулирование стилей в Blink</a></p>
    </blockquote>
  </div>
</div>


## Снижайте сложность своих селекторов

В самом простом случае вы ссылаетесь на элемент в своем CSS просто с помощью класса:


    .title {
      /* styles */
    }
    

Однако, по мере роста проекта, CSS, скорее всего, станет сложнее, и в конечном итоге селекторы могут выглядеть примерно следующим образом:


    .box:nth-last-child(-n+1) .title {
      /* styles */
    }
    

Для того чтобы знать, что стили нужно применить, бразер должен фактически спросить: "Это тот элемент с классом title, у которого есть родительский элемент, который является минус n плюс 1 дочерним элементом элемента с классом box?" В зависимости от используемого селектора и браузера на вычисление всего этого _может_ уйти масса времени. Вместо этого, необходимое поведение селектора можно преобразовать в класс:


    .final-box-title {
      /* styles */
    }
    

Возможны сложности с именем класса, однако работа для браузера теперь будет намного проще. В предыдущей версии, чтобы, например, узнать, что элемент является последним элементом данного типа, браузеру сначала необходимо узнать все обо всех остальных элементах, а так же о том, есть ли другие элементы, которые идут после него, которые являются n-ым последним дочерним элементом. Все это потенциально намного затратнее, чем просто сравнить селектор с элементом, поскольку у него такой же класс.

## Сокращайте количество элементов, которым заданы стили
Другим соображением в отношении производительности, который обычно бывает _более важным фактором во многих ситуациях, связанных с обновлением стилей_, является общий объем работы, которую необходимо проделать, когда элемент изменяется.

В целом, в самом худшем варианте затратность вычисления стилей элементов определяется количеством элементов, умноженным на число селекторов, поскольку каждый элемент необходимо хотя бы сравнить с каждым стилем, чтобы понять, совпадает ли он.

Note: Когда-то, если вы меняли класс, скажем, для элемента body, необходимо было повторно вычислять стили всех дочерних элементов на странице. К счастью, сегодня все не так. Сейчас некоторые браузеры формируют небольшой набор правил, которые являются уникальными для каждого элемента, и в случае их изменения перерасчитываются только стили этого элемента. Это означает, что необходимость в перерасчете элемента зависит от его места в дереве, а также того, что именно было изменено

Обычно можно напрямую ограничить вычисление стилей несколькими элементами, а не пересматривать всю страницу целиком. В современных браузерах это представляет все меньшую проблему, поскольку браузеру не обязательно нужно проверять все элементы, которые потенциально может затронуть изменение. С другой стороны, старые браузеры не всегда оптимизированы для подобных задач. Где следует **сокращать количество пересчитываемых элементов**.

Note: Если вы занимаетесь веб-компонентами, то стоит отметить, что в этой области вычисление стилей выполняется несколько иначе, поскольку по умолчанию стили не переходят границу теневого дерева DOM и ограничены отдельными компонентами, а не всем деревом. В целом же концепция одинакова: небольшие деревья с простыми правилами обрабатываются более эффективно, чем большие деревья со сложными правилами

## Оценивайте затраты на перерасчет стилей
Проще и лучше всего оценить затраты на перерасчет стилей можно с помощью шкалы времени в программе Chrome DevTools. Для начала откройте DevTools, перейдите на вкладку Timeline, запустите запись и начните взаимодействовать со своим сайтом. После того как запись будет остановлена, программа выдаст экран, похожий на приведенный далее:

<img src="images/reduce-the-scope-and-complexity-of-style-calculations/long-running-style.jpg"  alt="Программа DevTools, информирующая о длительном вычислении стилей.">

Полоса вверху обозначает количество кадров в секунду. Если вы видите, что столбцы уходят выше нижней линии (60 кадров в секунду), значит, у вас есть длительные кадры.

<img src="images/reduce-the-scope-and-complexity-of-style-calculations/frame-selection.jpg"  alt="Проблемная область, выделенная в Chrome DevTools.">

При наличии длительных кадров в моменты, когда пользователь выполняет такие действия, как прокрутка или др., необходимо провести тщательный анализ.

Если же есть большой фиолетовый блок (как на приведенном выше примере), щелкните запись, и программа выдаст более подробные сведения.

<img src="images/reduce-the-scope-and-complexity-of-style-calculations/style-details.jpg"  alt="Получение подробных сведений о длительных вычислениях стилей.">

В данном случае у нас имеется длительное событие перерасчета стилей, которое занимает чуть более 18 мс и происходит во время прокрутки, из-за чего пользователь наблюдает значительное дрожание изображения.

Если щелкнуть само событие, программа выдаст стек вызовов, в котором будет выделено место в коде JavaScript, которое отвечает за инициирование изменения стиля. Помимо этого, вы получите количество элементов, которые были затронуты изменением (в данном случае их чуть больше 400), а также время, которое потребовалось на выполнение вычисления стилей. Эта информация позволяет начать поиск соответствующих мест в своем коде и их исправление.

## Используйте блок, элемент, модификатор
Такие подходы к программированию, как [BEM (Block, Element, Modifier – блок, элемент, модификатор)](https://bem.info/){: .external }, фактически основаны на описанной выше работе по сопоставлению селекторов, поскольку в них рекомендуется, чтобы у всех элементов был один класс, а когда требуется иерархия, она также должна основываться на имени этого класса:


    .list { }
    .list__list-item { }
    

Если вам необходим определенный модификатор, как в приведенном выше примере, когда нам требовалось сделать нечто особенное с последним потомком, его можно добавить вот так:


    .list__list-item--last-child {}
    

Если вы ищете хороший способ организации своего кода CSS, BEM – это действительно неплохая отправная точка, как с точки зрения структуры, так в силу упрощения определения стилей.

Если BEM вам не нравится, есть другие варианты организации CSS. Однако, помимо эргономики подхода, следует оценивать и вопросы производительности.

## Ресурсы

* [Аннулирование стилей в Blink](https://docs.google.com/document/d/1vEW86DaeVs4uQzNFI5R-_xS9TcS1Cs_EUsHRSgCHGu8/edit)
* [BEM (Block, Element, Modifier – блок, элемент, модификатор)](https://bem.info/){: .external }


