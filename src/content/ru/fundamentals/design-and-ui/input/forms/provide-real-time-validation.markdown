---
title: "Обеспечение проверки в реальном времени"
description: "Проверка данных в реальном времени помогает не только обеспечить их точность, но также улучшить восприятие пользователей.  Современные браузеры имеют несколько встроенных средств, позволяющих обеспечить проверку данных в реальном времени. Кроме того, они могут не позволить пользователю отправить форму с некорректными сведениями.  Необходимо использовать визуальные подсказки, которые укажут, правильно ли заполнена форма"
updated_on: 2014-10-21
key-takeaways:
  provide-real-time-validation:
    - "Используйте встроенные в браузеры атрибуты проверки, например <code>pattern</code>, <code>required</code>, <code>min</code>, <code>max</code> и т. д."
    - "При необходимости более сложных вариантов проверки используйте JavaScript и API-интерфейс проверки ограничений."
    - "Отображайте ошибки, выявленные при проверке, в реальном времени, а если пользователь пытается отправить неправильно заполненную форму, показывайте все поля, которые ему необходимо исправить."
notes:
  use-placeholders:
    - "Заполнители исчезают сразу после перевода фокуса на элемент, поэтому они не являются заменой обозначений.  Их следует использовать как вспомогательное средство, чтобы помочь пользователю выбрать требуемый формат или контент."
  recommend-input:
    - "Автозаполнение работает только в том случае, если в форме используется метод post."
  use-datalist:
    - "Значения <code>datalist</code> выдаются в качестве подсказки, пользователи при этом не ограничены предоставленными подсказками."
  provide-real-time-validation:
    - "Даже при наличии проверки ввода на стороне клиента всегда важно проверять данные на сервере для обеспечения их согласованности и безопасности."
  show-all-errors:
    - "Пользователю сразу же следует показывать все имеющиеся в форме неполадки, а не по одной за раз."
  request-auto-complete-flow:
    - "Если запрашиваются какая-либо личная информация или данные кредитной карты, страница должна выдаваться через SSL.  В противном случае в диалоговом окне должно выдаваться сообщение, предупреждающее пользователя о том, что его информация не защищена."
comments:
  # ПРИМЕЧАНИЕ. Если изменяется заголовок или URL-адрес раздела, необходимо обновить ссылки
  - g.co/mobilesiteprinciple17b
---

<p class="intro">
  Проверка данных в реальном времени помогает не только обеспечить их точность, но также улучшить восприятие пользователей.  Современные браузеры имеют несколько встроенных средств, позволяющих обеспечить проверку данных в реальном времени. Кроме того, они могут не позволить пользователю отправить форму с некорректными сведениями.  Необходимо использовать визуальные подсказки, которые укажут, правильно ли заполнена форма
</p>


{% include shared/takeaway.liquid list=page.key-takeaways.provide-real-time-validation %}

### Используйте следующие атрибуты для проверки ввода

#### Атрибут `pattern`

Атрибут `pattern` задает [регулярное
выражение](http://en.wikipedia.org/wiki/Regular_expression), используемое для проверки 
поля ввода. Например, чтобы проверить почтовый индекс США (5 цифр, за которыми иногда
следует дефис и еще четыре цифры), атрибут`pattern` необходимо задать
следующим образом:

{% highlight html %}
<input type="text" pattern="^\d{5,6}(?:[-\s]\d{4})?$" ...>
{% endhighlight %}

##### Стандартные шаблоны регулярных выражений

<table class="mdl-data-table mdl-js-data-table">
  <thead>
    <tr>
      <th data-th="Description">Описание</th>
      <th data-th="Regular expression">Регулярное выражение</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td data-th="Description">Почтовый адрес</td>
      <td data-th="Regular expression"><code>[a-zA-Z\d\s\-\,\#\.\+]+</code></td>
    </tr>
    <tr>
      <td data-th="Description">Почтовый индекс (США)</td>
      <td data-th="Regular expression"><code>^\d{5,6}(?:[-\s]\d{4})?$</code></td>
    </tr>
    <tr>
      <td data-th="Description">IP-адрес (IPv4)</td>
      <td data-th="Regular expression"><code>^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</code></td>
    </tr>
    
<tr>
      <td data-th="Description">IP-адрес (IPv6)</td>
      <td data-th="Regular expression"><code>^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$</code></td>
    </tr>
    
<tr>
      <td data-th="Description">IP-адрес (оба)</td>
      <td data-th="Regular expression"><code>^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$</code></td>
    </tr>
    
    <tr>
      <td data-th="Description">Номер кредитной карты</td>
      <td data-th="Regular expression"><code>^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\d{3})\d{11})$</code></td>
    </tr>
    <tr>
      <td data-th="Description">Номер социального страхования</td>
      <td data-th="Regular expression"><code>^\d{3}-\d{2}-\d{4}$</code></td>
    </tr>
    <tr>
      <td data-th="Description">Номер телефона в Северной Америке</td>
      <td data-th="Regular expression"><code>^(?:(?:\+?1\s*(?:[.-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$</code></td>
    </tr>
  </tbody>
</table>

#### Атрибут `required`

Если задан атрибут `required`, то, чтобы получить возможность отправить форму, в поле, снабженном этим атрибутом,
должно быть указано значение. Например, чтобы сделать поле почтового индекса обязательным для заполнения, нужно
просто добавить атрибут required:

{% highlight html %}
<input type="text" required pattern="^\d{5,6}(?:[-\s]\d{4})?$" ...>
{% endhighlight %}

#### Атрибуты `min`, `max` и `step`

Для ввода численной информации, такой как номер, диапазон, дата или время, можно
указать минимальное и максимальное значения, а также шаг их
изменения при регулировке с помощью ползунка или наборного счетчика.  Например, 
для поля ввода размера обуви задается минимальный размер 1 и максимальный размер 13 с шагом изменения
0,5

{% highlight html %}
<input type="number" min="1" max="13" step="0.5" ...>
{% endhighlight %}

#### Атрибут `maxlength`

С помощью атрибута `maxlength` можно задавать максимальную длину вводимого значения или
текстового поля. Он полезен, когда требуется ограничить длину информации, которую
может указать пользователь. Например, если длину имени файла требуется ограничить 12 символами,
это можно сделать следующим образом.

{% highlight html %}
<input type="text" id="83filename" maxlength="12" ...>
{% endhighlight %}

#### Атрибут `minlength`

С помощью атрибута `minlength` можно задавать минимальную длину вводимого значения или
текстового поля. Он полезен, когда требуется указать минимальную длину информации, которую
должен предоставить пользователь. Например, если требуется указать, что имя файла должно состоять минимум из
8 символов, это можно сделать следующим образом.

{% highlight html %}
<input type="text" id="83filename" minlength="8" ...>
{% endhighlight %}

#### Атрибут `novalidate`

В некоторых случаях можно позволить пользователю отправить форму, даже если
она содержит ошибки. Для этого добавьте в элемент
формы или отдельные поля ввода атрибут `novalidate`. В этом случае все псевдоклассы и
API-интерфейсы JavaScript все равно позволят вам проверять правильность заполнения формы.

{% highlight html %}
<form role="form" novalidate>
  <label for="inpEmail">Email address</label>
  <input type="email" ...>
</form>
{% endhighlight %}

{% include shared/remember.liquid title="Remember" list=page.notes.provide-real-time-validation %}

### Для более сложной проверки в реальном времени используйте JavaScript

Когда встроенной проверки и регулярных выражений недостаточно, можно использовать 
[API-интерфейс проверки ограничений](http://dev.w3.org/html5/spec-preview/constraints.html#constraint-validation) –
мощное средство для выполнения нестандартной проверки.  С помощью этого API-интерфейса можно, например,
задать нетипичную ошибочную ситуацию, проверить корректность элемента и определить
причину, по которой данный элемент является некорректным:

<table class="mdl-data-table mdl-js-data-table">
  <thead>
    <tr>
      <th data-th="API">API-интерфейс</th>
      <th data-th="Description">Описание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td data-th="API"><code>setCustomValidity()</code></td>
      <td data-th="Description">Задает нестандартное сообщение о результатах проверки, а свойству <code>customError</code> объекта <code>ValidityState</code> присваивает значение <code>true</code>.</td>
    </tr>
    <tr>
      <td data-th="API"><code>validationMessage</code></td>
      <td data-th="Description">Возвращает строку с указанием причины, по которой поле не прошло проверку.</td>
    </tr>
    <tr>
      <td data-th="API"><code>checkValidity()</code></td>
      <td data-th="Description">Возвращает значение <code>true</code>, если элемент прошел проверку по всем ограничениям. В противном случае возвращается значение <code>false</code>. Определение реакции страницы на ситуацию, когда проверка возвращает значение <code>false</code>, остается за разработчиком.</td>
    </tr>
    <tr>
      <td data-th="API"><code>reportValidity()</code></td>
      <td data-th="Description">Возвращает значение <code>true</code>, если элемент прошел проверку по всем ограничениям. В противном случае возвращается значение <code>false</code>. Когда страница возвращает значение <code>false</code>, о нарушении ограничения сообщается пользователю.</td>
    </tr>
    <tr>
      <td data-th="API"><code>validity</code></td>
      <td data-th="Description">Возвращает объект <code>ValidityState</code>, представляющий состояния корректности элемента.</td>
    </tr>
  </tbody>
</table>

#### Задавайте нестандартные сообщения о результатах проверки

Если поле не проходит проверку, обозначьте его как некорректное с помощью `setCustomValidity()`
и поясните, в чем заключается ошибка.  Например, при заполнении регистрационной формы
пользователю может быть предложено для подтверждения его адреса электронной почты ввести его дважды.  Используйте событие
blur после ввода данных во втором поле, чтобы проверить правильность указанных данных и выдать соответствующий
ответ.  Например:

{% include_code src=_code/order.html snippet=customvalidation lang=javascript %}

#### Не позволяйте отправлять формы с ошибками

Поскольку некоторые браузеры позволяют пользователю отправлять формы, даже если в них есть
некорректные данные, необходимо отслеживать событие отправки и с помощью `checkValidity()`
в элементе формы определять ее корректность.  Например:

{% include_code src=_code/order.html snippet=preventsubmission lang=javascript %}

### Отображайте ответ в реальном времени

Полезно снабдить каждое поле визуальной подсказкой,
с тем чтобы пользователь еще перед отправкой формы видел, правильно ли он заполнил данное поле.
В HTML5 также появилось несколько псевдоклассов, с помощью которых поля ввода можно
оформлять в соответствии с их значениями или атрибутами.

<table class="mdl-data-table mdl-js-data-table">
  <thead>
    <tr>
      <th data-th="Pseudo-class">Пвевдокласс</th>
      <th data-th="Use">Использование</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td data-th="Pseudo-class"><code>:valid</code></td>
      <td data-th="Use">В явном виде задает стиль, который будет использоваться для поля ввода, когда указанное в нем значение соответствует всем требованиям проверки.</td>
    </tr>
    <tr>
      <td data-th="Pseudo-class"><code>:invalid</code></td>
      <td data-th="Use">В явном виде задает стиль, который будет использоваться для поля ввода, когда указанное в нем значение не соответствует всем требованиям проверки.</td>
    </tr>
    <tr>
      <td data-th="Pseudo-class"><code>:required</code></td>
      <td data-th="Use">В явном виде задает стиль элемента ввода, для которого задан атрибут required.</td>
    </tr>
    <tr>
      <td data-th="Pseudo-class"><code>:optional</code></td>
      <td data-th="Use">В явном виде задает стиль элемента ввода, для которого не задан атрибут required.</td>
    </tr>
    <tr>
      <td data-th="Pseudo-class"><code>:in-range</code></td>
      <td data-th="Use">В явном виде задает стиль элемента ввода числа, значение которого находится в пределах диапазона.</td>
    </tr>
    <tr>
      <td data-th="Pseudo-class"><code>:out-of-range</code></td>
      <td data-th="Use">В явном виде задает стиль элемента ввода числа, значение которого находится вне диапазона.</td>
    </tr>
  </tbody>
</table>

Проверка выполняется мгновенно, а это означает, что, когда страница загружается, поля
могут быть обозначены как некорректные, даже если пользователь еще не приступал к их
заполнению.  Это также означает, что, пока пользователь не закончил вводить информацию, для оформления поля может использоваться
стиль, предназначенный для полей с ошибочными данными и указывающий на то, что введено неверное значение. Во избежание таких ситуаций можно с помощью CSS и
JavaScript сделать так, чтобы стиль, указывающий на ошибку, использовался только после того, как пользователь перешел в другое поле.

{% include_code src=_code/order.html snippet=invalidstyle lang=css %}
{% include_code src=_code/order.html snippet=initinputs lang=javascript %}

{% include shared/remember.liquid title="Important" list=page.remember.show-all-errors %}


