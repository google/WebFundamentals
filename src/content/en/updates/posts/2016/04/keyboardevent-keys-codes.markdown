---
layout: updates/post
title: "What’s New with KeyboardEvents? Keys and Codes!"
description: "Two new attributes bring consistent keyboard event handling to the web."
published_on: 2016-04-19
updated_on: 2016-04-19
authors:
  - jeffposnick
tags:
  - uievents
  - input
  - chrome51
featured_image: /web/updates/images/2016/04/keyboardevent-keys-codes/ic_keyboard_black.png
---

The past few versions of Chrome have seen two additions to [`KeyboardEvent`s](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent), which are used as a parameter passed to [`keydown`](https://developer.mozilla.org/en-US/docs/Web/Events/keydown), [`keypress`](https://developer.mozilla.org/en-US/docs/Web/Events/keypress), and [`keyup`](https://developer.mozilla.org/en-US/docs/Web/Events/keyup) event listeners. Both the [`code`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) attribute (added in [Chrome 48](https://www.chromestatus.com/feature/5228092293382144)) and the [`key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) attribute (added in [Chrome 51](https://www.chromestatus.com/feature/4748790720364544)) give developers a straightforward way to get information that would otherwise be [difficult](https://github.com/inexorabletash/polyfill/blob/master/keyboard.md#legacy-key-events) using legacy attributes.

## The code Attribute
First up is the `code` attribute. This is set to a [string](https://w3c.github.io/uievents-code/#code-value-tables) representing the key that was pressed to generate the `KeyboardEvent`, _without_ taking the current keyboard layout (e.g., [QWERTY](https://en.wikipedia.org/wiki/QWERTY) vs. [Dvorak](https://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard)), locale (e.g., English vs. French), or any modifier keys into account.
This is useful when you care about which _physical_ key was pressed, rather thanwhich character it corresponds to. For example, if you’re a writing a game, you might want a certain set of keys to move the player in different directions, and that mapping should ideally be independent of keyboard layout.

## The key Attribute
Next, we have the new `key` attribute. It’s also set to a [string](https://w3c.github.io/uievents-key/), but while `code` returns information about the physical key that was pressed, `key` contains the character that is generated by that key, taking into account the current keyboard layout, locale and modifier keys.
Looking at the `key` attribute’s value comes in handy when you need to know what character would be displayed on the screen as if the user had typed into a text input.

## What’s This Mean in Practice?
To give a concrete example, let’s assume your user is using a U.S. keyboard with a QWERTY keyboard layout. Pressing the physical `Q` key on that keyboard will result in a `KeyboardEvent` with a `code` attribute set to `"KeyQ"`. This is true regardless of keyboard layout, and regardless of any other modifier keys. For comparison, on a French ([AZERTY](https://en.wikipedia.org/wiki/AZERTY)) keyboard this key would still have a `code` of `"KeyQ"` even though the letter printed on the keycap is an "a".
Pressing the physical `Q` key on that same U.S. keyboard will typically generate a `KeyboardEvent` with `key` set to `"q"` (with no modifier keys), or `"Q"` (with Shift or CapsLock), or `"œ"` (on OS X, with Alt). On a French AZERTY keyboard, this same key would generate an "a" (or "A" with Shift or CapsLock). And for other keyboard layouts, the `key` value could be `"й"`, `"ض"`, `"ㅂ"`, `"た"`, or some other character.
Revisiting our game example from earlier, if you want your game to use the WASD keys for movement, you can use the `code` attribute and check for `"KeyW"`, `"KeyA"`, `"KeyS"` and `"KeyD"`. This will work for all keyboards and all layouts—even AZERTY keyboards that swap the position of the "w" and "z" keys.

## Virtual Keyboards
You’ll notice that up until now, we’ve been focusing on the behavior assuming a physical keyboard. What about users who are typing on a virtual keyboard or an alternative input device? [The specification](https://w3c.github.io/uievents/#code-virtual-keyboards) offers official guidance for the `code` attribute. To summarize, a virtual keyboard that mimics the layout of a standard keyboard is expected to result in an appropriate `code` attribute being set, but virtual keyboards that adopt non-traditional layouts may result in `code` not being set at all.

Things are more straightforward for the `key` attribute, which you should expect to be set to a string based on which character the user (virtually) typed.

## Try it Out
Gary Kačmarčík has put together a [fantastic demo](https://w3c.github.io/uievents/tools/key-event-viewer.html) for visualizing all the attributes associated with `KeyboardEvent`s:

<img src="/web/updates/images/2016/04/keyboardevent-keys-codes/screenshot.png">

## Cross-Browser Support
Support for the [`code`](http://caniuse.com/#feat=keyboardevent-code) attribute is, as of this writing, limited to Chrome 48+, Opera 35+, and Firefox 44+.
The [`key`](http://caniuse.com/#feat=keyboardevent-key) attribute is supported in Firefox 44+, Chrome 51+, and Opera 38+, with [partial support](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key#Browser_compatibility) in Internet Explorer 9+ and Edge 13+.
