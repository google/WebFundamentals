---
layout: shared/narrow
title: "Preparing messages"
description: ""
published_on: 2016-08-05
updated_on: 2016-08-05
order: 25
translation_priority: 0
authors:
  - josephmedley
notes:
  octets: "In many of the relevant specs bytes are called octets. The term is used because of legacy and communication systems where bytes may not always be 8 bits long."
---

<p class="intro">
Construct an Authorization header. Send a message using the Authorization header to the enpoing provided by the subscription object.
 </p>

{% include shared/toc.liquid %}

## Anatomy of a subscription object {#subscription-anatomy}

In [the last section](permissions-subscriptions#passing-subscription) we said that a subscription object must be stringified and
passed to the server, but we didn't tell you what was in the subscription object. That's because the client doesn't do anything with it. The server does.

The subscription object looks like this:

{% highlight json %}
{
  "endpoint": "https://example.com/push-service/send/dbDqU8xX10w:APA91b...",
  "keys": {
    "auth": "qLAYRzG9TnUwbprns6H2Ew==",
    "p256dh": "BILXd-c1-zuEQYXH\_tc3qmLq52cggfqqTr\_ZclwqYl6A7-RX2J0NG3icsw..."
  }
}
{% endhighlight %}

What's in this?

_endpoint_—Contains two parts: the URL of the messaging service you're using
followed by unique identifier for the user. This is called a subscription ID or
a registration ID. This tells your server how to identify you the messaging
server.

_keys_—Encryption keys used for encrypting data passed to the service worker
messages. It contains the following:

* _auth_-A 16 byte authentication secret generated by the browser. 
* _p256dh_A 65 byte containing the `vapidPublicKey` created on the server.

{% include shared/note.liquid list=page.notes.octets %}

## Constructiong the Authorization header {#authorization-header}

The Authorization header consists of four parts.

    Bearer <JWTHeader>.<Payload>.<Signature>

The word `Bearer` is a litteral that must be followed by a space. The remaining portions, which are encrypted and concatenated using a period are a signed JSON web token (JWT). A JWT is a way of sharing a JSON object with a second party in such a way that the sending party can sign it and the receiving party can verify the signature is from the expected sender. Adding the literal `Bearer` to the front makes it a bearer token.

You must encrypt all messages before sending them. Encryption is enough of a
specialty, even within software development, that we don't recommend writing
your own encryption system. Fortunately, there are [a range of push
libraries](https://github.com/web-push-libs) including our own [Push Encryption
Library](https://github.com/GoogleChrome/web-push-encryption).

Let's look at each part of the bearer token in detail.


### JWT Header {#jwtheader}

The JWT Header contains two standard pieces of information: a `typ` property to indicate that this is a JWT message, and an `alg` header to indicate the algorithm used for encrypting the rest of the message. For VAPID, the later must be base64 url encoded.

{% highlight json %}
{
	"typ": "JWT",
	"alg": "ES256"
}
{% endhighlight %}

### Payload {#payload}

The payload is another JSON object with the following members:

**`aud`**

This contains the push service endpoint, which you should extract from the subscription object. This is **not** the origin of your site.

**`exp`**

Specifies the time the request expires in miliseconds. It must be within twenty-four hours. This can be calculated by converting the current date to milliseconds and adding the duration. For example, in Node.js you could do this:

    Math.floor((Date.now() / 1000) + 12 * 60 * 60)

**`sub`**

Specifices a subject, which the VAPID spec defines as a way for the push service to contact a message sender. This can be a URL or a mail to URL.

A complete payload looks like this:

{% highlight json %}
{
	"aud": "http://push-service.example.com",
	"exp": "1469618703",
	"sub": "mailto: my-email@some-url.com"
}
{% endhighlight %}

### Signature {#signature}

Create the signature by first concatenating the JWT header and the payload with
a dot, the encrypting the private key [you created earlier](permissions-
subscriptions#applicationserverkey). We're not going to show you how to do this,
but there are a number of ecryption libraries available. The result will look
something like the following:


    Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJhdWQiOiJodHRwczovL2ZjbS5nb29n
    bGVhcGlzLmNvbSIsImV4cCI6MTQ2NjY2ODU5NCwic3ViIjoibWFpbHRvOnNpbXBsZS1wdXNoLWRl
    bW9AZ2F1bnRmYWNlLmNvLnVrIn0.Ec0VR8dtf5qb8Fb5Wk91br-evfho9sZT6jBRuQwxVMFyK5S8
    bhOjk8kuxvilLqTBmDXJM5l3uVrVOQirSsjq0A

## Crypto-Key header {#crypto-key-header}

The second header to add to your message is Crypto-Key header. It has several
parts.

`dh=`_applicationServerKey_`;p256ecdsa=`_publicKey_

For example:

    dh=BGEw2wsHgLwzerjvnMTkbKrFRxdmwJ5S_k7zi7A1coR_sVjHmGrlvzYpAT1n4NPbioFlQkIrT
    NL8EH4V3ZZ4vJE,p256ecdsa=BDd3_hVL9fZi9Ybo2UUzA284WG5FZR30_95YeZJsiApwXKpNcF1
    rRPF3foIiBHXRdJI2Qhumhf6_LFTeZaN

The first parg (`dh=`_applicationServerKey_) is the public key, the one we created under [Requesting permission and subscribing users](permissions-subscriptions) and used in the last section to create the bearer token. The second part (p256ecdsa=`_publicKey_) is the public key, but base64 url encoded. Notice the comma separating the two parts of the crypto-key.

Note: A bug in Chrome 52 requires that a semicolon be send to the message server in the Crypto-Key header instead of a comma.
