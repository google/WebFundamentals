---
layout: shared/narrow
title: "Sending messages"
description: "There are two servers involved in sending a message: your server and a third party messaging server. You keep track of who to send messages to. The third party server handles the routing."
published_on: 2016-07-01
updated_on: 2016-08-05
order: 30
translation_priority: 0
authors:
  - josephmedley
---

<p class="intro">
It's easy to assume that sending messages must involve building a complex 
messaging system on the server. That's not quite right. There are actually two 
servers involved in sending a message: your server and a third party messaging 
server. You keep track of two things: recipients and recipient-specific 
endpoints on the messaging server. The messaging server handles the routing.
</p>

{% include shared/toc.liquid %}

## The broader context

We've seen how to subscribe to push within a web application. That process included capturing a public key, called the `applicationServerKey` in the subscription API.  

The following diagram shows the order of operations.

![Sending a message](images/push-flow.gif)

1. A device downloads your web app containing an already created publicKey, referred to in scripts as the `applicationServerKey`. Your web app installs a service worker.
1. During the subscription flow the browser posts a request to the messaging server to create a new subscription.

   Note: You don't need to know the URL of the message server. Each browser vender manages it's own message server for its browser.

1. The messaging server returns 201 to indicate that the subscription was successful.
1. After processing the subscription flow, your app passes a subscription object back to your app server. 
1. At some later point, your app server sends a message to the messaging server.

## Generating the applicationServerKey

There are several things you need to know about the `applicationServerKey`:

* It's the public key portion of a public/private key pair generated on your application server.
* The key pair should be usable with an elliptic curve digital signature (ECDSA) over the P-256 curve.
* Your app should pass key to the server as an array of eight-bit unsigned integers.
* It's required by a spec called Voluntary Application Server Identification for Web Push (VAPID), which we'll discuss in the [sending messages](sending-messages) section. 

You can find an example for generating this in the [web-push node library](https://github.com/web-push-libs/web-push/). It looks something like this:

{% highlight javascript %}
function generateVAPIDKeys() {
  var curve = crypto.createECDH('prime256v1');
  curve.generateKeys();

  return {
    publicKey: curve.getPublicKey(),
    privateKey: curve.getPrivateKey(),
  };
}
{% endhighlight %}

## Anatomy of a subscription object

Earlier we said that a subscription object must be stringified and passed to the 
server, but we didn't tell you what was in the subscription object. That's 
because the client doesn't do anything with it. The server does.  
  
The subscription object looks like this:  

{% highlight javascript %}
{  
  "endpoint": "https://example.com/push-service/send/dbDqU8xX10w:APA91b...",  
  "keys": {  
    "auth": "qLAYRzG9TnUwbprns6H2Ew==",  
    "p256dh": 
"BILXd-c1-zuEQYXH\\_tc3qmLq52cggfqqTr\\_ZclwqYl6A7-RX2J0NG3icsw..."  
  }  
}
{% endhighlight %}

What's in this?  
  
**endpoint**—Contains two parts: the URL of the messaging service used by the
subscribing browser followed by unique identifier for the user. This is called a
subscription ID or  a registration ID. This tells your server how to identify
you the messaging  server.
  
**keys**—Encryption keys used for encrypting data passed to the service worker 
messages. It contains the following:

* **auth**-A 16 byte authentication secret generated by the browser.
* **p256dh**-A 65 byte containing the vapidPublicKey created on your app server.

**Note:** In many of the relevant specs bytes are called octets. The term is 
used because of legacy and communication systems where bytes may not always be 8 
bits long.

## Creating the message

This is where things start to get a little crazy. In this section we're no 
longer in your client app. We're on the app server where we are going to create 
and send a message to the client. There's much to keep track of. 

Before continuing, let's review what we have and where it came from.

* **Subscription object** - his came from the client. It contains the endpoint 
  of the messaging server, a copy of the public key (`applicationServerKey`), and an authentication 
  secret generated by the client. From here on, we're going to stop talking 
  about the subscription object and only refer to the **endpoint**, **public 
  key**, and **authentication secret**.
* **private key** - The private key corresponding to the public key. This is the private key you created in 'Generating the applicationServerKey'.

We're going to look at message creation in three parts. First we'll create some 
HTTP headers, then we'll create a payload for the message, and finally we'll 
combine them and send them to the messaging server.

### A note about code samples

The code samples given in this section, which are taken from the [web-push node 
library](https://github.com/web-push-libs/web-push) are not ready to use as code 
samples frequently and ideally should be. Given the complexity of this subject, 
we felt it was better to describe it at a conceptual level and restrict sample 
codes to snipits that illustrate those concepts.

### The product

Let's look at what we're going to end up with, then we'll talk about how to 
build it. 

<pre>POST /push-service/send/dbDqU8xX10w:APA91b... HTTP/1.1  
Host: push.example.net  
Push-Receipt: https://push.example.net/r/3ZtI4YVNBnUUZhuoChl6omU  
TTL: 43200  
Content-Type: text/plain;charset=utf8  
Content-Length: 36  
Authorization: Bearer 
eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJhdWQiOiJodHRwczovL3B1c2guZXhhbXBsZS5uZXQiLCJleHAiOjE0NTM1MjM3NjgsInN1YiI6Im1haWx0bzpwdXNoQGV4YW1wbGUuY29tIn0.i3CYb7t4xfxCDquptFOepC9GAu\_HLGkMlMuCGSK2rpiUfnK9ojFwDXb1JrErtmysazNjjvW2L9OkSSHzvoD1oA  
Crypto-Key: 
p256ecdsa=BA1Hxzyi1RUM1b5wjxsn7nGxAszw2u61m164i3MrAIxHF6YK5h4SDYic-dRuU\_RCPCfA5aq9ojSwk5Y2EmClBPsiChYuI3jMzt3ir20P8r\_jgRR-dSuN182x7iB</pre>

It should be fairly obvious how the endpoint of the subscription object is used. 
The Authorization, Crypto-Key , and TTL headers take a little explanation. Let's 
start with the simplest.

## HTTP headers

### TTL

It may be some time before a message server can deliver a message sent by your 
app server. Message services aren't obligated to hold a message forever. 
Frankly, to be timely, an app server should never send a message that can live 
forever. That's why it's required to include a header called TTL, literally 
'time to live'.

The TTL header is a a value in seconds given as a suggestion to the message 
server for how long the message should be retained. If it chooses, the message 
server may retain the message for less time than is given in the TTL header. If 
it does, it must return that time in a TTL header in a response to the message 
request. 

You can almost think of this interaction as a conversation. 

App server: "Here's a message can you deliver it within 43200 seconds?"

Message server: "I really can't, but I can do it for you in 21600."

If the TTL has a value of 0, the message server should deliver it immediately or 
as soon as soon as the user agent is available to receive it.

### Crypto-Key header

To validate a message sent by your app server, the message server needs the 
public key. You send the public key in the Crypto-Key header. It has several 
parts.  
  
<pre>dh=<i>applicationServerKey</i>;p256ecdsa=<i>publicKey</i></pre>  
  
For example:  
  
<pre>dh=BGEw2wsHgLwzerjvnMTkbKrFRxdmwJ5S\_k7zi7A1coR\_sVjHmGrlvzYpAT1n4NPbioFlQkIrT  
NL8EH4V3ZZ4vJE,p256ecdsa=BDd3\_hVL9fZi9Ybo2UUzA284WG5FZR30\_95YeZJsiApwXKpNcF1rRPF3foIiBHXRdJI2Qhumhf6\_LFTeZaN</pre>
  
The first part (`dh=applicationServerKey`) is the public key, the one we created 
under Requesting permission and subscribing users. The second part 
(`p256ecdsa=publicKey`) is the public key, but base64 url encoded. Notice the 
comma separating the two parts of the crypto-key.  
  
**Note:** A bug in Chrome 52 requires that a semicolon be send to the message 
server in the Crypto-Key header instead of a comma.

### Authorization header

The standards-based way of sending a message is through a system called 
Voluntary Application Server Identification for Web Push or VAPID. This article 
is written with the assumption that VAPID is how your app server will send 
messages to your client. Everything we've covered so far applies to message 
servers that don't use VAPID (though, those methods may have additional 
requirements of their own). 

To use VAPID, you need an an Authorization header. It contains four parts:  
  
<pre>Bearer &lt;JWTHeader&gt;.&lt;Payload&gt;.&lt;Signature&gt;</pre>

The word Bearer is a literal that must be followed by a space. The remaining 
portions, which are encrypted and concatenated using a period are a signed JSON 
web token (JWT). A JWT is a way of sharing a JSON object with a second party in 
such a way that the sending party can sign it and the receiving party can verify 
the signature is from the expected sender. Adding the literal Bearer to the 
front makes it a bearer token.  
  
You must encrypt all messages before sending them. Encryption is enough of a 
specialty, even within software development, that we don't recommend writing 
your own encryption system. Fortunately, there are a range of push libraries 
including our own Push Encryption Library.  
  
Let's look at each part of the bearer token in detail.

#### JWT Header

The JWT Header contains two standard pieces of information: a typ property to 
indicate that this is a JWT message, and an alg property to indicate the 
algorithm used for encrypting the rest of the message. For VAPID, the later must 
be base64 url encoded.

{% highlight javascript %} 
{  
  "typ": "JWT",  
  "alg": "ES256"  
}
{% endhighlight %}

#### JWT Payload

The JWT calls this section the payload. This isn't where the message payload is 
stored. We'll get to that shortly. The payload is another JSON object with the 
following members:    
**aud**  
This contains the push service endpoint, which you should extract from the 
subscription object. This is not the origin of your site.    
**exp**  
Specifies the time the request expires in milliseconds. It must be within 
twenty-four hours. This can be calculated by converting the current date to 
milliseconds and adding the duration. For example, in Node.js you could do this: 
   
{% highlight javascript %}
Math.floor((Date.now() / 1000) + 12 * 60 * 60)
{% endhighlight %}

This should match the value in the TTL header.

**sub**  
Specifies a subject, which the VAPID spec defines as a way for the push service 
to contact a message sender. This can be a URL or a mail to URL.  
  
A complete payload looks like this:

{% highlight javascript %}  
{  
  "aud": "http://push.example.net",  
  "exp": "1469618703",  
  "sub": "mailto: my-email@some-url.com"  
}
{% endhighlight %}

#### Signature

Create the signature by first concatenating the JWT header and the payload with 
a dot, the encrypting the private key you created earlier. We're not going to 
show you how to do this, but there are a number of encryption libraries 
available. The result will look something like the following:  
  
<pre>Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJhdWQiOiJodHRwczovL2ZjbS5nb29nbGVhcGlzLmNvbSIsImV4cCI6MTQ2NjY2ODU5NCwic3ViIjoibWFpbHRvOnNpbXBsZS1wdXNoLWRlbW9AZ2F1bnRmYWNlLmNvLnVrIn0.Ec0VR8dtf5qb8Fb5Wk91br-evfho9sZT6jBRuQwxVMFyK5S8bhOjk8kuxvilLqTBmDXJM5l3uVrVOQirSsjq0A</pre>

### Message payload

When implementing server code there are two methods of sending messages to 
consider.  

* Messages with a data payload.
* Messages without a data payload, often called a tickle.

In the case of the tickle, the service worker uses the message as a signal to 
fetch data from an endpoint. The Handling Messages section contains sample code 
for showing how a service worker does this.  
  
Why would you ever send a message without a payload? There are two reasons.  

* You need to send something larger than the 4k payload limit set by the spec
* The clients needs fresher data than what would be in the push.

Technically, there's another reason which is that browser capabilities may vary 
for a while yet, but the two main reasons will likely always apply. If the 
browser doesn't support payloads, the subscription object won't contain keys.

The payload, regardless of how you get it to the client, should be encrypted. 
For payloads sent through the message server you must encrypt it using the 
publicKey and the authentication secret. It must also be padded, and salted with 
random 16 bytes, urlBase64 encoded. Finally, it's added to the body of the 
request sent to the message server. 

### Sending it on its way

In the web-push node library this is accomplished with an instance of the 
request object from the built-in https library.

{% highlight javascript %}
const https = require('https');
{% endhighlight %}

At some point the request is send to the message server. The web-push node 
library wraps this code inside a promise (with appropriate calls to resolve and 
reject) so that it can happen asynchronously. 

Note that the message server responds to the push message immediately, meaning 
it is asynchronous to sending the message to the client app.

{% highlight javascript %}
const pushRequest = https.request(options, function(pushResponse) {  
  let body = '';    
  // Allow the payload to be sent out in chunks.  
  pushResponse.on('data', function(chunk) {  
    body += chunk;  
  });    
  // Check to see if the push is successful.  
  pushResponse.on('end', function() {  
    if (pushResponse.statusCode !== 201) {  
      reject(new WebPushError('Received unexpected response code',  
        pushResponse.statusCode, pushResponse.headers, body));  
    } else {  
      // Do something with the response body.  
    }  
 });  
});  
  
if (requestPayload) {  
  pushRequest.write(requestPayload);  
}  
  
pushRequest.end();  
  
pushRequest.on('error', function(e) {  
  console.error(e);  
});
{% endhighlight %}