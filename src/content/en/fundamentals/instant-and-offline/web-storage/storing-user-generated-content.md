project_path: /web/_project.yaml
book_path: /web/fundamentals/_book.yaml
description: Learn how to store user generated content like images, media, and data files in a progressively enhanceable way.

{# wf_updated_on: 2017-09-25 #}
{# wf_published_on: 2017-09-25 #}
{# wf_tags: indexeddb #}

# Storing User Generated Content {: .page-title }

{% include "web/_shared/contributors/mscales.html" %}

If your application allows users to generate some sort of content offline then you are going to want
to store it locally. This article focuses on storing larger items like documents, images, and
videos.

When working online this data can be uploaded to the server, but we need a way to store the data
locally while offline, and then to sync the data with the server when we are online again.

## Using CacheStorage API
Since this content has a URL it makes sense to use the CacheStorage API. This API is accessible from
workers, windows and service workers.

To create a new entry you can insert the file straight into your cache. If you are working with a
`Blob`, for example, you might have a function like this:

    async function storeLocalFile(blob, url) {
      const cache = await caches.open('my-cache');
      const request = new Request(url);
      const response = new Response(blob);
      cache.put(request, response);
    }

This creates an entry in the cache so that later when you fetch the given URL you will get the user
generated file.

## Generating a URL
One issue with the above approach, though, is determining what the URL should be while offline. You
need to have some scheme in place that lets the client generate a URL that will not conflict with
any URL that may be generated by the server or another client.

One option is to use a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) in the
URL that can be generated on the client with a very small risk of collision. This can then be used
as the final server URL too.

If you would like to eliminate the risk of collision altogether, another option is to generate a
local-only URL for the item while offline, and then update all references to it later when the
server has confirmed what the URL really is.

For example, lets say that you are creating a drawing app. When a user creates a drawing locally you
could assign it a URL something like `/drawings/local/1`, using a simple counter to determine the id
of the file. You could store this URL in your local index of available drawings.

**user-drawings.json**

    {
      'drawings': [
        '/drawings/4b542102950af6dd6022301e9238ed24',
        '/drawings/64f466254e7c8eeb26dc7cc62e2f831f',
        '/drawings/local/1'
      ]
    }

Now when your UI lists the available drawings to view or edit everything will just work. When the
drawing has been uploaded to the server and you have determined it's real global URL you can cache
the new URL, delete the local version, and update the index.

## Fallback to IndexedDB
While the CacheStorage API is ideal for storing this kind of content, it is not yet available in all
browsers. Full offline support may not be available to users who's browsers do not support Service
Workers, but those users may be in a situation where they load the app while online and then create
content while temporarily offline. If you want to serve these users too, then you need a fallback
that works in more browsers.

The best alternative is IndexedDB, which has very wide support, but there are a few caveats.

Firstly, IndexedDB is often slower, particularly for large content. When getting an entry from the
CacheStorage API the `Response` object that you retrieve does not include the body, which is instead
streamed in later. IndexedDB retrieves the whole content up front.

The second is that while IndexedDB in theory supports storing anything that can be stored in
CacheStorage, this is not always implemented the same across browsers. Specifically, Safari on iOS
does not allow storing a `Blob` in IndexedDB.

## Converting to and from a Blob
Luckily it is not too difficult to convert a `Blob` into an `ArrayBuffer`, and visa versa. Remember,
however, that a `Blob` has a MIME type while an `ArrayBuffer` does not. You will need to store the
type alongside the buffer in order to do the conversion correctly.

To convert an `ArrayBuffer` to a `Blob` you simply use the `Blob` constructor.

    function arrayBufferToBlob(buffer, type) {
      return new Blob([buffer], {type: type});
    }

The other direction is slightly more involved, and is an asynchronous process. You can use a
`FileReader` object to read the blob as an `ArrayBuffer`. When the reading is finished a `loadend`
event is triggered on the reader. You can wrap this process in a `Promise` like so:

    function blobToArrayBuffer(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener('loadend', async (e) => {
          resolve(reader.result);
        });
        reader.addEventListener('error', reject);
        reader.readAsArrayBuffer(blob);
      });
    }
