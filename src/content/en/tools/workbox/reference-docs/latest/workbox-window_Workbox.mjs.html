<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="/web/tools/workbox/_project.yaml" />
  <meta name="book_path" value="/web/tools/workbox/_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: workbox-window/Workbox.mjs</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: workbox-window/Workbox.mjs</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/*
  Copyright 2019 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {Deferred} from &#x27;workbox-core/_private/Deferred.mjs&#x27;;
import {logger} from &#x27;workbox-core/_private/logger.mjs&#x27;;
import {messageSW} from &#x27;./messageSW.mjs&#x27;;
import {EventTargetShim} from &#x27;./utils/EventTargetShim.mjs&#x27;;
import {urlsMatch} from &#x27;./utils/urlsMatch.mjs&#x27;;
import {WorkboxEvent} from &#x27;./utils/WorkboxEvent.mjs&#x27;;
import &#x27;./_version.mjs&#x27;;


// The time a SW must be in the waiting phase before we can conclude
// &#x60;skipWaiting()&#x60; wasn&#x27;t called. This 200 amount wasn&#x27;t scientifically
// chosen, but it seems to avoid false positives in my testing.
const WAITING_TIMEOUT_DURATION &#x3D; 200;

// The amount of time after a registration that we can reasonably conclude
// that the registration didn&#x27;t trigger an update.
const REGISTRATION_TIMEOUT_DURATION &#x3D; 60000;

/**
 * A class to aid in handling service worker registration, updates, and
 * reacting to service worker lifecycle events.
 *
 * @fires [message]{@link module:workbox-window.Workbox#message}
 * @fires [installed]{@link module:workbox-window.Workbox#installed}
 * @fires [waiting]{@link module:workbox-window.Workbox#waiting}
 * @fires [controlling]{@link module:workbox-window.Workbox#controlling}
 * @fires [activated]{@link module:workbox-window.Workbox#activated}
 * @fires [redundant]{@link module:workbox-window.Workbox#redundant}
 * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}
 * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}
 * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}
 *
 * @memberof module:workbox-window
 */
class Workbox extends EventTargetShim {
  /**
   * Creates a new Workbox instance with a script URL and service worker
   * options. The script URL and options are the same as those used when
   * calling &#x60;navigator.serviceWorker.register(scriptURL, options)&#x60;. See:
   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register
   *
   * @param {string} scriptURL The service worker script associated with this
   *     instance.
   * @param {Object} [registerOptions] The service worker options associated
   *     with this instance.
   */
  constructor(scriptURL, registerOptions &#x3D; {}) {
    super();

    this._scriptURL &#x3D; scriptURL;
    this._registerOptions &#x3D; registerOptions;
    this._updateFoundCount &#x3D; 0;

    // Deferreds we can resolve later.
    this._swDeferred &#x3D; new Deferred();
    this._activeDeferred &#x3D; new Deferred();
    this._controllingDeferred &#x3D; new Deferred();

    // Bind event handler callbacks.
    this._onMessage &#x3D; this._onMessage.bind(this);
    this._onStateChange &#x3D; this._onStateChange.bind(this);
    this._onUpdateFound &#x3D; this._onUpdateFound.bind(this);
    this._onControllerChange &#x3D; this._onControllerChange.bind(this);
  }

  /**
   * Registers a service worker for this instances script URL and service
   * worker options. By default this method delays registration until after
   * the window has loaded.
   *
   * @param {Object} [options]
   * @param {Function} [options.immediate&#x3D;false] Setting this to true will
   *     register the service worker immediately, even if the window has
   *     not loaded (not recommended).
   */
  async register({immediate &#x3D; false} &#x3D; {}) {
    if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
      if (this._registrationTime) {
        logger.error(&#x27;Cannot re-register a Workbox instance after it has &#x27; +
            &#x27;been registered. Create a new instance instead.&#x27;);
        return;
      }
    }

    if (!immediate &amp;amp;&amp;amp; document.readyState !&#x3D;&#x3D; &#x27;complete&#x27;) {
      await new Promise((res) &#x3D;&gt; addEventListener(&#x27;load&#x27;, res));
    }

    // Set this flag to true if any service worker was controlling the page
    // at registration time.
    this._isUpdate &#x3D; Boolean(navigator.serviceWorker.controller);

    // Before registering, attempt to determine if a SW is already controlling
    // the page, and if that SW script (and version, if specified) matches this
    // instance&#x27;s script.
    this._compatibleControllingSW &#x3D; this._getControllingSWIfCompatible();

    this._registration &#x3D; await this._registerScript();

    // If we have a compatible controller, store the controller as the &quot;own&quot;
    // SW, resolve active/controlling deferreds and add necessary listeners.
    if (this._compatibleControllingSW) {
      this._sw &#x3D; this._compatibleControllingSW;
      this._activeDeferred.resolve(this._compatibleControllingSW);
      this._controllingDeferred.resolve(this._compatibleControllingSW);

      this._reportWindowReady(this._compatibleControllingSW);
      this._compatibleControllingSW.addEventListener(
          &#x27;statechange&#x27;, this._onStateChange, {once: true});
    }

    // If there&#x27;s a waiting service worker with a matching URL before the
    // &#x60;updatefound&#x60; event fires, it likely means that this site is open
    // in another tab, or the user refreshed the page (and thus the prevoius
    // page wasn&#x27;t fully unloaded before this page started loading).
    // /web/fundamentals/primers/service-workers/lifecycle#waiting
    const waitingSW &#x3D; this._registration.waiting;
    if (waitingSW &amp;amp;&amp;amp; urlsMatch(waitingSW.scriptURL, this._scriptURL)) {
      // Store the waiting SW as the &quot;own&quot; Sw, even if it means overwriting
      // a compatible controller.
      this._sw &#x3D; waitingSW;

      // Run this in the next microtask, so any code that adds an event
      // listener after awaiting &#x60;register()&#x60; will get this event.
      Promise.resolve().then(() &#x3D;&gt; {
        this.dispatchEvent(new WorkboxEvent(&#x27;waiting&#x27;, {
          sw: waitingSW,
          wasWaitingBeforeRegister: true,
        }));
        if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
          logger.warn(&#x27;A service worker was already waiting to activate &#x27; +
              &#x27;before this script was registered...&#x27;);
        }
      });
    }

    // If an &quot;own&quot; SW is already set, resolve the deferred.
    if (this._sw) {
      this._swDeferred.resolve(this._sw);
    }

    if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
      logger.log(&#x27;Successfully registered service worker.&#x27;, this._scriptURL);

      if (navigator.serviceWorker.controller) {
        if (this._compatibleControllingSW) {
          logger.debug(&#x27;A service worker with the same script URL &#x27; +
              &#x27;is already controlling this page.&#x27;);
        } else {
          logger.debug(&#x27;A service worker with a different script URL is &#x27; +
              &#x27;currently controlling the page. The browser is now fetching &#x27; +
              &#x27;the new script now...&#x27;);
        }
      }

      const currentPageIsOutOfScope &#x3D; () &#x3D;&gt; {
        const scopeURL &#x3D; new URL(
            this._registerOptions.scope || this._scriptURL, document.baseURI);
        const scopeURLBasePath &#x3D; new URL(&#x27;./&#x27;, scopeURL.href).pathname;
        return !location.pathname.startsWith(scopeURLBasePath);
      };
      if (currentPageIsOutOfScope()) {
        logger.warn(&#x27;The current page is not in scope for the registered &#x27; +
            &#x27;service worker. Was this a mistake?&#x27;);
      }
    }

    this._registration.addEventListener(&#x27;updatefound&#x27;, this._onUpdateFound);
    navigator.serviceWorker.addEventListener(
        &#x27;controllerchange&#x27;, this._onControllerChange, {once: true});

    // Add message listeners.
    if (&#x27;BroadcastChannel&#x27; in self) {
      this._broadcastChannel &#x3D; new BroadcastChannel(&#x27;workbox&#x27;);
      this._broadcastChannel.addEventListener(&#x27;message&#x27;, this._onMessage);
    }
    navigator.serviceWorker.addEventListener(&#x27;message&#x27;, this._onMessage);

    return this._registration;
  }

  /**
   * Resolves to the service worker registered by this instance as soon as it
   * is active. If a service worker was already controlling at registration
   * time then it will resolve to that if the script URLs (and optionally
   * script versions) match, otherwise it will wait until an update is found
   * and activates.
   *
   * @return {Promise&amp;lt;ServiceWorker&gt;}
   */
  get active() {
    return this._activeDeferred.promise;
  }

  /**
   * Resolves to the service worker registered by this instance as soon as it
   * is controlling the page. If a service worker was already controlling at
   * registration time then it will resolve to that if the script URLs (and
   * optionally script versions) match, otherwise it will wait until an update
   * is found and starts controlling the page.
   * Note: the first time a service worker is installed it will active but
   * not start controlling the page unless &#x60;clients.claim()&#x60; is called in the
   * service worker.
   *
   * @return {Promise&amp;lt;ServiceWorker&gt;}
   */
  get controlling() {
    return this._controllingDeferred.promise;
  }

  /**
   * Resolves with a reference to a service worker that matches the script URL
   * of this instance, as soon as it&#x27;s available.
   *
   * If, at registration time, there&#x27;s already an active or waiting service
   * worker with a matching script URL, it will be used (with the waiting
   * service worker taking precedence over the active service worker if both
   * match, since the waiting service worker would have been registered more
   * recently).
   * If there&#x27;s no matching active or waiting service worker at registration
   * time then the promise will not resolve until an update is found and starts
   * installing, at which point the installing service worker is used.
   *
   * @return {Promise&amp;lt;ServiceWorker&gt;}
   */
  async getSW() {
    // If &#x60;this._sw&#x60; is set, resolve with that as we want &#x60;getSW()&#x60; to
    // return the correct (new) service worker if an update is found.
    return this._sw || this._swDeferred.promise;
  }

  /**
   * Sends the passed data object to the service worker registered by this
   * instance (via [&#x60;getSW()&#x60;]{@link module:workbox-window.Workbox#getSW}) and resolves
   * with a response (if any).
   *
   * A response can be set in a message handler in the service worker by
   * calling &#x60;event.ports[0].postMessage(...)&#x60;, which will resolve the promise
   * returned by &#x60;messageSW()&#x60;. If no response is set, the promise will never
   * resolve.
   *
   * @param {Object} data An object to send to the service worker
   * @return {Promise&amp;lt;Object&gt;}
   */
  async messageSW(data) {
    const sw &#x3D; await this.getSW();
    return messageSW(sw, data);
  }

  /**
   * Checks for a service worker already controlling the page and returns
   * it if its script URL matchs.
   *
   * @private
   * @return {ServiceWorker|undefined}
   */
  _getControllingSWIfCompatible() {
    const controller &#x3D; navigator.serviceWorker.controller;
    if (controller &amp;amp;&amp;amp; urlsMatch(controller.scriptURL, this._scriptURL)) {
      return controller;
    }
  }

  /**
   * Registers a service worker for this instances script URL and register
   * options and tracks the time registration was complete.
   *
   * @private
   */
  async _registerScript() {
    try {
      const reg &#x3D; await navigator.serviceWorker.register(
          this._scriptURL, this._registerOptions);

      // Keep track of when registration happened, so it can be used in the
      // &#x60;this._onUpdateFound&#x60; heuristic. Also use the presence of this
      // property as a way to see if &#x60;.register()&#x60; has been called.
      this._registrationTime &#x3D; performance.now();

      return reg;
    } catch (error) {
      if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
        logger.error(error);
      }
      // Re-throw the error.
      throw error;
    }
  }


  /**
   * Sends a message to the passed service worker that the window is ready.
   *
   * @param {ServiceWorker} sw
   * @private
   */
  _reportWindowReady(sw) {
    messageSW(sw, {
      type: &#x27;WINDOW_READY&#x27;,
      meta: &#x27;workbox-window&#x27;,
    });
  }

  /**
   * @private
   */
  _onUpdateFound() {
    const installingSW &#x3D; this._registration.installing;

    // If the script URL passed to &#x60;navigator.serviceWorker.register()&#x60; is
    // different from the current controlling SW&#x27;s script URL, we know any
    // successful registration calls will trigger an &#x60;updatefound&#x60; event.
    // But if the registered script URL is the same as the current controlling
    // SW&#x27;s script URL, we&#x27;ll only get an &#x60;updatefound&#x60; event if the file
    // changed since it was last registered. This can be a problem if the user
    // opens up the same page in a different tab, and that page registers
    // a SW that triggers an update. It&#x27;s a problem because this page has no
    // good way of knowing whether the &#x60;updatefound&#x60; event came from the SW
    // script it registered or from a registration attempt made by a newer
    // version of the page running in another tab.
    // To minimize the possibility of a false positive, we use the logic here:
    let updateLikelyTriggeredExternally &#x3D;
        // Since we enforce only calling &#x60;register()&#x60; once, and since we don&#x27;t
        // add the &#x60;updatefound&#x60; event listener until the &#x60;register()&#x60; call, if
        // &#x60;_updateFoundCount&#x60; is &gt; 0 then it means this method has already
        // been called, thus this SW must be external
        this._updateFoundCount &gt; 0 ||
        // If the script URL of the installing SW is different from this
        // instance&#x27;s script URL, we know it&#x27;s definitely not from our
        // registration.
        !urlsMatch(installingSW.scriptURL, this._scriptURL) ||
        // If all of the above are false, then we use a time-based heuristic:
        // Any &#x60;updatefound&#x60; event that occurs long after our registration is
        // assumed to be external.
        (performance.now() &gt;
            this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?
                // If any of the above are not true, we assume the update was
                // triggered by this instance.
                true : false;

    if (updateLikelyTriggeredExternally) {
      this._externalSW &#x3D; installingSW;
      this._registration.removeEventListener(
          &#x27;updatefound&#x27;, this._onUpdateFound);
    } else {
      // If the update was not triggered externally we know the installing
      // SW is the one we registered, so we set it.
      this._sw &#x3D; installingSW;
      this._swDeferred.resolve(installingSW);

      // The &#x60;installing&#x60; state isn&#x27;t something we have a dedicated
      // callback for, but we do log messages for it in development.
      if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
        if (navigator.serviceWorker.controller) {
          logger.log(&#x27;Updated service worker found. Installing now...&#x27;);
        } else {
          logger.log(&#x27;Service worker is installing...&#x27;);
        }
      }
    }

    // Increment the &#x60;updatefound&#x60; count, so future invocations of this
    // method can be sure they were triggered externally.
    ++this._updateFoundCount;

    // Add a &#x60;statechange&#x60; listener regardless of whether this update was
    // triggered externally, since we have callbacks for both.
    installingSW.addEventListener(&#x27;statechange&#x27;, this._onStateChange);
  }

  /**
   * @private
   * @param {Event} originalEvent
   */
  _onStateChange(originalEvent) {
    const sw &#x3D; originalEvent.target;
    const {state} &#x3D; sw;
    const isExternal &#x3D; sw &#x3D;&#x3D;&#x3D; this._externalSW;
    const eventPrefix &#x3D; isExternal ? &#x27;external&#x27; : &#x27;&#x27;;

    const eventProps &#x3D; {sw, originalEvent};
    if (!isExternal &amp;amp;&amp;amp; this._isUpdate) {
      eventProps.isUpdate &#x3D; true;
    }

    this.dispatchEvent(new WorkboxEvent(
        eventPrefix + state, eventProps));

    if (state &#x3D;&#x3D;&#x3D; &#x27;installed&#x27;) {
      // This timeout is used to ignore cases where the service worker calls
      // &#x60;skipWaiting()&#x60; in the install event, thus moving it directly in the
      // activating state. (Since all service workers *must* go through the
      // waiting phase, the only way to detect &#x60;skipWaiting()&#x60; called in the
      // install event is to observe that the time spent in the waiting phase
      // is very short.)
      // NOTE: we don&#x27;t need separate timeouts for the own and external SWs
      // since they can&#x27;t go through these phases at the same time.
      this._waitingTimeout &#x3D; setTimeout(() &#x3D;&gt; {
        // Ensure the SW is still waiting (it may now be redundant).
        if (state &#x3D;&#x3D;&#x3D; &#x27;installed&#x27; &amp;amp;&amp;amp; this._registration.waiting &#x3D;&#x3D;&#x3D; sw) {
          this.dispatchEvent(new WorkboxEvent(
              eventPrefix + &#x27;waiting&#x27;, eventProps));

          if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
            if (isExternal) {
              logger.warn(&#x27;An external service worker has installed but is &#x27; +
                  &#x27;waiting for this client to close before activating...&#x27;);
            } else {
              logger.warn(&#x27;The service worker has installed but is waiting &#x27; +
                  &#x27;for existing clients to close before activating...&#x27;);
            }
          }
        }
      }, WAITING_TIMEOUT_DURATION);
    } else if (state &#x3D;&#x3D;&#x3D; &#x27;activating&#x27;) {
      clearTimeout(this._waitingTimeout);
      if (!isExternal) {
        this._activeDeferred.resolve(sw);
      }
    }

    if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
      switch (state) {
        case &#x27;installed&#x27;:
          if (isExternal) {
            logger.warn(&#x27;An external service worker has installed. &#x27; +
                &#x27;You may want to suggest users reload this page.&#x27;);
          } else {
            logger.log(&#x27;Registered service worker installed.&#x27;);
          }
          break;
        case &#x27;activated&#x27;:
          if (isExternal) {
            logger.warn(&#x27;An external service worker has activated.&#x27;);
          } else {
            logger.log(&#x27;Registered service worker activated.&#x27;);
            if (sw !&#x3D;&#x3D; navigator.serviceWorker.controller) {
              logger.warn(&#x27;The registered service worker is active but &#x27; +
                  &#x27;not yet controlling the page. Reload or run &#x27; +
                  &#x27;&#x60;clients.claim()&#x60; in the service worker.&#x27;);
            }
          }
          break;
        case &#x27;redundant&#x27;:
          if (sw &#x3D;&#x3D;&#x3D; this._compatibleControllingSW) {
            logger.log(&#x27;Previously controlling service worker now redundant!&#x27;);
          } else if (!isExternal) {
            logger.log(&#x27;Registered service worker now redundant!&#x27;);
          }
          break;
      }
    }
  }

  /**
   * @private
   * @param {Event} originalEvent
   */
  _onControllerChange(originalEvent) {
    const sw &#x3D; this._sw;
    if (sw &#x3D;&#x3D;&#x3D; navigator.serviceWorker.controller) {
      this.dispatchEvent(new WorkboxEvent(&#x27;controlling&#x27;, {sw, originalEvent}));
      if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
        logger.log(&#x27;Registered service worker now controlling this page.&#x27;);
      }
      this._controllingDeferred.resolve(sw);
    }
  }

  /**
   * @private
   * @param {Event} originalEvent
   */
  _onMessage(originalEvent) {
    const {data} &#x3D; originalEvent;
    this.dispatchEvent(new WorkboxEvent(&#x27;message&#x27;, {data, originalEvent}));
  }
}

// The jsdoc comments below outline the events this instance may dispatch:
// -----------------------------------------------------------------------

/**
 * The &#x60;message&#x60; event is dispatched any time a &#x60;postMessage&#x60; (or a
 * &#x60;BroadcastChannel&#x60; message with the &#x60;workbox&#x60; channel name) is received.
 *
 * @event module:workbox-window.Workbox#message
 * @type {WorkboxEvent}
 * @property {*} data The &#x60;data&#x60; property from the original &#x60;message&#x60; event.
 * @property {Event} originalEvent The original [&#x60;message&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}
 *     event.
 * @property {string} type &#x60;message&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;installed&#x60; event is dispatched if the state of a
 * [&#x60;Workbox&#x60;]{@link module:workbox-window.Workbox} instance&#x27;s
 * [registered service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to &#x60;installed&#x60;.
 *
 * Then can happen either the very first time a service worker is installed,
 * or after an update to the current service worker is found. In the case
 * of an update being found, the event&#x27;s &#x60;isUpdate&#x60; property will be &#x60;true&#x60;.
 *
 * @event module:workbox-window.Workbox#installed
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [&#x60;statechange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this &#x60;Workbox&#x60; instance called &#x60;register()&#x60;.
 * @property {string} type &#x60;installed&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;waiting&#x60; event is dispatched if the state of a
 * [&#x60;Workbox&#x60;]{@link module:workbox-window.Workbox} instance&#x27;s
 * [registered service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to &#x60;installed&#x60; and then doesn&#x27;t immediately change to &#x60;activating&#x60;.
 * It may also be dispatched if a service worker with the same
 * [&#x60;scriptURL&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}
 * was already waiting when the [&#x60;register()&#x60;]{@link module:workbox-window.Workbox#register}
 * method was called.
 *
 * @event module:workbox-window.Workbox#waiting
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The native &#x60;controllerchange&#x60; event
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this &#x60;Workbox&#x60; instance called &#x60;register()&#x60;.
 * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with
 *     a matching &#x60;scriptURL&#x60; was already waiting when this &#x60;Workbox&#x60;
 *     instance called &#x60;register()&#x60;.
 * @property {string} type &#x60;waiting&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;controlling&#x60; event is dispatched if a
 * [&#x60;controllerchange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}
 * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}
 * and the [&#x60;scriptURL&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}
 * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}
 * matches the &#x60;scriptURL&#x60; of the &#x60;Workbox&#x60; instance&#x27;s
 * [registered service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-registered-sw}.
 *
 * @event module:workbox-window.Workbox#controlling
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [&#x60;controllerchange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this service worker was registered.
 * @property {string} type &#x60;controlling&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;activated&#x60; event is dispatched if the state of a
 * [&#x60;Workbox&#x60;]{@link module:workbox-window.Workbox} instance&#x27;s
 * [registered service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to &#x60;activated&#x60;.
 *
 * @event module:workbox-window.Workbox#activated
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [&#x60;statechange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this &#x60;Workbox&#x60; instance called &#x60;register()&#x60;.
 * @property {string} type &#x60;activated&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;redundant&#x60; event is dispatched if the state of a
 * [&#x60;Workbox&#x60;]{@link module:workbox-window.Workbox} instance&#x27;s
 * [registered service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to &#x60;redundant&#x60;.
 *
 * @event module:workbox-window.Workbox#redundant
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [&#x60;statechange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this &#x60;Workbox&#x60; instance called &#x60;register()&#x60;.
 * @property {string} type &#x60;redundant&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;externalinstalled&#x60; event is dispatched if the state of an
 * [external service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-external-sw}
 * changes to &#x60;installed&#x60;.
 *
 * @event module:workbox-window.Workbox#externalinstalled
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [&#x60;statechange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {string} type &#x60;externalinstalled&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;externalwaiting&#x60; event is dispatched if the state of an
 * [external service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-external-sw}
 * changes to &#x60;waiting&#x60;.
 *
 * @event module:workbox-window.Workbox#externalwaiting
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event|undefined} originalEvent The original [&#x60;statechange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {string} type &#x60;externalwaiting&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

/**
 * The &#x60;externalactivated&#x60; event is dispatched if the state of an
 * [external service worker]{@link /web/tools/workbox/modules/workbox-precaching#def-external-sw}
 * changes to &#x60;activated&#x60;.
 *
 * @event module:workbox-window.Workbox#externalactivated
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [&#x60;statechange&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {string} type &#x60;externalactivated&#x60;.
 * @property {Workbox} target The &#x60;Workbox&#x60; instance.
 */

export {Workbox};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>