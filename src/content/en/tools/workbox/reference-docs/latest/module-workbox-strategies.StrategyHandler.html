<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="/web/tools/workbox/_project.yaml" />
  <meta name="book_path" value="/web/tools/workbox/_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Class: StrategyHandler</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1><small><a href="module-workbox-strategies.html">workbox-strategies</a>.<wbr></small><span class="symbol-name">StrategyHandler</span></h1>
            <div class="symbol-detail-labels"><span class="label label-kind"><small>class</small></span>&nbsp;&nbsp;&nbsp;<span class="label label-static"><small>static</small></span></div>
            <div class="symbol-detail-labels">
              <span class="label label-kind"><small>Version</small></span>
              &nbsp;&nbsp;&nbsp;
              <span class="label label-version"><small>6.2.0</small></span>
            </div>
            <p>A class created every time a Strategy instance instance calls
              handle() or
              handleAll() that wraps all fetch and
              cache actions around plugin callbacks and keeps track of when the strategy
              is &quot;done&quot; (i.e. all added <code>event.waitUntil()</code> promises have resolved).</p>
          </header>
          <section>
            <h2>Constructor</h2>
            <section>
              <h3 id="StrategyHandler" class="symbol-name">StrategyHandler</h3>
              <p class="type-signature"> new
                StrategyHandler(strategy, options)</p>
              <p>Creates a new instance associated with the passed strategy and event
                that's handling the request.</p>
              <p>The constructor also initializes the state that will be passed to each of
                the plugins handling this request.</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>strategy</p>
                      </td>
                      <td>
                        <p class="details-table-types"><a href="module-workbox-strategies.Strategy.html">module:workbox-strategies.Strategy</a></p>
                      </td>
                    </tr>
                    <tr>
                      <td class="details-table-name">
                        <p>options</p>
                      </td>
                      <td>
                        <p class="details-table-types">Object</p>
                        <p>Values in <code>options</code> have the following properties:</p>
                        <table class="function param responsive">
                          <tr>
                            <th colspan="2">
                              <h4>Parameter</h4>
                            </th>
                          </tr>
                          <tbody>
                            <tr>
                              <td class="details-table-name">
                                <p>request</p>
                              </td>
                              <td>
                                <p class="details-table-types">(Request or string)</p>
                                <p>A request to run this strategy for.</p>
                              </td>
                            </tr>
                            <tr>
                              <td class="details-table-name">
                                <p>event</p>
                              </td>
                              <td>
                                <p class="details-table-types">ExtendableEvent</p>
                                <p>The event associated with the
                                  request.</p>
                              </td>
                            </tr>
                            <tr>
                              <td class="details-table-name">
                                <p>url</p>
                              </td>
                              <td>
                                <p class="details-table-optional">Optional</p>
                                <p class="details-table-types">URL</p>
                              </td>
                            </tr>
                            <tr>
                              <td class="details-table-name">
                                <p>params</p>
                              </td>
                              <td>
                                <p class="details-table-optional">Optional</p>
                                <p class="details-table-types">any type</p>
                                <p><a href="module-workbox-routing.html#~matchCallback">match callback</a>,
                                  (if applicable).</p>
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
              </dl>
            </section>
          </section>
          <section>
            <h2>Properties</h2>
            <section>
              <h3 id="event" class="symbol-name">event</h3>
              <p class="type-signature">ExtendableEvent</p>
              <p>The event associated with this request.</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="params" class="symbol-name">params</h3>
              <p class="type-signature">(any type or undefined)</p>
              <p>A <code>param</code> value (if passed to the strategy's
                <code>handle()</code> or <code>handleAll()</code> method).
                Note: the <code>param</code> param will be present if the strategy was invoked
                from a workbox <code>Route</code> object and the
                <a href="module-workbox-routing.html#~matchCallback">match callback</a> returned
                a truthy value (it will be that value).</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="request" class="symbol-name">request</h3>
              <p class="type-signature">Request</p>
              <p>The request the strategy is performing (passed to the strategy's
                <code>handle()</code> or <code>handleAll()</code> method).</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="url" class="symbol-name">url</h3>
              <p class="type-signature">(URL or undefined)</p>
              <p>A <code>URL</code> instance of <code>request.url</code> (if passed to the strategy's
                <code>handle()</code> or <code>handleAll()</code> method).
                Note: the <code>url</code> param will be present if the strategy was invoked
                from a workbox <code>Route</code> object.</p>
              <dl class="dl-compact">
              </dl>
            </section>
            <h2>Methods</h2>
            <section>
              <h3 id="cacheMatch" class="symbol-name">cacheMatch</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> cacheMatch(key)&nbsp;returns&nbsp;Promise containing (Response or undefined)</p>
              <p>Matches a request from the cache (and invokes any applicable plugin
                callback methods) using the <code>cacheName</code>, <code>matchOptions</code>, and <code>plugins</code>
                defined on the strategy object.</p>
              <p>The following plugin lifecycle methods are invoked when using this method:</p>
              <ul>
                <li>cacheKeyWillByUsed()</li>
                <li>cachedResponseWillByUsed()</li>
              </ul>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>key</p>
                      </td>
                      <td>
                        <p class="details-table-types">(Request or string)</p>
                        <p>The Request or URL to use as the cache key.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Promise containing (Response or undefined)</code>&nbsp;A matching response, if found.</p>
                </dd>
              </dl>
              <h3 id="cachePut" class="symbol-name">cachePut</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> cachePut(key, response)&nbsp;returns&nbsp;Promise containing boolean</p>
              <p>Puts a request/response pair in the cache (and invokes any applicable
                plugin callback methods) using the <code>cacheName</code> and <code>plugins</code> defined on
                the strategy object.</p>
              <p>The following plugin lifecycle methods are invoked when using this method:</p>
              <ul>
                <li>cacheKeyWillByUsed()</li>
                <li>cacheWillUpdate()</li>
                <li>cacheDidUpdate()</li>
              </ul>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>key</p>
                      </td>
                      <td>
                        <p class="details-table-types">(Request or string)</p>
                        <p>The request or URL to use as the cache key.</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="details-table-name">
                        <p>response</p>
                      </td>
                      <td>
                        <p class="details-table-types">Response</p>
                        <p>The response to cache.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Promise containing boolean</code>&nbsp;<code>false</code> if a cacheWillUpdate caused the response
                    not be cached, and <code>true</code> otherwise.</p>
                </dd>
              </dl>
              <h3 id="destroy" class="symbol-name">destroy</h3>
              <p class="type-signature"> destroy()</p>
              <p>Stops running the strategy and immediately resolves any pending
                <code>waitUntil()</code> promises.</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="doneWaiting" class="symbol-name">doneWaiting</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> doneWaiting()</p>
              <p>Returns a promise that resolves once all promises passed to
                <code>waitUntil()</code>
                have settled.</p>
              <p>Note: any work done after <code>doneWaiting()</code> settles should be manually
                passed to an event's <code>waitUntil()</code> method (not this handler's
                <code>waitUntil()</code> method), otherwise the service worker thread my be killed
                prior to your work completing.</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="fetch" class="symbol-name">fetch</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> fetch(input)&nbsp;returns&nbsp;Promise containing Response</p>
              <p>Fetches a given request (and invokes any applicable plugin callback
                methods) using the <code>fetchOptions</code> (for non-navigation requests) and
                <code>plugins</code> defined on the <code>Strategy</code> object.</p>
              <p>The following plugin lifecycle methods are invoked when using this method:</p>
              <ul>
                <li><code>requestWillFetch()</code></li>
                <li><code>fetchDidSucceed()</code></li>
                <li><code>fetchDidFail()</code></li>
              </ul>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>input</p>
                      </td>
                      <td>
                        <p class="details-table-types">(Request or string)</p>
                        <p>The URL or request to fetch.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Promise containing Response</code>&nbsp;</p>
                </dd>
              </dl>
              <h3 id="fetchAndCachePut" class="symbol-name">fetchAndCachePut</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> fetchAndCachePut(input)&nbsp;returns&nbsp;Promise containing Response</p>
              <p>Calls <code>this.fetch()</code> and (in the background) runs <code>this.cachePut()</code> on
                the response generated by <code>this.fetch()</code>.</p>
              <p>The call to <code>this.cachePut()</code> automatically invokes <code>this.waitUntil()</code>,
                so you do not have to manually call <code>waitUntil()</code> on the event.</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>input</p>
                      </td>
                      <td>
                        <p class="details-table-types">(Request or string)</p>
                        <p>The request or URL to fetch and cache.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Promise containing Response</code>&nbsp;</p>
                </dd>
              </dl>
              <h3 id="getCacheKey" class="symbol-name">getCacheKey</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> getCacheKey(request, mode)&nbsp;returns&nbsp;Promise containing Request</p>
              <p>Checks the list of plugins for the <code>cacheKeyWillBeUsed</code> callback, and
                executes any of those callbacks found in sequence. The final <code>Request</code>
                object returned by the last plugin is treated as the cache key for cache
                reads and/or writes. If no <code>cacheKeyWillBeUsed</code> plugin callbacks have
                been registered, the passed request is returned unmodified</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>request</p>
                      </td>
                      <td>
                        <p class="details-table-types">Request</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="details-table-name">
                        <p>mode</p>
                      </td>
                      <td>
                        <p class="details-table-types">string</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Promise containing Request</code>&nbsp;</p>
                </dd>
              </dl>
              <h3 id="hasCallback" class="symbol-name">hasCallback</h3>
              <p class="type-signature"> hasCallback(name)&nbsp;returns&nbsp;boolean</p>
              <p>Returns true if the strategy has at least one plugin with the given
                callback.</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>name</p>
                      </td>
                      <td>
                        <p class="details-table-types">string</p>
                        <p>The name of the callback to check for.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>boolean</code>&nbsp;</p>
                </dd>
              </dl>
              <h3 id="iterateCallbacks" class="symbol-name">iterateCallbacks</h3>
              <div class="symbol-detail-labels"><span class="label label-generator"><small>generator</small></span></div>
              <p class="type-signature"> iterateCallbacks(name)&nbsp;returns&nbsp;Array of function()</p>
              <p>Accepts a callback and returns an iterable of matching plugin callbacks,
                where each callback is wrapped with the current handler state (i.e. when
                you call each callback, whatever object parameter you pass it will
                be merged with the plugin's current state).</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>name</p>
                      </td>
                      <td>
                        <p class="details-table-types">string</p>
                        <p>The name fo the callback to run</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Array of function()</code>&nbsp;</p>
                </dd>
              </dl>
              <h3 id="runCallbacks" class="symbol-name">runCallbacks</h3>
              <div class="symbol-detail-labels"><span class="label label-async"><small>async</small></span></div>
              <p class="type-signature"> runCallbacks(name, param)</p>
              <p>Runs all plugin callbacks matching the given name, in order, passing the
                given param object (merged ith the current plugin state) as the only
                argument.</p>
              <p>Note: since this method runs all plugins, it's not suitable for cases
                where the return value of a callback needs to be applied prior to calling
                the next callback. See
                <a href="module-workbox-strategies.StrategyHandler.html#iterateCallbacks"><code>iterateCallbacks()</code></a>
                below for how to handle that case.</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>name</p>
                      </td>
                      <td>
                        <p class="details-table-types">string</p>
                        <p>The name of the callback to run within each plugin.</p>
                      </td>
                    </tr>
                    <tr>
                      <td class="details-table-name">
                        <p>param</p>
                      </td>
                      <td>
                        <p class="details-table-types">Object</p>
                        <p>The object to pass as the first (and only) param
                          when executing each callback. This object will be merged with the
                          current plugin state prior to callback execution.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
              </dl>
              <h3 id="waitUntil" class="symbol-name">waitUntil</h3>
              <p class="type-signature"> waitUntil(promise)</p>
              <p>Adds a promise to the
                <a href="https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises">extend lifetime promises</a>
                of the event event associated with the request being handled (usually a
                <code>FetchEvent</code>).</p>
              <p>Note: you can await
                <code>doneWaiting()</code>
                to know when all added promises have settled.</p>
              <section>
                <table class="function param responsive">
                  <tr>
                    <th colspan="2">
                      <h4>Parameter</h4>
                    </th>
                  </tr>
                  <tbody>
                    <tr>
                      <td class="details-table-name">
                        <p>promise</p>
                      </td>
                      <td>
                        <p class="details-table-types">Promise</p>
                        <p>A promise to add to the extend lifetime promises
                          of the event that triggered the request.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
              </dl>
            </section>
          </section>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>