<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="/web/tools/workbox/_project.yaml" />
  <meta name="book_path" value="/web/tools/workbox/_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: workbox-precaching/PrecacheStrategy.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: workbox-precaching/PrecacheStrategy.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/*
  Copyright 2020 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
import { copyResponse } from &#x27;workbox-core/copyResponse.js&#x27;;
import { cacheNames } from &#x27;workbox-core/_private/cacheNames.js&#x27;;
import { getFriendlyURL } from &#x27;workbox-core/_private/getFriendlyURL.js&#x27;;
import { logger } from &#x27;workbox-core/_private/logger.js&#x27;;
import { WorkboxError } from &#x27;workbox-core/_private/WorkboxError.js&#x27;;
import { Strategy } from &#x27;workbox-strategies/Strategy.js&#x27;;
import &#x27;./_version.js&#x27;;
const copyRedirectedCacheableResponsesPlugin &#x3D; {
    async cacheWillUpdate({ response }) {
        return response.redirected ? await copyResponse(response) : response;
    }
};
/**
 * A [Strategy]{@link module:workbox-strategies.Strategy} implementation
 * specifically designed to work with
 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
 * to both cache and fetch precached assets.
 *
 * Note: an instance of this class is created automatically when creating a
 * &#x60;PrecacheController&#x60;; it&#x27;s generally not necessary to create this yourself.
 *
 * @extends module:workbox-strategies.Strategy
 * @memberof module:workbox-precaching
 */
class PrecacheStrategy extends Strategy {
    /**
     *
     * @param {Object} [options]
     * @param {string} [options.cacheName] Cache name to store and retrieve
     * requests. Defaults to the cache names provided by
     * [workbox-core]{@link module:workbox-core.cacheNames}.
     * @param {Array&amp;lt;Object&gt;} [options.plugins] [Plugins]{@link /web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} [options.fetchOptions] Values passed along to the
     * [&#x60;init&#x60;]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
     * of all fetch() requests made by this strategy.
     * @param {Object} [options.matchOptions] The
     * [&#x60;CacheQueryOptions&#x60;]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
     * for any &#x60;cache.match()&#x60; or &#x60;cache.put()&#x60; calls made by this strategy.
     * @param {boolean} [options.fallbackToNetwork&#x3D;true] Whether to attempt to
     * get the response from the network if there&#x27;s a precache miss.
     */
    constructor(options &#x3D; {}) {
        options.cacheName &#x3D; cacheNames.getPrecacheName(options.cacheName);
        super(options);
        this._fallbackToNetwork &#x3D; options.fallbackToNetwork &#x3D;&#x3D;&#x3D; false ? false : true;
        // Redirected responses cannot be used to satisfy a navigation request, so
        // any redirected response must be &quot;copied&quot; rather than cloned, so the new
        // response doesn&#x27;t contain the &#x60;redirected&#x60; flag. See:
        // https://bugs.chromium.org/p/chromium/issues/detail?id&#x3D;669363&amp;amp;desc&#x3D;2#c1
        this.plugins.push(copyRedirectedCacheableResponsesPlugin);
    }
    /**
     * @private
     * @param {Request|string} request A request to run this strategy for.
     * @param {module:workbox-strategies.StrategyHandler} handler The event that
     *     triggered the request.
     * @return {Promise&amp;lt;Response&gt;}
     */
    async _handle(request, handler) {
        const response &#x3D; await handler.cacheMatch(request);
        if (!response) {
            // If this is an &#x60;install&#x60; event then populate the cache. If this is a
            // &#x60;fetch&#x60; event (or any other event) then respond with the cached
            // response.
            if (handler.event &amp;amp;&amp;amp; handler.event.type &#x3D;&#x3D;&#x3D; &#x27;install&#x27;) {
                return await this._handleInstall(request, handler);
            }
            return await this._handleFetch(request, handler);
        }
        return response;
    }
    async _handleFetch(request, handler) {
        let response;
        // Fall back to the network if we don&#x27;t have a cached response
        // (perhaps due to manual cache cleanup).
        if (this._fallbackToNetwork) {
            if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
                logger.warn(&#x60;The precached response for &#x60; +
                    &#x60;${getFriendlyURL(request.url)} in ${this.cacheName} was not &#x60; +
                    &#x60;found. Falling back to the network instead.&#x60;);
            }
            response &#x3D; await handler.fetch(request);
        }
        else {
            // This shouldn&#x27;t normally happen, but there are edge cases:
            // https://github.com/GoogleChrome/workbox/issues/1441
            throw new WorkboxError(&#x27;missing-precache-entry&#x27;, {
                cacheName: this.cacheName,
                url: request.url,
            });
        }
        if (process.env.NODE_ENV !&#x3D;&#x3D; &#x27;production&#x27;) {
            const cacheKey &#x3D; handler.params &amp;amp;&amp;amp; handler.params.cacheKey ||
                await handler.getCacheKey(request, &#x27;read&#x27;);
            // Workbox is going to handle the route.
            // print the routing details to the console.
            logger.groupCollapsed(&#x60;Precaching is responding to: &#x60; +
                getFriendlyURL(request.url));
            logger.log(&#x60;Serving the precached url: ${getFriendlyURL(cacheKey.url)}&#x60;);
            logger.groupCollapsed(&#x60;View request details here.&#x60;);
            logger.log(request);
            logger.groupEnd();
            logger.groupCollapsed(&#x60;View response details here.&#x60;);
            logger.log(response);
            logger.groupEnd();
            logger.groupEnd();
        }
        return response;
    }
    async _handleInstall(request, handler) {
        const response &#x3D; await handler.fetchAndCachePut(request);
        // Any time there&#x27;s no response, consider it a precaching error.
        let responseSafeToPrecache &#x3D; Boolean(response);
        // Also consider it an error if the user didn&#x27;t pass their own
        // cacheWillUpdate plugin, and the response is a 400+ (note: this means
        // that by default opaque responses can be precached).
        if (response &amp;amp;&amp;amp; response.status &gt;&#x3D; 400 &amp;amp;&amp;amp;
            !this._usesCustomCacheableResponseLogic()) {
            responseSafeToPrecache &#x3D; false;
        }
        if (!responseSafeToPrecache) {
            // Throwing here will lead to the &#x60;install&#x60; handler failing, which
            // we want to do if *any* of the responses aren&#x27;t safe to cache.
            throw new WorkboxError(&#x27;bad-precaching-response&#x27;, {
                url: request.url,
                status: response.status,
            });
        }
        return response;
    }
    /**
     * Returns true if any users plugins were added containing their own
     * &#x60;cacheWillUpdate&#x60; callback.
     *
     * This method indicates whether the default cacheable response logic (i.e.
     * &amp;lt;400, including opaque responses) should be used. If a custom plugin
     * with a &#x60;cacheWillUpdate&#x60; callback is passed, then the strategy should
     * defer to that plugin&#x27;s logic.
     *
     * @private
     */
    _usesCustomCacheableResponseLogic() {
        return this.plugins.some((plugin) &#x3D;&gt; plugin.cacheWillUpdate &amp;amp;&amp;amp;
            plugin !&#x3D;&#x3D; copyRedirectedCacheableResponsesPlugin);
    }
}
export { PrecacheStrategy };
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>