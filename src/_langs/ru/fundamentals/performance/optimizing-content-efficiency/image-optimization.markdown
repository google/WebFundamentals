---
layout: article
title: "Оптимизация изображений"
description: "Изображения - те ресурсы, которые часто занимают много места на странице и весят больше всего. Благодаря их оптимизации мы можем значительно уменьшить количество скачиваемых данных и улучшить работу сайта. Чем больше сжато изображение, тем меньше пропускной способности канала занимает скачивание и тем быстрее браузер сможет показать страницу пользователю."
introduction: "Изображения - те ресурсы, которые часто занимают много места на странице и весят больше всего. Благодаря их оптимизации мы можем значительно уменьшить количество скачиваемых данных и улучшить работу сайта. Чем больше сжато изображение, тем меньше пропускной способности канала занимает скачивание и тем быстрее браузер сможет показать страницу пользователю."
article:
  written_on: 2014-05-07
  updated_on: 2014-05-10
  order: 3
collection: optimizing-content-efficiency
authors:
  - ilyagrigorik
key-takeaways:
  replace:
    - Удалите ненужные изображения.
    - При возможности применяйте эффекты CSS3.
    - Используйте веб-шрифты вместо кодировки текста в изображениях.
  vector-raster:
    - Векторный формат отлично подходит для изображений из геометрических фигур.
    - Качество векторных изображений не зависит от масштаба и разрешения.
    - Используйте растровый формат для сложных изображений с множеством нестандартных форм и деталей.
  hidpi:
    - На экранах с высоким разрешением один CSS-пиксель состоит из нескольких экранных пикселей.
    - В изображениях высокого разрешения пикселей и байтов гораздо больше, чем в обычных.
    - Техники оптимизации можно применять к изображениям любого разрешения.
  optimizing-vector:
    - SVG - это формат изображений на основе XML
    - SVG-файлы нужно минифицировать для уменьшения размера.
    - Сжимайте SVG-файлы с помощью GZIP.
  optimizing-raster:
    - Растровое изображение - это сетка пикселей.
    - В каждом пикселе закодирована информация о цвете и прозрачности.
    - Чтобы уменьшить размер изображения, компрессоры используют различные методы для снижения количества битов на пиксель.
  lossless-lossy:
    - Учитывая особенности человеческого зрения, для изображений можно применять сжатие данных с потерями.
    - Для оптимизации изображения используется сжатие данных с потерями и без потерь.
    - Разница в форматах изображений - это отличия в том, как и какие алгоритмы этих сжатий применяются для уменьшения размера ресурса.
    - Не существует самого лучшего формата или настройки качества, которые подошли бы для всех изображений. При сочетании разных компрессоров и ресурсов мы никогда не получим одинаковый результат.
  formats:
    - "Выберите подходящий стандартный формат: GIF, PNG или JPEG."
    - "Попробуйте установить разные настройки для каждого формата (качество, размер палитры и т. д.) и выберите наиболее подходящие."
    - Для современных клиентов добавьте ресурсы в форматах WebP и JPEG XR масштабированные изображения:
    - Масштабирование изображений - один из самых простых и эффективных методов оптимизации.
    - Если вы используете изображения большого размера, пользователь может скачивать лишние данные.
    - Reduce the number of unnecessary pixels by scaling your images to their display size Снизьте количество ненужных пикселей, уменьшив изображение до отображаемого размера.


notes:
  decompressed:
    - "Кроме того, вне зависимости от формата изображения, передаваемого от сервера клиенту, при расшифровке изображения каждый пиксель занимает 4 байта памяти. Поэтому при отображении больших файлов на устройствах с ограниченным количеством памяти могут возникнуть проблемы."
  artifacts:
    - "Изображения в формате PNG слева направо: 32 бита (16M цветов), 7 бит (128 цветов), 5 бит (32 цвета). Сложные изображения с плавными перехода цвета (градиентами, небом и т. д.)  требуют палитр большего размера. Однако если ресурс состоит из небольшого количества цветов, большая палитра - это напрасная трата битов."
  quality:
    - "Обратите внимание, изображения с одинаковыми настройками качества, но в разных форматах будут отличаться. Это происходит из-за разницы в алгоритмах сжатия изображения. Например, JPEG и WebP с настройками качества 90 выглядят по-разному. На самом деле, даже изображения в одном формате и с одинаковыми настройками качества могут отличаться в зависимости от использованного компрессора."
  resized:
    - 'Чтобы узнать исходный и отображаемый размеры изображения, наведите на него курсор в Инструментах разработчика Chrome. В примере выше мы скачиваем изображение размером 300x260 пикселей, однако при показе клиент уменьшает его до 245x212 пикселей.'
---

{% wrap content%}

<style>
  img, video, object {
    max-width: 100%;
  }

  img.center {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
</style>

{% include modules/toc.liquid %}

Оптимизация изображений - это одновременно наука и искусство. Мы можем назвать это искусством, потому что никто не может дать определенный ответ, как лучше всего сжать конкретное изображение. Однако это и наука, ведь в нашем распоряжении есть разработанные техники и алгоритмы, которые могут значительно уменьшить размер ресурса. Чтобы выбрать оптимальные настройки для изображения, необходимо учесть много факторов: возможности формата, закодированные данные, качество, количество пикселей и т. д.

## Удаление и замена изображений

{% include modules/takeaway.liquid list=page.key-takeaways.replace %}

Прежде всего задайте себе вопрос: действительно ли это изображение необходимо? Хороший дизайн должен быть простым и не ухудшать производительность. Лучше всего просто удалить ненужное изображение, поскольку оно весит гораздо больше байтов по сравнению с HTML, CSS, JavaScript и другими ресурсами на странице. При этом одно изображение в нужном месте может заменить длинный текст, поэтому вам нужно самостоятельно найти баланс и принять правильное решение.

После этого вы должны проверить, нельзя ли достигнуть желаемого результата более эффективным путем:

* Благодаря **CSS-эффектам** (градиентам, теням и т. д.) и CSS-анимации вы можете создать ресурсы, которые четко выглядят при любом разрешении и масштабе и весят гораздо меньше, чем изображения.
* **Веб-шрифты** позволяют использовать красивые надписи, сохраняя возможность выбирать и искать текст, а также менять его размер. Благодаря этому работа с вашим ресурсом станет ещё удобнее.

Избегайте кодирования текста в изображении. Красивые надписи необходимы для качественного дизайна, продвижения бренда и удобной работы с ресурсом, но текст в изображении только мешает всему этом. Его нельзя выбрать, найти, увеличить, скопировать, а также он плохо смотрится на устройствах с высоким разрешением. Конечно, веб-шрифтам также требуется оптимизация, но они помогут избежать вышеперечисленных проблем. Для отображения текста всегда выбирайте именно их.


## Векторные и растровые изображения

{% include modules/takeaway.liquid list=page.key-takeaways.vector-raster %}

Если вы решили, что для достижения результата вам следует использовать именно изображение, выберите для него подходящий формат:

&nbsp;

<div class="clear">
  <div class="g--half">
    <b>Векторное изображение</b>
    <img class="center" src="images/vector-zoom.png" alt="Увеличенное векторное изображение">
  </div>

  <div class="g--half g--last">
    <b>Растровое изображение</b>
    <img src="images/raster-zoom.png" alt="Увеличенное растровое изображение">
  </div>
</div>

* В [векторной графике](http://ru.wikipedia.org/wiki/Векторная_графика) для отображения картинки используются линии, точки и многоугольники.
* В [растровой графике](http://ru.wikipedia.org/wiki/Растровая_графика) индивидуальные значения каждого пикселя в прямоугольной сетке кодируются, и на их основе показывается изображение.

У каждого формата есть свои достоинства и недостатки. Векторный формат идеально подходит для изображений из простых геометрических фигур (например, логотипов, текста, значков и т. д.). Они остаются четкими при любом разрешении и масштабе, поэтому используйте этот формат для больших экранов и ресурсов, которые должны быть показаны в разных размерах.

Однако векторные форматы не подходят для сложных изображений (например, для фотографий). SVG-разметки для описания всех фигур может стать слишком много, но полученное изображение все равно будет выглядеть нереалистично. В этом случае вам стоит использовать растровый формат изображений, например GIF, PNG, JPEG или новые форматы JPEG-XR и WebP.

Качество растровых изображений зависит от разрешения и масштаба: при увеличении оно становится размытым и распадается на пиксели. В результате вам может понадобиться сохранить несколько версий растрового изображения в разных разрешениях.


## Оптимизация для экранов с высоким разренением

{% include modules/takeaway.liquid list=page.key-takeaways.hidpi %}

Говоря о пикселях, следует различать экранные и CSS-пиксели. CSS-пиксель может соответствовать одному или нескольким экранным. Это сделано для того, чтобы на устройствах с большим количеством экранных пикселей изображение было более четким и детализированным.

<img src="images/css-vs-device-pixels.png" class="center" alt="Экранные и CSS-пиксели">

Конечно, на экранах с высоким DPI (HiDPI) графика выглядит очень красиво. Однако, чтобы хорошо смотреться в высоком разрешении, наши изображения должны быть более детализированными. Но у нас есть решение: векторные форматы идеально подходят для этой задачи. Они сохраняют четкость в любом разрешении. Даже если увеличатся затраты на отрисовку мелких деталей, мы по-прежнему используем один независимый от размера экрана ресурс.

С другой стороны, с растровыми изображениями возникает гораздо больше сложностей, потому что они кодируют данные изображения в каждом пикселе. Таким образом, чем выше число пикселей, тем больше размер такого ресурса. В качестве примера рассмотрим разницу между фотографиями размером 100х100 CSS-пикселей:

<table class="table-3">
<colgroup><col span="1"><col span="1"><col span="1"></colgroup>
<thead>
  <tr>
    <th>Разрешение экрана</th>
    <th>Всего пикселей</th>
    <th>Размер файла без сжатия (4 Б на пикс.)</th>
  </tr>
</thead>
<tbody>
<tr>
  <td data-th="разрешение">1x</td>
  <td data-th="всего пикселей">100 x 100 = 10 000</td>
  <td data-th="размер файла">40 000 Б</td>
</tr>
<tr>
  <td data-th="разрешение">2x</td>
  <td data-th="всего пикселей">100 x 100 x 4 = 40 000</td>
  <td data-th="размер файла">160 000 Б</td>
</tr>
<tr>
  <td data-th="разрешение">3x</td>
  <td data-th="всего пикселей">100 x 100 x 9 = 90 000</td>
  <td data-th="размер файла">360 000 Б</td>
</tr>
</tbody>
</table>

Когда мы вдвое увеличиваем разрешение экрана, общее количество пикселей возрастает сразу в четыре раза: в два раза по вертикали и в два по горизонтали.

Подведем итог. На экранах с большим разрешением графика выглядят очень привлекательно, поэтому вы сможете создать хорошее впечатление о вашем сайте. Однако для таких экранов нужны изображения с высоким разрешением. Выбирайте векторные форматы, потому что они четко выглядят на любых устройствах. Если необходимо использовать растровое изображение, добавьте несколько оптимизированных вариантов ресурса (см. далее).


## Оптимизация векторных изображений

{% include modules/takeaway.liquid list=page.key-takeaways.optimizing-vector %}

Все современные браузеры поддерживают формат SVG (Scalable Vector Graphics). Это формат изображений на основе XML для двухмерной графики. Разметку SVG можно встроить прямо в страницу или на внешний ресурс. В свою очередь, файл SVG можно создать с помощью любого ПО для векторного рисования или вручную в текстовом редакторе.

{% highlight xml %}
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 17.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.2" baseProfile="tiny" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
   x="0px" y="0px" viewBox="0 0 612 792" xml:space="preserve">
<g id="XMLID_1_">
  <g>
    <circle fill="red" stroke="black" stroke-width="2" stroke-miterlimit="10" cx="50" cy="50" r="40"/>
  </g>
</g>
</svg>
{% endhighlight %}

Пример выше отрисовывает простую круглую форму с черной границей и красным фоном. Она была экспортирована из Adobe Illustrator. Легко догадаться, что она содержит множество метаданных, например информацию о слоях, комментарии и пространства имен XML, которые чаще всего не нужны для отобрадения ресурса в браузере. В результате, следует минифицировать файлы SVG с помощью инструмента [svgo](https://github.com/svg/svgo).

Например, svgo уменьшает размер приведенного выше файла SVG на 58% с 470 до 199 Б. Кроме того, поскольку SVG - это формат на основе XML, мы может применить сжатие GZIP для уменьшения его размера при передаче. Убедитесь, что на вашем сервере настроено сжатие SVG-ресурсов.


## Оптимизация растровых изображений

{% include modules/takeaway.liquid list=page.key-takeaways.optimizing-raster %}

Растровое изображение - это просто двухмерная сетка отдельных `пикселей`. Например, изображение 100x100 пикселей - это последовательно из 10 000 пикселей. В каждом из пикселей содержатся значения RGBA: красного (R), зеленого (G) и синего (B) канала, а также альфа-канала, или канала прозрачности (A).

Браузер устанавливает 256 значений (оттенков) для каждого канала, которые в пере счете занимают 8 битов на канал (2 ^ 8 = 256) и 4 байта на пиксель (4 канала x 8 бит = 32 бита = 4 байта). Таким образом, зная размеры сетки, мы легко можем вычислить размер файла:

* Изображение 100 x 100 пикс. состоит из 10 000 пикселей
* 10 000 пикс. x 4 Б = 40 000 Б
* 40 000 Б / 1024 = 39 КБ

^

{% include modules/remember.liquid title="Note" list=page.notes.decompressed %}

<table class="table-3">
<colgroup><col span="1"><col span="1"><col span="1"></colgroup>
<thead>
  <tr>
    <th>Размер</th>
    <th>Пиксели</th>
    <th>Размер файла</th>
  </tr>
</thead>
<tbody>
<tr>
  <td data-th="размер">100 x 100</td>
  <td data-th="пиксели">10 000</td>
  <td data-th="размер файла">39 КБ</td>
</tr>
<tr>
  <td data-th="размер">200 x 200</td>
  <td data-th="пиксели">40 000</td>
  <td data-th="размер файла">156 КБ</td>
</tr>
<tr>
  <td data-th="размер">300 x 300</td>
  <td data-th="пиксели">90 000</td>
  <td data-th="размер файла">351 КБ</td>
</tr>
<tr>
  <td data-th="размер">500 x 500</td>
  <td data-th="пиксели">250 000</td>
  <td data-th="размер файла">977 КБ</td>
</tr>
<tr>
  <td data-th="размер">800 x 800</td>
  <td data-th="пиксели">640 000</td>
  <td data-th="размер файла">2500 КБ</td>
</tr>
</tbody>
</table>

Может показаться, что 39 КБ - это совсем немного для изображения размером 100x100 пикселей. Однако при увеличении размера файл будет весить гораздо больше, и на его скачивание придется потратить много времени и ресурсов. Сейчас это изображение не сжато. Что можно сделать, чтобы уменьшить его размер?

Один из простых способов оптимизации изображения - снизить глубину цвета с 8 битов на канал, выбрав палитру меньшего размера. Установив глубину в 8 битов на канал, мы получаем 256 значений для канала и 16 777 216 (2563) цветов. Может, стоит уменьшить палитру до 256 цветов? Тогда нам будет нужно всего 8 бит для всех каналов RGB и только 2 байта на пиксель, а не 4, как раньше. Нам удалось сжать изображения в два раза!

<img src="images/artifacts.png" class="center" alt="Шумы при сжатии">

{% include modules/remember.liquid title="Note" list=page.notes.artifacts %}

Оптимизировав данные в отдельных пикселях, обратим внимания на соседние пиксели. Оказывается, цвет таких пикселей на многих изображениях, особенно на фотографиях, часто похож. Благодаря этому компрессор может применять [дельта-кодирование](http://ru.wikipedia.org/wiki/Дельта-кодирование). Вместо сохранения отдельных значения для каждого пикселя можно указать только разницу между соседними пикселями. Если они одинаковы, то дельта равна нулю, и нам нужно сохранить всего один бит. Но это ещё не все!

Мы часто не замечаем разницы в некоторых оттенках, поэтому мы можем оптимизировать изображение, уменьшив или увеличив палитру для этих цветов.
У каждого пикселя в двухмерной сетке есть несколько `соседей`, поэтому мы можем усовершенствовать дельта-кодирование.
Сконцентрируетесь не на непосредственных соседях пикселя, а на целых блоках похожих цветов и закодируйте их с помощью разных настроек.

Как вы видите, оптимизация изображения становится все сложнее и интереснее. На эту тему ведутся научные и коммерческие исследования, потому что изображения весят много байтов, и развивать новые техники сжатия выгодно. Если вы хотите узнать больше, прочитайте [статью на Википедии](http://ru.wikipedia.org/wiki/Сжатие_изображений) или ознакомьтесь с конкретными примерами в [брошюре о техниках сжатия WebP](https://developers.google.com/speed/webp/docs/compression).

Итак, как весь этот сложный материал поможет нам оптимизировать изображения? Повторим: нам не нужно изобретать новые методы сжатия. Однако нам нужно знать о ключевых аспектах вопроса: пикселях RGBA, глубине цвета и разных техниках оптимизации. Это необходимо, чтобы продолжить разговор о растровых форматах.


## Сжатие данных с потерями и без потерь

{% include modules/takeaway.liquid list=page.key-takeaways.lossless-lossy %}

Для определенных типов данных, например исходного кода страницы или исполняемого файла, крайне важно, чтобы компрессор не удалял и не менял первоначальную информацию. Из-за пропавшего или неправильного бита данных может быть полностью искажено или уничтожено значение контента файла. Однако другие типы данных вполне можно передать в `приблизительном` виде.

Из-за особенностей человеческого зрения мы можем не заметить отсутствия какой-либо информации о каждом пикселе, например мы не увидим различия между некоторыми оттенками цвета. Поэтому мы можем использовать меньше битов для кодирования некоторых цветов и благодаря этому уменьшить размер ресурса. Таким образом, стандартная оптимизация изображения состоит из двух основных этапов:

1. Сжатие изображения `[с потерями](http://ru.wikipedia.org/wiki/Сжатие_данных_с_потерями)`, при котором удаляются некоторые данные пикселей.
1. Сжатие изображения `[без потерь](http://en.wikipedia.org/wiki/Lossless_compression)`, при котором данные пикселей сжимаются.

**Выполнять первый шаг необязательно. Точный алгоритм зависит от определенного формата изображения, однако учтите, что каждое изображение можно сжать с потерей данных. ** На самом деле, разница между форматами изображений, например GIF, PNG, JPEG и т. д., состоит именно в комбинации различных алгоритмов сжатия данных с потерей и без потерь.

Как лучше всего совмещать сжатие с потерями и без потерь? Это зависит от самого изображения и других условий, например баланса между размером файла и шумами. Чтобы получить четкое детализированное изображение, вы можете не применять сжатие с потерями. Если же для вас больше важен размер файла, смело используйте этот метод оптимизации.  Единого варианта настроек для всех изображений не существует. Вы сами должны определить желаемый результат и принять решение.

<img src="images/save-for-web.png" class="center" alt="Сохранить для web">

При использовании сжатия с потерями, например JPEG, вы сможете выбрать настройки качества (вроде ползунка `Сохранить для Web` в Adobe Photoshop). Обычно это значение от 1 до 100, которое определяет применение алгоритмов сжатия с потерями и без. Не бойтесь снижать качество: часто изображение по-прежнему хорошо выглядит, а размер файла становится значительно меньше.

{% include modules/remember.liquid title="Note" list=page.notes.quality %}


## Выбор формата изображения

{% include modules/takeaway.liquid list=page.key-takeaways.formats %}

Помимо алгоритмов сжатия с потерями и без потерь, в форматах изображения поддерживаются другие функции, например анимация и канал прозрачности (альфа-канал). Таким образом, при выборе подходящего формата вам нужно учесть желаемый визуальный эффект и требования к сайту или приложению.


<table class="table-4">
<colgroup><col span="1"><col span="1"><col span="1"><col span="1"></colgroup>
<thead>
  <tr>
    <th>Формат</th>
    <th>Прозрачность</th>
    <th>Анимация</th>
    <th>Браузер</th>
  </tr>
</thead>
<tbody>
<tr>
  <td data-th="формат"><a href="http://ru.wikipedia.org/wiki/GIF">GIF</a></td>
  <td data-th="прозрачность">Да</td>
  <td data-th="анимация">Да</td>
  <td data-th="браузер">Все</td>
</tr>
<tr>
  <td data-th="формат"><a href="http://ru.wikipedia.org/wiki/PNG">PNG</a></td>
  <td data-th="прозрачность">Да</td>
  <td data-th="анимация">Нет</td>
  <td data-th="браузер">Все</td>
</tr>
<tr>
  <td data-th="формат"><a href="http://ru.wikipedia.org/wiki/JPEG">JPEG</a></td>
  <td data-th="прозрачность">Нет</td>
  <td data-th="анимация">Нет</td>
  <td data-th="браузер">Все</td>
</tr>
<tr>
  <td data-th="формат"><a href="http://ru.wikipedia.org/wiki/JPEG_XR">JPEG XR</a></td>
  <td data-th="прозрачность">Да</td>
  <td data-th="анимация">Да</td>
  <td data-th="браузер">IE</td>
</tr>
<tr>
  <td data-th="формат"><a href="http://ru.wikipedia.org/wiki/WebP">WebP</a></td>
  <td data-th="Прозрачность">Да</td>
  <td data-th="анимация">Да</td>
  <td data-th="браузер">Chrome, Opera, Android</td>
</tr>
</tbody>
</table>

Существуют три стандартных формата изображений: GIF, PNG и JPEG. Кроме них некоторые браузеры поддерживают новые форматы WebP и JPEG XR, для которых доступно большее сжатие и дополнительные возможности. Итак, какой формат выбрать?

<img src="images/format-tree.png" class="center" alt="Сохранить для web">

1. **Изображение должно быть анимированным? Тогда выбирайте формат GIF.**
  * Цветовая палитра GIF состоит всего из 256 цветов. Это недостаточно для большинства изображений. Кроме того, формат PNG-8 лучше сжимает изображения с маленькой палитрой. Таким образом, выбирайте GIF, только если вам требуется анимация.
1. **Нужно сохранить все мелкие детали в самом высоком разрешении? Используйте PNG.**
  * В формате PNG не применяется сжатие с потерей данных, не считая выбора размера палитры. Благодаря этому изображение сохраняется в самом высоком качестве, но весит гораздо больше, чем файлы других форматов. Используйте этот формат только там, где это необходимо.
  * Если изображение состоит из геометрических фигур, конвертируйте его в векторный (SVG-) формат!
  * Избегайте текста в изображениях. Его нельзя выбрать, найти или увеличить. Если текст необходим для создания дизайна, используйте веб-шрифты.
1. **Вы оптимизируете фотографию, скриншот или избражение похожего типа? Используйте JPEG.**
  * В JPEG используется комбинация сжатия с потерями и без потерь для уменьшения размера файла. Чтобы выбрать лучшее сочетание качества и размера изображения, попробуйте установить несколько уровней качества JPEG.

Определив подходящий формат и его настройки для всех ресурсов, добавьте дополнительный вариант в WebP и JPEG XR. Это новые форматы, которые пока не поддерживаются во всех браузерах. Однако с их помощью может значительно уменьшить размер файла. Например, WebP сжимает изображение на [30% ](https://developers.google.com/speed/webp/docs/webp_study) больше, чем JPEG.

Поскольку WebP and JPEG XR поддерживаются не во всех браузерах, вам надо добавить дополнительную логику в приложения или на серверы, чтобы отправлять пользователю соответствующий ресурс.

* Некоторые сети доставки контента предоставляют услуги по оптимизации изображений, в том числе предоставление файлов в JPEG XR и WebP.
* Некоторые инструменты с открытым кодом, например PageSpeed для Apache и Nginx, автоматически производят оптимизацию, преобразование и доставку соответствующих ресурсов.
* Вы можете добавить дополнительную логику приложения, чтобы определить клиент и его поддерживаемые форматы, а затем отправить оптимальный вариант ресурса.

Обратите внимание, что если вы используете Webview для отрисовки контента в нативное приложении, тогда вы можете полностью управлять клиентом и использовать только WebP. В приложениях Facebook, Google+ и т. д. используются именно WebP-ресурсы, так как они действительно повышают производительность. Чтобы узнать больше об этом формате, посмотрите презентацию [WebP: Deploying Faster, Smaller, and More Beautiful Images](https://www.youtube.com/watch?v=pS8udLMOOaE) от Google I/O 2013.


## Инструменты и выбор параметров

Не существует одного идеального формата, инструмента или алгоритма оптимизации, который бы подошел бы для всех изображений. Чтобы получить наилучший результат, вы должны выбрать формат и его настройки в зависимости от контента, а также визуальных и технических требований.

<table class="table-2">
<colgroup><col span="1"><col span="1"></colgroup>
<thead>
  <tr>
    <th>Инструмент</th>
    <th>Описание</th>
  </tr>
</thead>
<tbody>
<tr>
  <td data-th="инструмент"><a href="http://www.lcdf.org/gifsicle/">gifsicle</a></td>
  <td data-th="описание">создает и оптимизирует GIF-изображения</td>
</tr>
<tr>
  <td data-th="инструмент"><a href="http://jpegclub.org/jpegtran/">jpegtran</a></td>
  <td data-th="описание">оптимизирует JPEG-изображения</td>
</tr>
<tr>
  <td data-th="инструмент"><a href="http://optipng.sourceforge.net/">optipng</a></td>
  <td data-th="описание">сжимает PNG без потерь</td>
</tr>
<tr>
  <td data-th="инструмент"><a href="http://pngquant.org/">pngquant</a></td>
  <td data-th="описание">сжимает PNG с потерями</td>
</tr>
</tbody>
</table>


Не бойтесь экспериментировать с параметрами компрессоров. Установите разные настройки качества, выберите подходящий вариант и примените его к другим похожим изображениям на сайте. Но помните: не все графические ресурсы нужно сжимать одним и тем же методом!


## Масштабирование передаваемых изображений

{% include modules/takeaway.liquid list=page.key-takeaways.scaled-images %}

Размер изображения - это сумма пикселей, умноженная на число байтов, используемых для кодирования каждого пикселя. Оптимизация изображения сводится к уменьшения этих двух составляющих.

Таким образом, один из самых простых и эффективных методов оптимизации - убедиться, что размер отправляемого изображения не больше, чем его отображаемый размер в браузере. Ничего сложного, но многие сайты совершают серьезную ошибку. Они размещают крупные ресурсы, и браузеру приходится самому масштабировать и отображать их в более низком разрешении. Помимо всего прочего, это увеличивает нагрузку на процессор пользователя.

<img src="images/resized-image.png" class="center" alt="Масштабированное изображение">

{% include modules/remember.liquid title="Note" list=page.notes.resized %}

Отправляя лишние пиксели и предоставляя браузеру самому масштабировать ресурс, мы упускаем возможность оптимизировать количество байтов, нужных для отрисовки страницы. Обратите внимание, что при масштабировании не только уменьшается количество пикселей, но и меняется исходный размер изображения.

<table class="table-3">
<colgroup><col span="1"><col span="1"><col span="1"></colgroup>
<thead>
  <tr>
    <th>Исходный размер</th>
    <th>Отображаемый размер</th>
    <th>Ненужные пиксели</th>
  </tr>
</thead>
<tbody>
<tr>
  <td data-th="исходный">110 x 110</td>
  <td data-th="отображаемый">100 x 100</td>
  <td data-th="перерасход">110 x 110 - 100 x 100 = 2100</td>
</tr>
<tr>
  <td data-th="исходный">410 x 410</td>
  <td data-th="отображаемый">400 x 400</td>
  <td data-th="перерасход">410 x 410 - 400 x 400 = 8100</td>
</tr>
<tr>
  <td data-th="исходный">810 x 810</td>
  <td data-th="отображаемый">800 x 800</td>
  <td data-th="перерасход">810 x 810 - 800 x 800 = 16100</td>
</tr>
</tbody>
</table>

Обратите внимание, что во всех трех случаях отображаемый размер `всего лишь на 10 пикселей` меньше, чем исходный. Однако чем больше первоначальный размер изображения, тем больше лишних данных приходится кодировать и отправлять. Даже если вам не удастся установить полное совпадение исходного и отображаемого размеров, **вы должны максимально сократить количество ненужных пикселей.**

## Список методов оптимизации

Оптимизация изображений - это одновременно наука и искусство. Мы можем назвать это искусством, потому что никто не может дать определенный ответ, как лучше всего сжать конкретное изображение. Однако это и наука, ведь в нашем распоряжении есть разработанные техники и алгоритмы, которые могут значительно уменьшить размер ресурса.

Помните о некоторых советах и техниках, которые помогут вам оптимизировать изображения:

* **Выбирайте изображения в векторных форматах.** Их качество не зависит от разрешения и масштаба, поэтому они подходят для больших экранов и разных типов устройств.
* ** Минифицируйте и сжимайте SVG-ресурсы.** Многие графические приложения  добавляют XML-разметку, которая часто содержит ненужные метаданные. Ее можно удалить. Убедитесь, что на серверах настроено GZIP-сжатие для SVG-ресурсов.
* **Выбирайте наиболее подходящие растровые форматы.** Определите необходимые требования к изображениям и выберите нужный формат для каждого ресурса.
* **Пробуйте разные настройки качеств для растровых форматов.** Не бойтесь снижать качество: часто изображение по-прежнему хорошо выглядит, а размер файла становится значительно меньше.
* **Удаляйте ненужные метаданные.** Многие растровые изображения содержат лишнюю информацию о ресурсе: геоданные, сведения о камере и т. д. Для их удаления используйте соответствующие инструменты.
* **Масштабируйте изображения.** Уменьшайте файлы на сервере, чтобы исходный и отображаемый размеры были практически одинаковы. Обратите особое внимание на большие изображения. Если их масштабирует браузер, производительность вашего сайта значительно снижается.
* **Автоматизируйте.** Используйте надежные инструменты и ПО, которые будут автоматически оптимизировать изображения на вашем сайте.


{% include modules/nextarticle.liquid %}

{% endwrap %}

